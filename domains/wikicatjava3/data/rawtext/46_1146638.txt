perl  perl  is a member of the perl family of programming languages while historically several interpreter and compiler implementations were being written today only the rakudo perl implementation is in active development it is introducing elements of many modern and historical languages compatibility with perl  is not a goal though a compatibility mode is part of the specification the design process for perl  began in  in february  a post on the perl foundation blog stated that the perl team will attempt to get a development release of version  available for larrys birthday in september and a version  release by christmas and on december   the first stable version of the specification was announced development on pugs the first hightraction implementation began in  and there have been multiple perl  implementation projects rakudo perl is based on nqp not quite perl and can use moarvm or the java virtual machine as a runtime environment and releases a new version every month in july  the project released the first rakudo star distribution a useful and usable collection of a perl  implementation and related materials larry wall maintains a reference grammar known as stdpm written in perl  and bootstrapped with perl  history the perl  design process was first announced on july   on the fourth day of that years perl conference by larry wall in his state of the onion  talk at that time the primary goals were to remove historical warts from the language easy things should stay easy hard things should get easier and impossible things should get hard a general cleanup of the internal design and apis the process began with a series of requests for comments or rfcs this process was open to all contributors and left no aspect of the language closed to change once the rfc process was complete wall reviewed and classified each request  were received he then began the process of writing several apocalypses a term which means revealing while the original goal was to write one apocalypse for each chapter of programming perl it became obvious that as each apocalypse was written previous apocalypses were being invalidated by later changes for this reason a set of synopses were published each one relating the contents of an apocalypse but with any subsequent changes reflected in updates today perl  specification continues almost entirely within the synopses there are also a series of exegeses written by damian conway that explain the content of each apocalypse in terms of practical usage each exegesis consists of code examples along with discussion of the usage and implications of the examples there are three primary methods of communication used in the development of perl  today the first is the irc channel on freenode the second is a set of mailing lists on the perl foundations servers at perlorg the third is the git source code repository hosted at httpsgithubcomperl goals the break in compatibility was mandated from the start of the project and immediately allowed some of the changes that larry wall had suggested in his initial speech historical warts such as the confusion surrounding sigil usage for containers the ambiguity between the codice functions the syntactic impact of bareword filehandles and many other problems that perl programmers had discussed fixing for years were some of the first issues addressed over the years perl  has undergone several alterations in its direction the introduction of concepts from python and ruby were early influences but as the pugs interpreter was written in the haskell programming language many functional programming influences were absorbed by the perl  design team mascot the languages mascot is camelia the perl  bug her name is a nod to the camel mascot associated with perl and her form in the punloving tradition of the perl community is a play on software bug spiral designs embedded in her butterflylike wings resemble the characters p the favored nickname for perl  implementations  only the rakudo perl implementation is under active development no implementation will be designated as the official perl  implementation rather perl  is anything that passes the official test suite rakudo perl targets a number of virtual machines such as moarvm the java virtual machine and javascript moarvm is a virtual machine designed for gradually typed programming languages primarily for perl  there is a layer between perl  and the virtual machines called not quite perl  or nqp which implements perl  rules for parsing perl  as well as an abstract syntax tree and backendspecific code generation large portions of rakudo are written in perl  itself or in its subset nqp rakudo is not a completely selfhosting implementation nor are there concrete plans at this point to make rakudo a bootstrapping compiler historical implementations pugs was an initial implementation of perl  written in haskell pugs used to be the most advanced implementation of perl  but since mid  it is mostly dormant with updates made only to track the current version of ghc as of november  pugs is not being actively maintained in  vminiperl mp and its reimplementation vkindaperl kp were written as a means to bootstrap the perl std using perl  the std is a full grammar for perl  and is written in perl  in theory anything capable of parsing the std and generating executable code is a suitable bootstrapping system for perl  kp is currently compiled by mp and can work with multiple backends mp and kp are not full perl  implementations and are designed only to implement the minimum featureset required to bootstrap a full perl  compiler yapsi is a perl  compiler and runtime written in perl  itself as a result it requires an existing perl  interpreter such as one of the rakudo star releases in order to run niecza another major perl  implementation effort focused on optimization and efficient implementation research it targets the common language infrastructure module system the perl  specification requests that modules are identified by name version and authority it is possible to load only a specific version of a module or even two modules of the same name that differ in version or authority as a convenience aliasing to a short name is provided cpan the perl  module distribution system does not yet handle perl  modules instead a prototype module system is in use major changes from perl  perl  and perl  differ fundamentally though in general the intent has been to keep perl  perl so that perl  is clearly a perl programming language most of the changes are intended to normalize the language to make it easier for novice and expert programmers alike to understand and to make easy things easier and hard things more possible a specification a major but nontechnical difference between perl  and perl  is that perl  began as a specification this means that perl  can be reimplemented if needed and it also means that programmers dont have to read the source code for the ultimate authority on any given feature perl s documentation is regarded as excellent even outside of the perl community where even mixed reviews typically note its maturity and breadth however the documentation is not considered authoritative and only describes the behavior of the actual perl  interpreter informally any discrepancies found between the documentation and the implementation may lead to either being changed to reflect the other a dynamic which drives the continuing development and refinement of the perl  releases a type system in perl  the dynamic type system of perl  has been augmented by the addition of static types for example however static typing remains optional so programmers can do most things without any explicit typing at all perl  offers a gradual typing system whereby the programmer may choose to use static typing use dynamic typing or mix the two formal subroutine parameter lists perl  defines subroutines without formal parameter lists at all though simple parameter counting and some very loose type checking can be done using perl s prototypes subroutine arguments passed in are aliased into the elements of the array  if the elements of  are modified the changes are reflected in the original data perl  introduces true formal parameters to the language in perl  a subroutine declaration looks like this as in perl  the formal parameters ie the variables in the parameter list are aliases to the actual parameters the values passed in but by default the aliases are constant so they cannot be modified they may be declared explicitly as readwrite aliases for the original value or as copies using the codice or codice directives should the programmer require them to be modified locally parameter passing modes perl  provides three basic modes of parameter passing positional parameters are the typical ordered list of parameters that most programming languages use all parameters may also be passed by using their name in an unordered way a namedonly parameter can only be passed by specifying its name that is it never captures a positional argument and are indicated with a leading codice character slurpy parameters indicated by an codice before the parameter name are perl s tool for creating variadic functions a slurpy hash will capture remaining passedbyname parameters whereas a slurpy array will capture remaining passedbyposition parameters here is an example of the use of all three parameterpassing modes positional parameters such as those used above are always required unless followed by codice to indicate that they are optional named parameters are optional by default but may be marked as required by adding codice after the variable name slurpy parameters are always optional blocks and closures parameters can also be passed to arbitrary blocks which act as closures this is how for example codice and codice loop iterators are named in the following example a list is traversed  elements at a time and passed to the loops block as the variables codice this is generally referred to as a pointy sub or pointy block and the arrow behaves almost exactly like the codice keyword introducing an anonymous closure or anonymous subroutine in perl  terminology sigil invariance in perl  sigils  the punctuation characters that precede a variable name  change depending on how the variable is used in perl  sigils are invariant which means that they do not change based on whether it is the array or the array element that is needed the variance in perl  is inspired by number agreement in english and many other natural languages however this conceptual mapping breaks down when references come into play since they may refer to data structures even though they are scalars thus dealing with nested data structures may require an expression of both singular and plural form in a single term this complexity has no equivalent either in common use of natural language or in other programming languages and it causes high cognitive load when writing code to manipulate complex data structures compare this with perl  objectoriented programming perl  supports objectoriented programming via a mechanism known as blessing any reference can be blessed into being an object of a particular class a blessed object can have methods invoked on it using the arrow syntax which will cause perl to locate or dispatch an appropriate subroutine by name and call it with the blessed variable as its first argument while extremely powerful it makes the most common case of object orientation a structlike object with some associated code unnecessarily difficult in addition because perl can make no assumptions about the object model in use method invocation cannot be optimized very well in the spirit of making the easy things easy and hard things possible perl  retains the blessing model and supplies a more robust object model for the common cases for example a class to encapsulate a cartesian point could be defined and used this way the dot replaces the arrow in a nod to the many other languages eg java python etc that have coalesced around dot as the syntax for method invocation in the terminology of perl  codice is called an attribute some languages call these fields or members the method used to access an attribute is called an accessor autoaccessors are methods that are created automatically as the method codice is in the example above these accessor functions return the value of the attribute when a class or individual attribute is declared with the codice modifier short for readwrite the autoaccessor can be passed a new value to set the attribute to or it can be directly assigned to as an lvalue as in the example autoaccessors can be replaced by userdefined methods should the programmer desire a richer interface to an attribute attributes can only be accessed directly from within a class definition all other access must go through the accessor methods the perl  object system has inspired the moose framework that introduces many of perl s oop features to perl  roles roles in perl  take on the function of interfaces in java mixins in ruby and traits in the smalltalk variant squeak these are much like classes but provide a safer composition mechanism these are used to perform composition when used with classes rather than adding to their inheritance chain roles define nominal types they provide semantic names for collections of behavior and state the fundamental difference between a role and a class is that classes are instantiable roles are not essentially a role is a bundle of possibly abstract methods and attributes that can be added to a class without using inheritance a role can even be added to an individual object in this case perl  will create an anonymous subclass add the role to the subclass and change the objects class to the anonymous subclass for example a dog is a mammal dogs inherit certain characteristics from mammals such as mammary glands and through mammals parent vertebrate a backbone dogs may have one of several distinct types of behavior for example a dog may be a pet a stray or a guide for the blind however these are simply sets of additional behaviors that can be added to a dog a cat can equally be a pet or stray for example hence dog and mammal are classes while pet stray and guide are roles roles are added to a class or object with the codice keyword as opposed to inheritances codice the keywords reflect the differing meanings of the two features role composition gives a class the behavior of the role but doesnt indicate that it is truly the same thing as the role although roles are distinct from classes both are types so a role can appear in a variable declaration where one would normally put a class for example a blind role for a human could include an attribute of type guide this attribute could contain a guide dog a guide horse a guide human or even a guide machine regular expressions perls regular expression and stringprocessing support has always been one of its defining features since perls patternmatching constructs have exceeded the capabilities of regular language expressions for some time perl  documentation will exclusively refer to them as regexen distancing the term from the formal definition perl  provides a superset of perl  features with respect to regexes folding them into a larger framework called rules which provide the capabilities of contextsensitive parsing formalisms such as the syntactic predicates of parsing expression grammars and antlr as well as acting as a closure with respect to their lexical scope rules are introduced with the codice keyword which has a usage quite similar to subroutine definition anonymous rules can also be introduced with the codice or codice keyword or they can simply be used inline as regexps were in perl  via the codice matching or codice substitute operators in apocalypse  larry wall enumerated  problems with current regex culture among these were that perls regexes were too compact and cute had too much reliance on too few metacharacters little support for named captures little support for grammars and poor integration with real language syntactic simplification some perl  constructs have been changed in perl  optimized for different syntactic cues for the most common cases for example the parentheses round brackets required in control flow constructs in perl  are now optional also the codice comma operator is now a list constructor so enclosing parentheses are no longer required around lists the code now makes codice an array with exactly the elements    and  chained comparisons perl  allows comparisons to chain that is a sequence of comparisons such as the following are allowed this is treated as if each lefttoright comparison were performed on its own and the result is logically combined via the codice operation lazy evaluation perl  uses the technique of lazy evaluation of lists that has been a feature of some functional programming languages such as haskell the code above will not crash by attempting to assign a list of infinite size to the array codice nor will it hang indefinitely in attempting to expand the list if a limited number of slots are searched this simplifies many common tasks in perl  including inputoutput operations list transformations and parameter passing gather related to lazy evaluation is the construction of lazy lists using codice and codice behaving somewhat like generators in languages like icon or python codice will be an infinite list of square numbers but lazy evaluation of the codice ensures that elements are only computed when they are accessed junctions perl  introduces the concept of junctions values that are composites of other values in their simplest form junctions are created by combining a set of values with junctive operators codice indicates a value which is equal to either its left or righthand arguments codice indicates a value which is equal to both its left and righthand arguments these values can be used in any code that would use a normal value operations performed on a junction act on all members of the junction equally and combine according to the junctive operator so codice would yield codice in comparisons junctions return a single true or false result for the comparison codice junctions return true if the comparison is true for any one of the elements of the junction codice junctions return true if the comparison is true for all of the elements of the junction junctions can also be used to more richly augment the type system by introducing a style of generic programming that is constrained to junctions of types macros in lowlevel languages the concept of macros has become synonymous with textual substitution of sourcecode due to the widespread use of the c preprocessor however highlevel languages such as lisp predated c in their use of macros that were far more powerful it is this lisplike macro concept that perl  will take advantage of the power of this sort of macro stems from the fact that it operates on the program as a highlevel data structure rather than as simple text and has the full capabilities of the programming language at its disposal a perl  macro definition will look like a subroutine or method definition and can operate on unparsed strings an ast representing preparsed code or a combination of the two a macro definition would look like this in this particular example the macro is no more complex than a cstyle textual substitution but because parsing of the macro parameter occurs before the macro operates on the calling code diagnostic messages would be far more informative however because the body of a macro is executed at compile time each time it is used many techniques of optimization can be employed it is even possible to entirely eliminate complex computations from resulting programs by performing the work at compiletime examples hello world the hello world program is a common program used to introduce a language in perl  hello world is  though there is more than one way to do it the codice function prints its arguments like the codice function but with a trailing newline this feature was backported into perl  quicksort quicksort is a wellknown sorting algorithm a working implementation using the functional programming paradigm can be succinctly written in perl  tower of hanoi tower of hanoi is often used to introduce recursive programming in computer science this implementation uses perl s multidispatch mechanism and parametric constraints