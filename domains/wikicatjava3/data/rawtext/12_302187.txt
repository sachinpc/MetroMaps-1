curry programming language curry is an experimental functional logic programming language based on the haskell language it merges elements of functional and logic programming including constraint programming integration it is nearly a superset of haskell lacking support mostly for overloading using type classes which some implementations provide anyway as a language extension such as the mnster curry compiler foundations of functional logic programming basic concepts a functional program is a set of functions defined by equations or rules a functional computation consists of replacing subexpressions by equal with regards to the function definitions subexpressions until no more replacements or reductions are possible and a value or normal form is obtained for instance consider the function double defined by the expression double  is replaced by  the latter can be replaced by  if we interpret the operator  to be defined by an infinite set of equations eg       etc in a similar way one can evaluate nested expressions where the subexpressions to be replaced are quoted there is also another order of evaluation if we replace the arguments of operators from right to left in this case both derivations lead to the same result a property known as confluence this follows from a fundamental property of pure functional languages termed referential transparency the value of a computed result does not depend on the order or time of evaluation due to the absence of side effects this simplifies the reasoning about and maintenance of pure functional programs as many functional languages like haskell do curry supports the definition of algebraic data types by enumerating their constructors for instance the type of boolean values consists of the constructors true and false that are declared as follows functions on booleans can be defined by pattern matching ie by providing several equations for different argument values the principle of replacing equals by equals is still valid provided that the actual arguments have the required form eg more complex data structures can be obtained by recursive data types for instance a list of elements where the type of elements is arbitrary denoted by the type variable a is either the empty list  or the nonempty list xxs consisting of a first element x and a list xs the type list a is usually written as a and finite lists xxxn are written as xxxn we can define operations on recursive types by inductive definitions where pattern matching supports the convenient separation of the different cases for instance the concatenation operation  on polymorphic lists can be defined as follows the optional type declaration in the first line specifies that  takes two lists as input and produces an output list where all list elements are of the same unspecified type beyond its application for various programming tasks the operation  is also useful to specify the behavior of other functions on lists for instance the behavior of a function last that yields the last element of a list can be specified as follows for all lists xs and elements e last xs  e iff ysyse  xs based on this specification one can define a function that satisfies this specification by employing logic programming features similarly to logic languages functional logic languages provide search for solutions for existentially quantified variables in contrast to pure logic languages they support equation solving over nested functional expressions so that an equation like yse   is solved by instantiating ys to the list  and e to the value  in curry one can define the operation last as follows here the symbol  is used for equational constraints in order to provide a syntactic distinction from defining equations similarly extra variables ie variables not occurring in the lefthand side of the defining equation are explicitly declared by wherefree in order to provide some opportunities to detect bugs caused by typos a conditional equation of the form l  c  r is applicable for reduction if its condition c has been solved in contrast to purely functional languages where conditions are only evaluated to a boolean value functional logic languages support the solving of conditions by guessing values for the unknowns in the condition narrowing as discussed in the next section is used to solve this kind of conditions narrowing narrowing is a mechanism whereby a variable is bound to a value selected from among alternatives imposed by constraints each possible value is tried in some order with the remainder of the program invoked in each case to determine the validity of the binding narrowing is an extension of logic programming in that it performs a similar search but can actually generate values as part of the search rather than just being limited to testing them narrowing is useful because it allows a function to be treated as a relation its value can be computed in both directions the curry examples of the previous section illustrate this as noted in the previous section narrowing can be thought of as reduction on a program term graph and there are often many different ways strategies to reduce a given term graph antoy et al proved in the s that a particular narrowing strategy needed narrowing is optimal in the sense of doing a number of reductions to get to a normal form corresponding to a solution that is minimal among sound and complete strategies needed narrowing corresponds to a lazy strategy in contrast to the sldresolution strategy of prolog functional patterns the rule defining last shown above expresses the fact that the actual argument must match the result of narrowing the expression yse curry can express this property also in the following more concise way haskell does not allow such a declaration since the pattern in the lefthand side contains a defined function  such a pattern is also called functional pattern functional patterns are enabled by the combined functional and logic features of curry and support concise definitions of tasks requiring deep pattern matching in hierarchical data structures nondeterminism since curry is able to solve equations containing function calls with unknown values its execution mechanism is based on nondeterministic computations similarly to logic programming this mechanism supports also the definition of nondeterministic operations ie operations that delivers more than one result for a given input the archetype of nondeterministic operations is the predefined infix operation  called choice operator that returns one of its arguments this operator is defined by the following rules thus the evaluation of the expression    returns  as well as  computing with nondeterministic operations and computing with free variables by narrowing has the same expressive power the rules defining  show an important feature of curry all rules are tried in order to evaluate some operation hence one can define by an operation to insert an element into a list at an indeterminate position so that the operation perm defined by returns any permutation of a given input list strategies due to the absence of side effects a functional logic program can be executed with different strategies to evaluate expressions curry uses a variant of the needed narrowing strategy which combines lazy evaluation with nondeterministic search strategies in contrast to prolog which uses backtracking to search for solutions curry does not fix a particular search strategy hence there are implementations of curry like kics where the user can easily select a search strategy like depthfirst search backtracking breadthfirst search iterative deepening or parallel search