java virtual machine a java virtual machine jvm is an abstract computing machine that enables a computer to run a java program there are three notions of the jvm specification implementation and instance the specification is a document that formally describes what is required of a jvm implementation having a single specification ensures all implementations are interoperable a jvm implementation is a computer program that meets the requirements of the jvm specification an instance of a jvm is an implementation running in a process that executes a computer program compiled into java bytecode java runtime environment jre is a software package that contains what is required to run a java program it includes a java virtual machine implementation together with an implementation of the java class library the oracle corporation which owns the java trademark distributes a java runtime environment with their java virtual machine called hotspot java development kit jdk is a superset of a jre and contains tools for java programmers eg a javac compiler the java development kit is provided free of charge either by oracle corporation directly or by the openjdk open source project which is governed by oracle jvm specification the java virtual machine is an abstract virtual computer defined by a specification this specification omits implementation details that are not essential to ensure interoperability the memory layout of runtime data areas the garbagecollection algorithm used and any internal optimization of the java virtual machine instructions their translation into machine code the main reason for this omission is to not unnecessarily constrain implementers any java application can be run only inside some concrete implementation of the abstract specification of the java virtual machine starting with java platform standard edition jse  changes to the jvm specification have been developed under the java community process as jsr   changes to specification to support changes proposed to the class file format jsr  are being done as a maintenance release of jsr  the specification for the jvm was published as the blue book the preface states one of oracles jvms is named hotspot the other inherited from bea systems is jrockit cleanroom java implementations include kaffe and ibm j oracle owns the java trademark and may allow its use to certify implementation suites as fully compatible with oracles specification class loader one of the organizational units of jvm byte code is a class a class loader implementation must be able to recognize and load anything that conforms to the java class file format any implementation is free to recognize other binary forms besides class files but it must recognize class files the class loader performs three basic activities in this strict order in general there are two types of class loader bootstrap class loader and user defined class loader every java virtual machine implementation must have a bootstrap class loader capable of loading trusted classes the java virtual machine specification doesnt specify how a class loader should locate classes bytecode instructions the jvm has instructions for the following groups of tasks the aim is binary compatibility each particular host operating system needs its own implementation of the jvm and runtime these jvms interpret the bytecode semantically the same way but the actual implementation may be different more complex than just emulating bytecode is compatibly and efficiently implementing the java core api that must be mapped to each host operating system jvm languages a jvm language is any language with functionality that can be expressed in terms of a valid class file which can be hosted by the java virtual machine a class file contains java virtual machine instructions java byte code and a symbol table as well as other ancillary information the class file format is the hardware and operating systemindependent binary format used to represent compiled classes and interfaces there are several jvm languages both old languages ported to jvm and completely new languages jruby and jython are perhaps the most wellknown ports of existing languages ie ruby and python respectively of the new languages that have been created from scratch to compile to java bytecode clojure groovy and scala may be the most popular ones a notable feature with the jvm languages is that they are compatible with each other so that for example scala libraries can be used with java programs and vice versa java  jvm implements jsr  supporting dynamically typed languages on the java platform a new feature which supports dynamically typed languages in the jvm this feature is developed within the da vinci machine project whose mission is to extend the jvm so that it supports languages other than java bytecode verifier a basic philosophy of java is that it is inherently safe from the standpoint that no user program can crash the host machine or otherwise interfere inappropriately with other operations on the host machine and that it is possible to protect certain methods and data structures belonging to trusted code from access or corruption by untrusted code executing within the same jvm furthermore common programmer errors that often led to data corruption or unpredictable behavior such as accessing off the end of an array or using an uninitialized pointer are not allowed to occur several features of java combine to provide this safety including the class model the garbagecollected heap and the verifier the jvm verifies all bytecode before it is executed this verification consists primarily of three types of checks the first two of these checks take place primarily during the verification step that occurs when a class is loaded and made eligible for use the third is primarily performed dynamically when data items or methods of a class are first accessed by another class the verifier permits only some bytecode sequences in valid programs eg a jump branch instruction can only target an instruction within the same method furthermore the verifier ensures that any given instruction operates on a fixed stack location allowing the jit compiler to transform stack accesses into fixed register accesses because of this that the jvm is a stack architecture does not imply a speed penalty for emulation on registerbased architectures when using a jit compiler in the face of the codeverified jvm architecture it makes no difference to a jit compiler whether it gets named imaginary registers or imaginary stack positions that must be allocated to the target architectures registers in fact code verification makes the jvm different from a classic stack architecture of which efficient emulation with a jit compiler is more complicated and typically carried out by a slower interpreter the original specification for the bytecode verifier used natural language that was incomplete or incorrect in some respects a number of attempts have been made to specify the jvm as a formal system by doing this the security of current jvm implementations can more thoroughly be analyzed and potential security exploits prevented it will also be possible to optimize the jvm by skipping unnecessary safety checks if the application being run is proven to be safe secure execution of remote code a virtual machine architecture allows very finegrained control over the actions that code within the machine is permitted to take it assumes the code is semantically correct that is it successfully passed the formal bytecode verifier process materialized by a tool possibly offboard the virtual machine this is designed to allow safe execution of untrusted code from remote sources a model used by java applets and other secure code downloads once bytecodeverified the downloaded code runs in a restricted sandbox which is designed to protect the user from misbehaving or malicious code as an addition to the bytecode verification process publishers can purchase a certificate with which to digitally sign applets as safe giving them permission to ask the user to break out of the sandbox and access the local file system clipboard execute external pieces of software or network formal proof of bytecode verifiers have been done by the javacard industry formal development of an embedded verifier for java card byte code bytecode interpreter and justintime compiler for each hardware architecture a different java bytecode interpreter is needed when a computer has a java bytecode interpreter it can run any java bytecode program and the same program can be run on any computer that has such an interpreter when java bytecode is executed by an interpreter the execution will always be slower than the execution of the same program compiled into native machine language this problem is mitigated by justintime jit compilers for executing java bytecode a jit compiler may translate java bytecode into native machine language while executing the program the translated parts of the program can then be executed much more quickly than they could be interpreted this technique gets applied to those parts of a program frequently executed this way a jit compiler can significantly speed up the overall execution time there is no necessary connection between java and java bytecode a program written in java can be compiled directly into the machine language of a real computer and programs written in other languages than java can be compiled into java bytecode java bytecode is intended to be platformindependent and secure some jvm implementations do not include an interpreter but consist only of a justintime compiler jvm in the web browser since very early stages of the design process java and jvm has been marketed as a web technology for creating rich internet applications java applets on the client side web browsers may be extended with a npapi java plugin which executes so called java applets embedded into html pages the applet is allowed to draw into a rectangular region on the page assigned to it and use a restricted set of apis that allow for example access to users microphone or d acceleration java applets were superior to javascript both in performance and features until approximately  when javascript engines in browsers were made significantly faster and the html  suite of web technologies started enhancing javascript with new apis java applets are not able to modify the page outside its rectangular region which is not true about javascript adobe flash player the main competing technology works in the same way in this respect java applets are not restricted to java and in general can be created in any jvm language as of april  google chrome does not allow the use of any npapi plugins mozilla firefox will also ban npapi plugins by the end of  this means that java applets can no longer be used in either browser oracle ultimately announced in january  that it will discontinue the java web browser plugin effective java  javascript jvms and interpreters as of may  javapoly allows users to import unmodified java libraries and invoke them directly from javascript javapoly allows websites to use run unmodified java libraries even if the user does not have java installed on their computer compilation to javascript with the continuing improvements in javascript execution speed combined with the increased use of mobile devices whose web browsers do not implement support for plugins there are efforts to target those users through compilation to javascript it is possible to either compile the source code or jvm bytecode to javascript compiling the jvm bytecode which is universal across jvm languages allows building upon the existing compiler to bytecode main jvm bytecode to javascript compilers are teavm the compiler contained in dragome web sdk bckbrwsr and jjscompiler leading compilers from jvm languages to javascript include the java to javascript compiler contained in google web toolkit clojurescript clojure grooscript groovy scalajs scala and others java runtime environment from oracle the java runtime environment jre released by oracle is a software distribution containing a standalone java vm hotspot browser plugin java standard libraries and a configuration tool it is the most common java environment installed on windows computers it is freely available for download at the website javacom performance the jvm specification gives a lot of leeway to implementors regarding the implementation details since java  jre from oracle contains a jvm called hotspot it has been designed to be a highperformance jvm to speedup code execution hotspot relies on justintime compilation to speedup object allocation and garbage collection hotspot uses generational heap generational heap the java virtual machine heap is the area of memory used by the jvm for dynamic memory allocation in hotspot the heap is divided into generations the permanent generation or permgen was used for class definitions and associated metadata prior to java  permanent generation was not part of the heap the permanent generation was removed from java  originally there was no permanent generation and objects and classes were stored together in the same area but as class unloading occurs much more rarely than objects are collected moving class structures to a specific area allowed significant performance improvements security oracles jre is installed on a large number of computers since any web page the user visits may run java applets java provides an easily accessible attack surface to malicious web sites that the user visits kaspersky labs reports that the java web browser plugin is the method of choice for computer criminals java exploits are included in many exploit packs that hackers deploy onto hacked web sites in the past end users were often using an outofdate version of jre which was vulnerable to many known attacks this led to the widely shared belief between users that java is inherently insecure since java  oracles jre for windows includes automatic update functionality