const computer programming in the c c d and javascript programming languages const is a type qualifier a keyword applied to a data type that indicates that the data is constant does not vary while this can be used to declare constants codice in the c family of languages differs from similar constructs in other languages in being part of the type and thus has complicated behavior when combined with pointers references composite data types and typechecking introduction when applied in an object declaration it indicates that the object is a constant its value does not change unlike a variable this basic use  to declare constants  has parallels in many other languages however unlike in other languages in the c family of languages the codice is part of the type not part of the object for example in c codice declares an object codice of codice type  the codice is part of the type as if it were parsed const int x  while in ada codice declares a constant a kind of object codice of codice type the codice is part of the object but not part of the type this has two subtle results firstly codice can be applied to parts of a more complex type  for example codice declares a constant pointer to a constant integer while codice declares a variable pointer to a constant integer and codice declares a constant pointer to a variable integer secondly because codice is part of the type it must match as part of typechecking for example the following code is invalid void fint x const int i fi because the argument to codice must be a variable integer but codice is a constant integer this matching is a form of program correctness and is known as constcorrectness this allows a form of programming by contract where functions specify as part of their type signature whether they modify their arguments or not and whether their return value is modifiable or not this typechecking is primarily of interest in pointers and references  not basic value types like integers  but also for composite data types or templated types such as containers it is concealed by the fact that the codice can often be omitted due to type coercion implicit type conversion and c being callbyvalue c and d are either callbyvalue or callbyreference consequences the idea of constness does not imply that the variable as it is stored in the computers memory is unwritable rather codiceness is a compiletime construct that indicates what a programmer should do not necessarily what they can do note however that in the case of predefined data such as codice string literals c codice is often unwritable other uses in addition a nonstatic memberfunction can be declared as codice in this case the codice pointer inside such a function is of type codice rather than merely of type codice this means that nonconst functions for this object cannot be called from inside such a function nor can member variables be modified in c a member variable can be declared as codice indicating that this restriction does not apply to it in some cases this can be useful for example with caching reference counting and data synchronization in these cases the logical meaning state of the object is unchanged but the object is not physically constant since its bitwise representation may change syntax in c c and d all data types including those defined by the user can be declared codice and constcorrectness dictates that all variables or objects should be declared as such unless they need to be modified such proactive use of codice makes values easier to understand track and reason about and it thus increases the readability and comprehensibility of code and makes working in teams and maintaining code simpler because it communicates information about a values intended use this can help the compiler as well as the developer when reasoning about code it can also enable an optimizing compiler to generate more efficient code simple data types for simple nonpointer data types applying the codice qualifier is straightforward it can go on either side of the type for historical reasons that is codice is equivalent to codice on some implementations using codice on both sides of the type for instance codice generates a warning but not an error pointers and references for pointer and reference types the meaning of codice is more complicated  either the pointer itself or the value being pointed to or both can be codice further the syntax can be confusing a pointer can be declared as a codice pointer to writable value or a writable pointer to a codice value or codice pointer to codice value a codice pointer cannot be reassigned to point to a different object from the one it is initially assigned but it can be used to modify the value that it points to called the pointee reference variables are thus an alternate syntax for codice pointers a pointer to a codice object on the other hand can be reassigned to point to another memory location which should be an object of the same type or of a convertible type but it cannot be used to modify the memory that it is pointing to a codice pointer to a codice object can also be declared and can neither be used to modify the pointee nor be reassigned to point to another object the following code illustrates these subtleties void foo int  ptr c convention following usual c convention for declarations declaration follows use and the codice in a pointer is written on the pointer indicating dereferencing for example in the declaration codice the dereferenced form codice is an codice while the reference form codice is a pointer to an codice thus codice modifies the name to its right the c convention is instead to associate the codice with the type as in codice and read the codice as modifying the type to the left codice can thus be read as codice is a codice the value is constant or codice is a codice the pointer is a pointer to a constant integer thus int ptr  ptr is an int value int const ptrtoconst  ptrtoconst is a constant int integer value int  const constptr  constptr is a constant int  integer pointer int const  const constptrtoconst  constptrtoconst is a constant pointer c convention following c convention of analyzing the type not the value a rule of thumb is to read the declaration from right to left thus everything to the left of the star can be identified as the pointee type and everything to the right of the star are the pointer properties for instance in our example above codice can be read as a writable pointer that refers to a nonwritable integer and codice can be read as a nonwritable pointer that refers to a writable integer a more generic rule that helps you understand complex declarations and definitions works like this here is an example expression double const funintdouble identifier fun fun is a read to the right int function expecting an int find the matching   returning a pointer to continue right double a function expecting a double find the matching  const returning a constant pointer to continue right  blocks of  read to the left double doubles when reading to the left its important that you read the elements from right to left so an codice becomes a pointer to a const int and not a const pointer to an int in some cases cc allows the codice keyword to be placed to the left of the type here are some examples const int ptrtoconst identical to int const ptrtoconst const int const constptrtoconst identical to int const const constptrtoconst although cc allows such definitions which closely match the english language when reading the definitions from left to right the compiler still reads the definitions according to the abovementioned procedure from right to left but putting codice before what must be constant quickly introduces mismatches between what you intend to write and what the compiler decides you wrote consider pointers to pointers int ptr  a pointer to a pointer to ints int const ptr  a pointer to a pointer to constant int value int const ptr  a pointer to a const pointer to int values int const ptr  a constant pointer to pointers to ints int const const ptr  a constant pointer to pointers to constant int values as a final note regarding pointer definitions always write the pointer symbol the  as much as possible to the right attaching the pointer symbol to the type is tricky as it strongly suggests a pointer type which isnt the case here are some examples int a write int a a is a pointer to an int int a b confusing int a b ugly both a and b are pointers to ints bjarne stroustrups faq recommends only declaring one variable per line if using the c convention to avoid this issue the same considerations apply to defining references and c rvalue references int var   int const reftoconst  var ok int const ref  var ref  var confusing int const constref  var error as references cant change anyway c int rref  int value   confusing more complicated declarations are encountered when using multidimensional arrays and references or pointers to pointers although it is sometimes argued that such declarations are confusing and errorprone and that they therefore should be avoided or be replaced by higherlevel structures it should be noted that the procedure described at the top of this section can always be used without introducing ambiguities or confusion parameters and variables codice can be declared both on function parameters and on variables static or automatic including global or local the interpretation varies between uses a codice static variable global variable or static local variable is a constant and may be used for data like mathematical constants such as codice  realistically longer or overall compiletime parameters a codice automatic variable nonstatic local variable means that single assignment is happening though a different value may be used each time such as codice a codice parameter in passbyreference means that the referenced value is not modified  it is part of the contract  while a codice parameter in passbyvalue or the pointer itself in passbyreference does not add anything to the interface as the value has been copied but indicates that internally the function does not modify the parameter it is a single assignment for this reason some favor using codice in parameters only for passbyreference where it changes the contract but not for passbyvalue where it exposes the implementation c methods in order to take advantage of the design by contract approach for userdefined types structs and classes which can have methods as well as member data the programmer must tag instance methods as codice if they dont modify the objects data members applying the codice qualifier to instance methods thus is an essential feature for constcorrectness and is not available in many other objectoriented languages such as java and c or in microsofts ccli or managed extensions for c while codice methods can be called by codice and noncodice objects alike noncodice methods can only be invoked by noncodice objects the const modifier on an instance method applies to the object pointed to by the codice pointer which is an implicit argument passed to all instance methods thus having const methods is a way to apply constcorrectness to the implicit codice pointer argument just like other arguments this example illustrates class c public void fooc nonconstc const c constc in the above code the implicit codice pointer to codice has the type codice whereas the codice pointer to codice has type codice indicating that the method cannot modify its object through the codice pointer often the programmer will supply both a codice and a noncodice method with the same name but possibly quite different uses in a class to accommodate both types of callers consider class myarray public void foo myarray  array myarray const  constarray  the codiceness of the calling object determines which version of codice will be invoked and thus whether or not the caller is given a reference with which he can manipulate or only observe the private data in the object the two methods technically have different signatures because their codice pointers have different types allowing the compiler to choose the right one returning a codice reference to an codice instead of merely returning the codice by value may be overkill in the second method but the same technique can be used for arbitrary types as in the standard template library loopholes to constcorrectness there are several loopholes to pure constcorrectness in c and c they exist primarily for compatibility with existing code the first which applies only to c is the use of codice which allows the programmer to strip the codice qualifier making any object modifiable the necessity of stripping the qualifier arises when using existing code and libraries that cannot be modified but which are not constcorrect for instance consider this code  prototype for a function which we cannot change but which  we know does not modify the pointee passed in void libraryfuncint ptr int size void calllibraryfuncconst int ptr int size however any attempt to modify an object that is itself declared codice by means of codice results in undefined behavior according to the iso c standard in the example above if codice references a global local or member variable declared as codice or an object allocated on the heap via codice the code is only correct if codice really does not modify the value pointed to by codice the c language has a need of a loophole because a certain situation exists variables with static storage duration are allowed to be defined with an initial value however the initializer can use only constants like string constants and other literals and is not allowed to use nonconstant elements like variable names whether the initializer elements are declared codice or not or whether the static duration variable is being declared codice or not there is a nonportable way to initialize a codice variable that has static storage duration by carefully constructing a typecast on the left hand side of a later assignment a codice variable can be written to effectively stripping away the codice attribute and initializing it with nonconstant elements like other codice variables and such writing into a codice variable this way may work as intended but it causes undefined behavior and seriously contradicts constcorrectness const sizet buffersize   const sizet usertextbuffersize initial value depends on const buffersize cant be initialized here int setupusertextboxtextboxt defaulttextboxtype rectt defaulttextboxlocation another loophole applies both to c and c specifically the languages dictate that member pointers and references are shallow with respect to the codiceness of their owners  that is a containing object that is codice has all codice members except that member pointees and referees are still mutable to illustrate consider this c code struct s void fooconst s  s although the object codice passed to codice is constant which makes all of its members constant the pointee accessible through codice is still modifiable though this may not be desirable from the standpoint of codicecorrectness because codice might solely own the pointee for this reason meyers argues that the default for member pointers and references should be deep codiceness which could be overridden by a codice qualifier when the pointee is not owned by the container but this strategy would create compatibility issues with existing code thus for historical reasons this loophole remains open in c and c the latter loophole can be closed by using a class to hide the pointer behind a codicecorrect interface but such classes either dont support the usual copy semantics from a codice object implying that the containing class cannot be copied by the usual semantics either or allow other loopholes by permitting the stripping of codiceness through inadvertent or intentional copying finally several functions in the c standard library violate constcorrectness as they accept a codice pointer to a character string and return a noncodice pointer to a part of the same string codice and codice are among these functions some implementations of the c standard library such as microsofts try to close this loophole by providing two overloaded versions of some functions a codice version and a noncodice version problems the use of the type system to express constancy leads to various complexities and problems and has accordingly been criticized and not adopted outside the narrow c family of c c and d java and c which are heavily influenced by c and c both explicitly rejected codicestyle type qualifiers instead expressing constancy by keywords that apply to the identifier codice in java codice and codice in c even within c and c the use of codice varies significantly with some projects and organizations using it consistently and others avoiding it codice problem the codice type qualifier causes difficulties when the logic of a function is agnostic to whether its input is constant or not but returns a value which should be of the same qualified type as an input in other words for these functions if the input is constant constqualified the return value should be as well but if the input is variable not constqualified the return value should be as well because the type signature of these functions differs it requires two functions or potentially more in case of multiple inputs with the same logic  a form of generic programming this problem arises even for simple functions in the c standard library notably codice this observation is credited by ritchie to tom plum in the mid s the codice function locates a character in a string formally it returns a pointer to the first occurrence of the character codice in the string codice and in classic c kr c its prototype is char strchrchar s int c the codice function does not modify the input string but the return value is often used by the caller to modify the string such as if p  strchrq  thus on the one hand the input string can be const since it is not modified by the function and if the input string is const the return value should be as well  most simply because it might return exactly the input pointer if the first character is a match  but on the other hand the return value should not be const if the original string was not const since the caller may wish to use the pointer to modify the original string in c this is done via function overloading typically implemented via a template resulting in two functions so that the return value has the same constqualified type as the input char strchrchar s int c const char strchrconst char s int c these can in turn be defined by a template template in d this is handled via the codice keyword which acts as a wildcard for const immutable or unqualified variable yielding inoutchar strchrinoutchar s int c however in c neither of these is possible since c does not have function overloading and instead this is handled by having a single function where the input is constant but the output is writable char strchrconst char s int c this allows idiomatic c code but does strip the const qualifier if the input actually was constqualified violating type safety this solution was proposed by ritchie and subsequently adopted this difference is one of the failures of compatibility of c and c d in version  of the d programming language two keywords relating to const exist the codice keyword denotes data that cannot be modified through any reference the codice keyword denotes a nonmutable view of mutable data unlike c codice d codice and codice are deep or transitive and anything reachable through a codice or codice object is codice or codice respectively example of const vs immutable in d int foo  new int  foo is mutable const int bar  foo  bar is a const view of mutable data immutable int baz  foo  error all views of immutable data must be immutable immutable int nums  new immutableint  no mutable reference to nums may be created const int constnums  nums  works immutable is implicitly convertible to const int mutablenums  nums  error cannot create a mutable view of immutable data example of transitive or deep const in d class foo  immutable foo foo  new immutablefoo foonextnum    wont compile foonext is of type immutablefoo history codice was introduced by bjarne stroustrup in c with classes the predecessor to c in  and was originally called codice as to motivation stroustrup writes the first use as a scoped and typed alternative to macros was analogously fulfilled for functionlike macros via the codice keyword constant pointers and the codice notation were suggested by dennis ritchie and so adopted codice was then adopted in c as part of standardization and appears in c and subsequent versions along with the other type qualifier codice a further qualifier codice was suggested at the december  meeting of the xj committee but was rejected its goal was ultimately fulfilled by the codice keyword in c ritchie was not very supportive of these additions arguing that they did not carry their weight but ultimately did not argue for their removal from the standard d subsequently inherited codice from c where it is known as a type constructor not type qualifier and added two further type constructors codice and codice to handle related use cases other languages other languages do not follow cc in having constancy part of the type though they often have superficially similar constructs and may use the codice keyword typically this is only used for constants constant objects c has a codice keyword but with radically different and simpler semantics it means a compiletime constant and is not part of the type nim has a codice keyword similar to that of c it also declares a compiletime constant rather than forming part of the type however in nim a constant can be declared from any expression that can be evaluated at compile time in c only c builtin types can be declared as codice userdefined types including classes structs and arrays cannot be codice java does not have codice  it instead has codice which can be applied to local variable declarations and applies to the identifier not the type it has a different objectoriented use for object members which is the origin of the name interestingly the java language specification regards codice as a reserved keyword  ie one that cannot be used as variable identifier  but assigns no semantics to it it is a reserved word it cannot be used in identifiers but not a keyword it has no special meaning it is thought that the reservation of the keyword occurred to allow for an extension of the java language to include cstyle codice methods and pointer to codice type an enhancement request ticket for implementing codice correctness exists in the java community process but was closed in  on the basis that it was impossible to implement in a backwardscompatible fashion the contemporary ada  independently had the notion of a constant object and a codice keyword with input parameters and loop parameters being implicitly constant here the codice is a property of the object not of the type