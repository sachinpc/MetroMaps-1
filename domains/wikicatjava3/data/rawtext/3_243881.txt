d programming language the d programming language is an objectoriented imperative multiparadigm system programming language created by walter bright of digital mars and released in  bright was joined in the design and development effort in  by andrei alexandrescu though it originated as a reengineering of c d is a distinct language having redesigned some core c features while also taking inspiration from other languages notably java python ruby c and eiffel ds design goals attempt to combine the performance and safety of compiled languages with the expressive power of modern dynamic languages idiomatic d code is commonly as fast as equivalent c code while being shorter and memorysafe type inference automatic memory management and syntactic sugar for common types allow faster development while bounds checking design by contract features and a concurrencyaware type system help reduce the occurrence of bugs features d is designed with lessons learned from practical c usage rather than from a purely theoretical perspective although it uses many c and c concepts it also discards some and is as such not compatible with c and c source code d has however been constrained in its design by the rule that any code that is legal in both c and d should behave in the same way it adds to the functionality of c by also implementing design by contract unit testing true modules garbage collection first class arrays associative arrays dynamic arrays array slicing nested functions inner classes closures anonymous functions compile time function execution lazy evaluation and has a reengineered template syntax d retains cs ability to perform lowlevel coding and adds to it with support for an integrated inline assembler c multiple inheritance is replaced by javastyle single inheritance with interfaces and mixins on the other hand ds declaration statement and expression syntax closely matches that of c the inline assembler typifies the differences between d and application languages like java and c an inline assembler lets programmers enter machinespecific assembly code within standard d code a method often used by system programmers to access the lowlevel features of the processor needed to run programs that interface directly with the underlying hardware such as operating systems and device drivers d has builtin support for documentation comments allowing automatic documentation generation programming paradigms d supports five main programming paradigms imperative objectoriented metaprogramming functional and concurrent actor model imperative imperative programming in d is almost identical to that in c functions data statements declarations and expressions work just as they do in c and the c runtime library may be accessed directly on the other hand some notable differences between d and c in the area of imperative programming include ds codice loop construct which allows looping over a collection and nested functions which are functions that are declared inside of another and may access the enclosing functions local variables objectoriented objectoriented programming in d is based on a single inheritance hierarchy with all classes derived from class object d does not support multiple inheritance instead it uses javastyle interfaces which are comparable to cs pure abstract classes and mixins which separates common functionality from the inheritance hierarchy d also allows the defining of static and final nonvirtual methods in interfaces metaprogramming metaprogramming is supported by a combination of templates compile time function execution tuples and string mixins the following examples demonstrate some of ds compiletime features templates in d can be written in a more imperative style compared to the c functional style for templates this is a regular function that calculates the factorial of a number ulong factorialulong n here the use of codice ds compiletime conditional construct is demonstrated to construct a template that performs the same calculation using code that is similar to that of the function above template factorialulong n in the following two examples the template and function defined above are used to compute factorials the types of constants need not be specified explicitly as the compiler infers their types from the righthand sides of assignments enum fact  factorial this is an example of compile time function execution ordinary functions may be used in constant compiletime expressions provided they meet certain criteria enum fact  factorial the codice function performs codicelike data formatting also at compiletime through ctfe and the msg pragma displays the result at compile time import stdstring  format pragmamsg format  s fact pragmamsg format  s fact string mixins combined with compiletime function execution allow generating d code using string operations at compile time this can be used to parse domainspecific languages to d code which will be compiled as part of the program import footod  hypothetical module which contains a function that parses foo source code void main functional d supports functional programming features such as function literals closures recursivelyimmutable objects and the use of higherorder functions there are two syntaxes for anonymous functions including a multiplestatement form and a shorthand singleexpression notation there are two builtin types for function literals codice which is simply a pointer to a stackallocated function and codice which also includes a pointer to the surrounding environment type inference may be used with an anonymous function in which case the compiler creates a codice unless it can prove that an environment pointer is not necessary likewise to implement a closure the compiler places enclosed local variables on the heap only if necessary for example if a closure is returned by another function and exits that functions scope when using type inference the compiler will also add attributes such as codice and codice to a functions type if it can prove that they apply other functional features such as currying and common higherorder functions such as map filter and reduce are available through the standard library modules codice and codice alternatively the above function compositions can be expressed using uniform function call syntax ufcs for more natural lefttoright reading concurrent import stdstdio stdconcurrency stdvariant void foo void main memory management memory is usually managed with garbage collection but specific objects may be finalized immediately when they go out of scope explicit memory management is possible using the overloaded operators codice and codice and by simply calling cs malloc and free directly garbage collection can be controlled programmers may add and exclude memory ranges from being observed by the collector can disable and enable the collector and force either a generational or full collection cycle the manual gives many examples of how to implement different highly optimized memory management schemes for when garbage collection is inadequate in a program safed safed is the name given to the subset of d that can be guaranteed to be memory safe no writes to memory that were not allocated or that have already been recycled functions marked safe are checked at compile time to ensure that they do not use any features that could result in corruption of memory such as pointer arithmetic and unchecked casts and any other functions called must also be marked as safe or trusted functions can be marked trusted for the cases where the compiler cannot distinguish between safe use of a feature that is disabled in safed and a potential case of memory corruption interaction with other systems cs application binary interface abi is supported as well as all of cs fundamental and derived types enabling direct access to existing c code and libraries d bindings are available for many popular c libraries additionally cs standard library is a part of standard d because c does not have a single standard abi d can only fully access c code that is written to the c abi the d parser understands an extern c calling convention for limited linking to c objects on microsoft windows d can access component object model com code history walter bright decided to start working on a new language in  d was first released in december  and reached version  in january  the first version of the language d concentrated on the imperative object oriented and metaprogramming paradigms similar to c dissatisfied with phobos ds official runtime and standard library members of the d community created an alternative runtime and standard library named tango the first public tango announcement came within days of d s release tango adopted a different programming style embracing oop and high modularity being a communityled project tango was more open to contributions which allowed it to progress faster than the official standard library at that time tango and phobos were incompatible due to different runtime support apis the garbage collector threading support etc this made it impossible to use both libraries in the same project the existence of two libraries both widely in use has led to significant dispute due to some packages using phobos and others using tango in june  the first version of d was released the beginning of ds development signalled the stabilization of d the first version of the language has been placed in maintenance only receiving corrections and implementation bugfixes d was to introduce breaking changes to the language beginning with its first experimental const system d later added numerous other language features such as closures purity and support for the functional and concurrent programming paradigms d also solved standard library problems by separating the runtime from the standard library the completion of a d tango port was announced in february  the release of andrei alexandrescus book the d programming language on june   marked the stabilization of d which today is commonly referred to as just d in january  d development moved from a bugtracker  patchsubmission basis to github this has led to a significant increase in contributions to the compiler runtime and standard library in december  andrei alexandrescu announced that d the first version of the language would be discontinued on december   the final d release d v was on december   implementations most current d implementations compile directly into machine code for efficient execution development tools editors and integrated development environments ides supporting d include eclipse microsoft visual studio slickedit emacs vim scite smultron textmate monodevelop zeus and geany among others open source d ides for windows exist some written in d such as poseidon dide and entice designer d applications can be debugged using any cc debugger like gdb or windbg although support for various dspecific language features is extremely limited on windows d programs can be debugged using ddbg or microsoft debugging tools windbg and visual studio after having converted the debug information using cvpdb the zerobugs debugger for linux has experimental support for the d language ddbg can be used with various ides or from the command line zerobugs has its own graphical user interface gui examples example  this example program prints its command line arguments the codice function is the entry point of a d program and codice is an array of strings representing the command line arguments a codice in d is an array of characters represented by codice in d or codice in d import stdstdio writefln void mainstring args the codice statement can iterate over any collection in this case it is producing a sequence of indexes codice and values codice from the array codice the index codice and the value codice have their types inferred from the type of the array codice example  the following shows several d capabilities and d design tradeoffs in a very short program it iterates over the lines of a text file named codice which contains a different word on each line and prints all the words that are anagrams of other words import stdstdio stdalgorithm stdrange stdstring void main