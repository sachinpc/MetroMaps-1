event dispatching thread the event dispatching thread edt is a background thread used in java to process events from the abstract window toolkit awt graphical user interface event queue it is an example of the generic concept of eventdriven programming that is popular in many other contexts than java for example web browsers or web servers the events are primarily update events that cause user interface components to redraw themselves or input events from input devices such as the mouse or keyboard the awt uses a singlethreaded painting model in which all screen updates must be performed from a single thread the event dispatching thread is the only valid thread to update the visual state of visible user interface components updating visible components from other threads is the source of many common bugs in java programs that use swing the event dispatching thread is called the primordial worker in adobe flash and the ui thread in swt net framework and android message loop for serializing gui accesses a software application normally consists of multiple threads and a single gui data structure this means gui is a shared data structure and some synchronization is needed to ensure that only one thread accesses it at a time though awt and swing expose the thread unsafe methods to create and access the gui components and these methods are visible to all application threads likewise in other gui frameworks only a single event dispatching thread has the right to execute these methods since programmers often miss this requirement thirdparty look and feels like substance go as far as to refuse to instantiate any swing component when not running within the event dispatch thread to prevent such a coding mistake access to the gui is serialized and other threads may submit some code to be executed in the edt through a edt message queue that is likewise in other gui frameworks the event dispatching thread spends its life pumping messages it maintains a message queue of actions to be performed over gui these requests are submitted to the queue by system and any application thread edt consumes them one after another and responds by updating the gui components the messages may be wellknown actions or involve callbacks the references to usermethods that must be executed by means of edt the important requirement imposed on all messages is that they must be executed quickly for the gui to stay responsive otherwise the message loop is blocked and gui freezing is experienced submitting user code to the edt there are various solutions for submitting code to the edt and performing lengthy tasks without blocking the loop component event handlers listeners gui components support the lists of callbacks called listeners which are typically populated when the components are created edt executes the listeners when user excitates the components somehow button is clicked mouse is moved item is selected focus is lost component resized and so on timer for short tasks that must accessmodify gui periodically or at specific time codice is used it can be considered as invisible gui component whose listeners are register to fire at specific times equivalents requests from other threads other application threads can pass some code to be executed in the event dispatching thread by means of helper classes or if you are doing awt the submitted code must be wrapped with a object two methods of these classes allow from the event dispatching thread the method codice should never be called from the event dispatching threadit will throw an exception the method or can be called to determine if the current thread is the event dispatching thread the code supplied by means of the codice and codice to the edt must be as quick as possible to prevent freezing they are normally intended to deliver the result of a lengthy computation to the gui user worker design pattern both execution of a task in another thread and presenting the results in the edt can be combined by means of worker design pattern the codice class developed by sun microsystems is an implementation of the worker design pattern and as of java  is part of standard swing distribution swingworker is normally invoked from edtexecuted event listener to perform a lengthy task in order not to block the edt samples if you use groovy and codice you can use codice codice and codice then you can write it more simple like this modal execution swingworker is normally created for a lengthy tasks by edt while handling callback listener events spawning a worker thread edt proceeds handling current message without waiting the worker to complete often this is not desirable often your edt handles a gui component action which demands the user to make a choice by means of another dialog like jfilechooser which pops up stays responsive while user picks its option and action proceeds with selected file only after ok button is pressed you see this takes time user responds in matter of seconds and you need a responsive gui the messages are still pumped in edt during all this time while edt is blocking it does not handle newer eg jfilechooser messages in the queue before the dialog is closed and current component action is finished the vicious cycle is broken through edt entering a new message loop which dispatches the messages as per normal until modal dialog is over arrives and normal message processing resumes from the blocked position in the component action the open source foxtrot project emulates the swing message loop pumping to provide the synchronous execution mechanism for arbitrary user tasks which proceeds only after the worker completes the task since java  java provides standard solution for custom secondary message loops by exposing createsecondaryloop in system eventqueue