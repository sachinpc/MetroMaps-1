objectivec objectivec is a generalpurpose objectoriented programming language that adds smalltalkstyle messaging to the c programming language it was the main programming language used by apple for the os x and ios operating systems and their respective application programming interfaces apis cocoa and cocoa touch prior to the introduction of swift the programming language objectivec was originally developed in the early s it was selected as the main language used by next for its nextstep operating system from which os x and ios are derived portable objectivec programs that do not use the cocoa or cocoa touch libraries or those using parts that may be ported or reimplemented for other systems can also be compiled for any system supported by gnu compiler collection gcc or clang objectivec source code implementation program files usually have m filename extensions while objectivec headerinterface files have h extensions the same as c header files objectivec files are denoted with a mm file extension history objectivec was created primarily by brad cox and tom love in the early s at their company stepstone both had been introduced to smalltalk while at itt corporations programming technology center in  the earliest work on objectivec traces back to around that time cox was intrigued by problems of true reusability in software design and programming he realized that a language like smalltalk would be invaluable in building development environments for system developers at itt however he and tom love also recognized that backward compatibility with c was critically important in itts telecom engineering milieu cox began writing a preprocessor for c to add some of the abilities of smalltalk he soon had a working implementation of an objectoriented extension to the c language which he called oopc for objectoriented precompiler love was hired by schlumberger research in  and had the opportunity to acquire the first commercial copy of smalltalk which further influenced the development of their brainchild in order to demonstrate that real progress could be made cox showed that making interchangeable software components really needed only a few practical changes to existing tools specifically they needed to support objects in a flexible manner come supplied with a usable set of libraries and allow for the code and any resources needed by the code to be bundled into one crossplatform format love and cox eventually formed a new venture productivity products international ppi to commercialize their product which coupled an objectivec compiler with class libraries in  cox published the main description of objectivec in its original form in the book objectoriented programming an evolutionary approach although he was careful to point out that there is more to the problem of reusability than just the language objectivec often found itself compared feature for feature with other languages popularization through next in  next licensed objectivec from stepstone the new name of ppi the owner of the objectivec trademark and extended the gcc compiler to support objectivec next developed the appkit and foundation kit libraries on which the nextstep user interface and interface builder were based while the next workstations failed to make a great impact in the marketplace the tools were widely lauded in the industry this led next to drop hardware production and focus on software tools selling nextstep and openstep as a platform for custom programming in order to circumvent the terms of the gpl next had originally intended to ship the objectivec frontend separately allowing the user to link it with gcc to produce the compiler executable after being initially accepted by richard m stallman this plan was rejected after stallman consulted with gnus lawyers and next agreed to make objectivec part of gcc the work to extend gcc was led by steve naroff who joined next from stepstone the compiler changes were made available as per gpl license terms but the runtime libraries were not rendering the open source contribution unusable to the general public this led to other parties developing such runtime libraries under open source license later steve naroff was also principal contributor to work at apple to build the objectivec frontend to clang the gnu project started work on its free software implementation of cocoa named gnustep based on the openstep standard dennis glatting wrote the first gnu objectivec runtime in  the gnu objectivec runtime which has been in use since  is the one developed by kresten krab thorup when he was a university student in denmark thorup also worked at next from  to  apple development and swift after acquiring next in  apple computer used openstep in its new operating system os x this included objectivec nexts objectivec based developer tool project builder and its interface design tool interface builder both now merged into one xcode application most of apples current cocoa api is based on openstep interface objects and is the most significant objectivec environment being used for active development at wwdc  apple introduced a new language swift which was characterized as objectivec without the c syntax objectivec is a thin layer atop c and is a strict superset of c meaning that it is possible to compile any c program with an objectivec compiler and to freely include c language code within an objectivec class objectivec derives its object syntax from smalltalk all of the syntax for nonobjectoriented operations including primitive variables preprocessing expressions function declarations and function calls are identical to those of c while the syntax for objectoriented features is an implementation of smalltalkstyle messaging messages the objectivec model of objectoriented programming is based on message passing to object instances in objectivec one does not call a method one sends a message this is unlike the simulastyle programming model used by c the difference between these two concepts is in how the code referenced by the method or message name is executed in a simulastyle language the method name is in most cases bound to a section of code in the target class by the compiler in smalltalk and objectivec the target of a message is resolved at runtime with the receiving object itself interpreting the message a method is identified by a selector or sel  a nulterminated string representing its name  and resolved to a c method pointer implementing it an imp a consequence of this is that the messagepassing system has no type checking the object to which the message is directed  the receiver  is not guaranteed to respond to a message and if it does not it raises an exception sending the message method to the object pointed to by the pointer obj would require the following code in c objmethodargument in objectivec this is written as follows obj methodargument both styles of programming have their strengths and weaknesses objectoriented programming in the simula c style allows multiple inheritance and faster execution by using compiletime binding whenever possible but it does not support dynamic binding by default it also forces all methods to have a corresponding implementation unless they are abstract the smalltalkstyle programming as used in objectivec allows messages to go unimplemented with the method resolved to its implementation at runtime for example a message may be sent to a collection of objects to which only some will be expected to respond without fear of producing runtime errors message passing also does not require that an object be defined at compile time an implementation is still required for the method to be called in the derived object see the dynamic typing section below for more advantages of dynamic late binding interfaces and implementations objectivec requires that the interface and implementation of a class be in separately declared code blocks by convention developers place the interface in a header file and the implementation in a code file the header files normally suffixed h are similar to c header files while the implementation method files normally suffixed m can be very similar to c code files interface in other programming languages this is called a class declaration the interface of a class is usually defined in a header file a common convention is to name the header file after the name of the class eg ballh would contain the interface for the class ball an interface declaration takes the form interface classname  superclassname   classmethod  returntypeclassmethod  returntypeclassmethodparamtypeparamvarname  returntypeinstancemethodwithparameterparamtypeparamvarname  returntypeinstancemethodwithparametersparamtypeparamvarname paramcallnameparamtypeparamvarname end in the above plus signs denote class methods or methods that can be called on the class itself not on an instance and minus signs denote instance methods which can only be called on a particular instance of the class class methods also have no access to instance variables the code above is roughly equivalent to the following c interface class classname  public superclassname  note that instancemethodwithparametersparamcallname demonstrates the interleaving of selector segments with argument expressions for which there is no direct equivalent in cc return types can be any standard c type a pointer to a generic objectivec object a pointer to a specific type of object such as nsarray  nsimage  or nsstring  or a pointer to the class to which the method belongs instancetype the default return type is the generic objectivec type id method arguments begin with a name labeling the argument that is part of the method name followed by a colon followed by the expected argument type in parentheses and the argument name the label can be omitted  voidsetrangestartintstart endintend  voidimportdocumentwithnamensstring name withspecifiedpreferences preferences prefs beforepageintinsertpage implementation the interface only declares the class interface and not the methods themselves the actual code is written in the implementation file implementation method files normally have the file extension codice which originally signified messages implementation classname  returntypeclassmethod  returntypeinstancemethod end methods are written using their interface declarations comparing objectivec and c  intmethodinti int function int i the syntax allows pseudonaming of arguments  intchangecolortoredfloatred greenfloatgreen bluefloatblue mycolor changecolortored green blue internal representations of a method vary between different implementations of objectivec if mycolor is of the class color instance method changecolortoredgreenblue might be internally labeled icolorchangecolortoredgreenblue the i is to refer to an instance method with the class and then method names appended and colons changed to underscores as the order of parameters is part of the method name it cannot be changed to suit coding style or expression as with true named parameters however internal names of the function are rarely used directly generally messages are converted to function calls defined in the objectivec runtime library it is not necessarily known at link time which method will be called because the class of the receiver the object being sent the message need not be known until runtime instantiation once an objectivec class is written it can be instantiated this is done by first allocating an uninitialized instance of the class an object and then by initializing it an object is not fully functional until both steps have been completed these steps should be accomplished with one line of code so that there is never an allocated object that hasnt undergone initialization and because it is unwise to keep the intermediate result since codice can return a different object than that on which it is called instantiation with the default noparameter initializer myobject o   end interface integer display  id showstars  id showint end implementation integer display  id showstars   id showint  end int mainvoid  notes compilation is performed for example by one can experiment by leaving out the import integerarithmetich and num addnum lines and omitting integerarithmeticm in compilation the program will still run this means that it is possible to mixandmatch added categories if needed if a category does not need to have some ability it can simply not be compile in posing objectivec permits a class to wholly replace another class within a program the replacing class is said to pose as the target class class posing was declared deprecated with mac os x v and is unavailable in the bit runtime similar functionality can be achieved by using method swizzling in categories that swaps one methods implementation with anothers that have the same signature for the versions still supporting posing all messages sent to the target class are instead received by the posing class there are several restrictions posing similarly with categories allows global augmentation of existing classes posing permits two features absent from categories for example interface customnsapplication  nsapplication end implementation customnsapplication  void setmainmenu nsmenu menu  end classposeas customnsapplication class nsapplication class this intercepts every invocation of setmainmenu to nsapplication import in the c language the codice precompile directive always causes a files contents to be inserted into the source at that point objectivec has the codice directive equivalent except that each file is included only once per compilation unit obviating the need for include guards other features objectivecs features often allow for flexible and often easy solutions to programming issues language variants objectivec objectivec is a language variant accepted by the frontend to the gnu compiler collection and clang which can compile source files that use a combination of c and objectivec syntax objectivec adds to c the extensions that objectivec adds to c as nothing is done to unify the semantics behind the various language features certain restrictions apply objectivec  at the  worldwide developers conference apple announced the release of objectivec  a revision of the objectivec language to include modern garbage collection syntax enhancements runtime performance improvements and bit support mac os x v released in october  included an objectivec  compiler gcc  supports many new objectivec features such as declared and synthesized properties dot syntax fast enumeration optional protocol methods methodprotocolclass attributes class extensions and a new gnu objectivec runtime api garbage collection objectivec  provided an optional conservative generational garbage collector when run in backwardscompatible mode the runtime turned reference counting operations such as retain and release into noops all objects were subject to garbage collection when garbage collection was enabled regular c pointers could be qualified with strong to also trigger the underlying writebarrier compiler intercepts and thus participate in garbage collection a zeroing weak subsystem was also provided such that pointers marked as weak are set to zero when the object or more simply gc memory is collected the garbage collector does not exist on the ios implementation of objectivec  garbage collection in objectivec runs on a lowpriority background thread and can halt on user events with the intention of keeping the user experience responsive garbage collection was deprecated in os x v in favor of automatic reference counting arc objectivec on ios  running on arm uses  bits out of a bit word to store the reference count as a form of tagged pointers properties objectivec  introduces a new syntax to declare instance variables as properties with optional attributes to configure the generation of accessor methods properties are in a sense public instance variables that is declaring an instance variable as a property provides external classes with access possibly limited eg read only to that property a property may be declared as readonly and may be provided with storage semantics such as codice codice or codice by default properties are considered codice which results in a lock preventing multiple threads from accessing them at the same time a property can be declared as codice which removes this lock interface person  nsobject  propertycopy nsstring name propertyreadonly int age idinitwithageintage end properties are implemented by way of the codice keyword which generates getter and setter if not readonly methods according to the property declaration alternatively the getter and setter methods must be implemented explicitly or the codice keyword can be used to indicate that accessor methods will be provided by other means when compiled using clang  or higher all properties which are not explicitly declared with codice marked codice or have complete userimplemented getter and setter will be automatically implicitly codiced implementation person synthesize name idinitwithageintinitage  intage  end properties can be accessed using the traditional message passing syntax dot notation or in keyvalue coding by name via the valueforkeysetvalueforkey methods person aperson  person alloc initwithage  apersonname  steve  note dot notation uses synthesized setter nslogaccess by message  dot notation property name and direct instance variable access  in order to use dot notation to invoke property accessors within an instance method the self keyword should be used void introducemyselfwithpropertiesboolusegetter   note getter vs ivar access a class or protocols properties may be dynamically type introspectionintrospected int i int propertycount   objcpropertyt propertylist  classcopypropertylistaperson class propertycount for i   i  propertycount i  nonfragile instance variables objectivec  provides nonfragile instance variables where supported by the runtime ie when building code for bit mac os x and all ios under the modern runtime an extra layer of indirection is added to instance variable access allowing the dynamic linker to adjust instance layout at runtime this feature allows for two important improvements to objectivec code fast enumeration instead of using an nsenumerator object or indices to iterate through a collection objectivec  offers the fast enumeration syntax in objectivec  the following loops are functionally equivalent but have different performance traits  using nsenumerator nsenumerator enumerator  thepeople objectenumerator person p while p  enumerator nextobject  nil   using indexes for int i   i  thepeople count i   using fast enumeration for person p in thepeople  fast enumeration generates more efficient code than standard enumeration because method calls to enumerate over objects are replaced by pointer arithmetic using the nsfastenumeration protocol class extensions a class extension has the same syntax as a category declaration with no category name and the methods and properties declared in it are added directly to the main class it is mostly used as an alternative to a category to add methods to a class without advertising them in the public headers with the advantage that for class extensions the compiler checks that all the privately declared methods are actually implemented implications for cocoa development all objectivec applications developed for mac os x that make use of the above improvements for objectivec  are incompatible with all operating systems prior to  leopard since fast enumeration does not generate exactly the same binaries as standard enumeration its use will cause an application to crash on os x version  or earlier blocks blocks is a nonstandard extension for objectivec and c programming languagec and c that uses special syntax to create closure programmingclosures blocks are only supported in mac os x snow leopardmac os x  snow leopard or later ios  or later and gnustep with libobjc  and compiling with clang  or later typedef int intblock intblock makecounterint start int increment  int mainvoid   output modern objectivec automatic reference counting automatic reference counting arc is a compiletime feature that eliminates the need for programmers to manually manage retain counts using codice and codice unlike garbage collection computer sciencegarbage collection which occurs at run time arc eliminates the overhead of a separate process managing retain counts arc and manual memory management are not mutually exclusive programmers can continue to use nonarc code in arcenabled projects by disabling arc for individual code files xcode can also attempt to automatically upgrade a project to arc literals next and apple objc runtimes have long included a shortform way to create new strings using the literal syntax codice or drop to corefoundation constants codice and codice for codice with boolean values using this format saves the programmer from having to use the longer codice or similar methods when doing certain operations when using apple llvm compiler  or later arrays dictionaries and numbers codice codice codice classes can also be created using literal syntax instead of methods example without literals nsarray myarray  nsarray arraywithobjectsobjectobjectobjectnil nsdictionary mydictionary  nsdictionary dictionarywithobjectsomeobject forkeykey nsdictionary mydictionary  nsdictionary dictionarywithobjectsandkeysobject key object key nil nsnumber mynumber  nsnumber numberwithintmyint nsnumber mysumnumber nsnumber numberwithint   nsnumber myboolnumber  nsnumber numberwithboolyes example with literals nsarray myarray   object object object  nsdictionary mydictionary   key  someobject  nsdictionary mydictionary   key object key object  nsnumber mynumber  myint nsnumber mysumnumber   nsnumber myboolnumber  yes nsnumber myintegernumber   however different from string literals which compile to constants in the executable these literals compile to code equivalent to the above method calls in particular under manually referencecounted memory management these objects are autoreleased which requires added care when eg used with functionstatic variables or other kinds of globals subscripting when using apple llvm compiler  or later arrays and dictionaries codice and codice classes can be manipulated using subscripting subscripting can be used to retrieve values from indexes array or keys dictionary and with mutable objects can also be used to set objects to indexes or keys in code subscripting is represented using brackets codice example without subscripting id object  somearray objectatindex id object  somedictionary objectforkeykey somemutablearray replaceobjectatindex withobjectobject somemutabledictionary setobjectobject forkeykey example with subscripting id object  somearray id object  somedictionarykey somemutablearray  object somemutabledictionarykey  object modern objectivec syntax  after the purchase of next by apple attempts were made to make the language more acceptable to programmers more familiar with java programming languagejava than smalltalk one of these attempts was introducing what was dubbed modern syntax for objectivec at the time as opposed to the current classic syntax there was no change in behaviour this was merely an alternative syntax instead of writing a method invocation like it was instead written as similarly declarations went from the form to this modern syntax is no longer supported in current dialects of the objectivec language portable object compiler besides the gnu compiler collectiongccnextapple incapple implementation which added several extensions to the original stepstone implementation another free and open source softwarefree opensource objectivec implementation called the portable object compiler also exists the set of extensions implemented by the portable object compiler differs from the gccnextapple implementation in particular it includes smalltalklike blocks for objectivec while it lacks protocols and categories two features used extensively in openstep and its derivatives and relatives overall poc represents an older prenext stage in the languages evolution roughly conformant to brad coxs  book it also includes a runtime library called objectpak which is based on coxs original icpak library which in turn derives from the smalltalk class library and is quite radically different from the openstep foundationkit geos objectivec the geos bit operating systempc geos system used a programming language known as geos objectivec or goc despite the name similarity the two languages are similar only in overall concept and the use of keywords prefixed with an  sign clang the clang compiler suite part of the llvm project implements objectivec and other languages library use objectivec today is often used in tandem with a fixed library of standard objects often known as a kit or framework such as cocoa apicocoa gnustep or objfw these libraries often come with the operating system the gnustep libraries often come with linux based distributions and cocoa comes with os x the programmer is not forced to inherit functionality from the existing base class nsobject  ofobject objectivec allows for the declaration of new root classes that do not inherit any existing functionality originally objectivec based programming environments typically offered an object class as the base class from which almost all other classes inherited with the introduction of openstep next created a new base class named nsobject which offered additional features over object an emphasis on using object references and reference counting instead of raw pointers for example almost all classes in cocoa inherit from nsobject not only did the renaming serve to differentiate the new default behavior of classes within the openstep api but it allowed code that used objectthe original base class used on nextstep and more or less other objectivec class librariesto coexist in the same runtime with code that used nsobject with some limitations the introduction of the two letter prefix also became a simplistic form of namespaces which objectivec lacks using a prefix to create an informal packaging identifier became an informal coding standard in the objectivec community and continues to this day more recently package managers have started appearing such as cocoapods which aims to be both a package manager and a repository of packages a lot of opensource objectivec code that was written in the last few years can now be installed using cocoapods analysis of the language objectivec implementations use a thin run time systemruntime system written in c which adds little to the size of the application in contrast most objectoriented systems at the time that it was created used large virtual machine runtimes programs written in objectivec tend to be not much larger than the size of their code and that of the libraries which generally do not need to be included in the software distribution in contrast to smalltalk systems where a large amount of memory was used just to open a window objectivec applications tend to be larger than similar c or c applications because objectivec dynamic typing does not allow methods to be stripped or inlined since the programmer has such freedom to delegate forward calls build selectors on the fly and pass them to the runtime system the objectivec compiler cannot assume it is safe to remove unused methods or to inline calls likewise the language can be implemented atop extant c compilers in gnu compiler collectiongcc first as a preprocessor then as a module rather than as a new compiler this allows objectivec to leverage the huge existing collection of c code libraries tools etc existing c libraries can be wrapped in objectivec adapter patternwrappers to provide an oostyle interface in this aspect it is similar to gobject library and vala programming languagevala language which are widely used in development of gtk applications all of these practical changes lowered the barriers to entrybarrier to entry likely the biggest problem for the widespread acceptance of smalltalk in the s a common criticism is that objectivec does not have language support for namespaces instead programmers are forced to add prefixes to their class names which are traditionally shorter than namespace names and thus more prone to collisions as of  all mac os x classes and functions in the cocoa softwarecocoa programming environment are prefixed with ns eg nsobject nsbutton to identify them as belonging to the mac os x or ios core the ns derives from the names of the classes as defined during the development of nextstep since objectivec is a strict superset of c it does not treat c primitive types as firstclass objects unlike c objectivec does not support operator overloading also unlike c objectivec allows an object to directly inherit only from one class forbidding multiple inheritance however in most cases categories and protocols may be used as alternative ways to achieve the same results because objectivec uses dynamic runtime typing and because all method calls are function calls or in some cases syscalls many common performance optimizations cannot be applied to objectivec methods for example inlining constant propagation interprocedural optimizations and scalar replacement of aggregates this limits the performance of objectivec abstractions relative to similar abstractions in languages such as c where such optimizations are possible memory management the first versions of objectivec did not support garbage collection computer sciencegarbage collection at the time this decision was a matter of some debate and many people considered long dead times when smalltalk performed collection to render the entire system unusable some rd party implementations have added this feature most notably gnustep and apple has implemented it as of mac os x v however in more recent versions of mac os x and ios garbage collection has been deprecated in favor of automatic reference counting arc introduced in  with arc the compiler inserts retain and release calls automatically into objectivec code based on static program analysisstatic code analysis the automation relieves the programmer of having to write in memory management code arc also adds weak references to the objectivec language philosophical differences between objectivec and c the design and implementation of c and objectivec represent fundamentally different approaches to extending c in addition to cs style of procedural programming c directly supports certain forms of objectoriented programming generic programming and metaprogramming c also comes with c standard librarya large standard library that includes sequence container cseveral container classes similarly objectivec adds polymorphism in objectoriented programmingobjectoriented programming dynamic typing and reflection computer sciencereflection to c objectivec does not provide a standard library per se but in most places where objectivec is used it is used with an opensteplike library such as openstep cocoa apicocoa or gnustep which provides functionality similar to cs standard library one notable difference is that objectivec provides runtime support for reflection computer sciencereflective features whereas c adds only a small amount of runtime support to c in objectivec an object can be queried about its own properties eg whether it will respond to a certain message in c this is not possible without the use of external libraries the use of reflection is part of the wider distinction between dynamic runtime features and static compiletime features of a language although objectivec and c each employ a mix of both features objectivec is decidedly geared toward runtime decisions while c is geared toward compiletime decisions the tension between dynamic and static programming involves many of the classic tradeoffs in programming dynamic features add flexibility static features add speed and type checking generic programming and metaprogramming can be implemented in both languages using runtime polymorphism in c this takes the form of virtual functions and runtime type identification while objectivec offers dynamic typing and reflection objectivec lacks compiletime polymorphism generic functions entirely while c supports it via function overloading and template ctemplates categoryc programming language family external links categoryclassbased programming languages categorydynamically typed programming languages categorygnustep categorynext categoryobjectoriented programming languages categoryobjectivec categoryprogramming languages created in 