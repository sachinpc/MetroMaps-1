eiffel programming language eiffel is an objectoriented programming language designed by bertrand meyer an objectorientation proponent and author of objectoriented software construction and eiffel software meyer conceived the language in  with the goal of increasing the reliability of commercial software development the first version becoming available in  in  eiffel became an isostandardized language the design of the language is closely connected with the eiffel programming method both are based on a set of principles including design by contract commandquery separation the uniformaccess principle the singlechoice principle the openclosed principle and optionoperand separation many concepts initially introduced by eiffel later found their way into java c and other languages new language design ideas particularly through the ecmaiso standardization process continue to be incorporated into the eiffel language characteristics the key characteristics of the eiffel language include design goals eiffel emphasizes declarative statements over procedural code and attempts to eliminate the need for bookkeeping instructions eiffel shuns coding tricks or coding techniques intended as optimization hints to the compiler the aim is not only to make the code more readable but also to allow programmers to concentrate on the important aspects of a program without getting bogged down in implementation details eiffels simplicity is intended to promote simple extensible reusable and reliable answers to computing problems compilers for computer programs written in eiffel provide extensive optimization techniques such as automatic inlining that relieve the programmer of part of the optimization burden background eiffel was originally developed by eiffel software a company founded by bertrand meyer objectoriented software construction contains a detailed treatment of the concepts and theory of the object technology that led to eiffels design the design goal behind the eiffel language libraries and programming methods is to enable programmers to create reliable reusable software modules eiffel supports multiple inheritance genericity polymorphism encapsulation typesafe conversions and parameter covariance eiffels most important contribution to software engineering is design by contract dbc in which assertions preconditions postconditions and class invariants are employed to help ensure program correctness without sacrificing efficiency eiffels design is based on objectoriented programming theory with only minor influence of other paradigms or concern for support of legacy code eiffel formally supports abstract data types under eiffels design a software text should be able to reproduce its design documentation from the text itself using a formalized implementation of the abstract data type implementations and environments eiffelstudio is an integrated development environment available under either an open source or a commercial license it offers an objectoriented environment for software engineering eiffelenvision is a plugin for microsoft visual studio that allows users to edit compile and debug eiffel projects from within the microsoft visual studio ide five other open source implementations are available the eiffel compiler tecomp gobo eiffel smarteiffelthe gnu implementation based on an older version of the language libertyeiffelbased on the smarteiffel compiler and visual eiffel several other programming languages incorporate elements first introduced in eiffel sather for example was originally based on eiffel but has since diverged and now includes several functional programming features the interactiveteaching language blue forerunner of bluej is also eiffelbased the apple media tool includes an eiffelbased apple media language specifications and standards the eiffel language definition is an international standard of the iso the standard was developed by ecma international which first approved the standard on  june  as standard ecma eiffel analysis design and programming language in june  ecma and iso adopted the second version in november  iso first published that version the standard can be found and used free of charge on the ecma site the iso version is identical in all respects except formatting eiffel software the eiffel compiler tecomp and eiffellibrarydeveloper gobo have committed to implementing the standard eiffel softwares eiffelstudio  and the eiffel compiler tecomp implement some of the major new mechanismsin particular inline agents assigner commands bracket notation nonconforming inheritance and attached types the smarteiffel team has turned away from this standard to create its own version of the language which they believe to be closer to the original style of eiffel object tools has not disclosed whether future versions of its eiffel compiler will comply with the standard libertyeiffel implements a dialect somewhere in between the smarteiffel language and the standard the standard cites the following predecessor eiffellanguage specifications the current version of the standard from june  contains some inconsistencies eg covariant redefinitions the ecma committee has not yet announced any timeline and direction on how to resolve the inconsistencies syntax and semantics overall structure an eiffel system or program is a collection of classes above the level of classes eiffel defines cluster which is essentially a group of classes and possibly of subclusters nested clusters clusters are not a syntactic language construct but rather a standard organizational convention typically an eiffel program will be organized with each class in a separate file and each cluster in a directory containing class files in this organization subclusters are subdirectories for example under standard organizational and casing conventions codice might be the name of a file that defines a class called x a class contains features which are similar to routines members attributes or methods in other objectoriented programming languages a class also defines its invariants and contains other properties such as a notes section for documentation and metadata eiffels standard data types such as codice codice and codice are all themselves classes every system must have a class designated as root with one of its creation procedures designated as root procedure executing a system consists of creating an instance of the root class and executing its root procedure generally doing so creates new objects calls new features and so on eiffel has five basic executable instructions assignment object creation routine call condition and iteration eiffels control structures are strict in enforcing structured programming every block has exactly one entry and exactly one exit scoping unlike many objectoriented languages but like smalltalk eiffel does not permit any assignment into fields of objects except within the features of an object which is the practical application of the principle of information hiding or data abstraction requiring formal interfaces for data mutation to put it in the language of other objectoriented programming languages all eiffel fields are private and setters are needed to modify values an upshot of this is that setters can and normally do implement the invariants for which eiffel provides syntax while eiffel does not allow direct access to the features of a class by a client of the class it does allow for the definition of an assigner command such as while a slight bow to the overall developer community to allow something looking like direct access eg thereby breaking the information hiding principle the practice is dangerous as it hides or obfuscates the reality of a setter being used in practice it is better to read the direct call to a setter rather than implying a direct access to a feature like codice as in the example code above unlike other languages having notions of public private and so on eiffel uses an exporting technology to more precisely control the scoping between client and supplier classes moreover the export logic used can be checked statically by the compiler which allows earlier detection of scope violating calls at compiletime rather than runtime for example below the none is similar to private in other languages scope applied this way to a feature set eg everything below the feature keyword to either the next feature set keyword or the end of the class can be changed in descendant classes using the export keyword feature none  initialization alternatively the lack of a x export declaration implies any and is similar to the public scoping of other languages feature  constants finally scoping can be selectively and precisely controlled to any class in the eiffel project universe such as feature decimal dcmmadecimalparser dcmmadecimalhandler  access here the compiler will allow only the classes listed between the curly braces to access the features within the feature group eg decimal dcmmadecimalparser dcmmadecimalhandler hello world a programming languages look and feel is often conveyed using a hello world program such a program written in eiffel might be class create feature end this program contains the class codice the constructor create routine for the class named codice invokes the codice system library routine to write a codicecodice message to the output design by contract the concept of design by contract is central to eiffel the contracts assert what must be true before a routine is executed precondition and what must hold to be true after the routine finishes postcondition class invariant contracts define what assertions must hold true both before and after any feature of a class is accessed both routines and attributes moreover contracts codify into executable code developer and designers assumptions about the operating environment of the features of a class or the class as a whole by means of the invariant the eiffel compiler is designed to include the feature and class contracts in various levels eiffelstudio for example executes all feature and class contracts during execution in the workbench mode when an executable is created the compiler is instructed by way of the project settings file eg ecf file to either include or exclude any set of contracts thus an executable file can be compiled to either include or exclude any level of contract thereby bringing along continuous levels of unit and integration testing moreover contracts can be continually and methodically exercised by way of the autotest feature found in eiffelstudio the design by contract mechanisms are tightly integrated with the language and guide redefinition of features in inheritance in addition the language supports a check instruction a kind of assert loop invariants and loop variants which guarantee loop termination voidsafety voidsafety like static typing is another facility for improving software quality voidsafe software is protected from run time errors caused by calls to void references and therefore will be more reliable than software in which calls to void targets can occur the analogy to static typing is a useful one in fact voidsafe capability could be seen as an extension to the type system or a step beyond static typing because the mechanism for ensuring voidsafety is integrated into the type system the guard against void target calls can be seen by way of the notion of attachment and by extension detachment eg detachable keyword the voidsafe facility can be seen in a short rework of the example code used above the code example above shows how the compiler can statically address the reliability of whether codice will be attached or detached at the point it is used notably the codice keyword allows for an attachment local eg codice which is scoped to only the block of code enclosed by the ifstatement construct thus within this small block of code the local variable eg codice can be statically guaranteed to be nonvoid ie voidsafe features commands and queries the primary characteristic of a class is that it defines a set of features as a class represents a set of runtime objects or instances a feature is an operation on these objects there are two kinds of features queries and commands a query provides information about an instance a command modifies an instance the commandquery distinction is important to the eiffel method in particular overloading eiffel does not allow argument overloading each feature name within a class always maps to a specific feature within the class one name within one class means one thing this design choice helps the readability of classes by avoiding a cause of ambiguity about which routine will be invoked by a call it also simplifies the language mechanism in particular this is what makes eiffels multiple inheritance mechanism possible names can of course be reused in different classes for example the feature plus along with its infix alias  is defined in several classes integer real string etc genericity a generic class is a class that varies by type eg list phone a list of phone numbers account gaccounttype allowing for account savings and account checking etc classes can be generic to express that they are parameterized by types generic parameters appear in square brackets class list g  g is known as a formal generic parameter eiffel reserves argument for routines and uses parameter only for generic classes with such a declaration g represents within the class an arbitrary type so a function can return a value of type g and a routine can take an argument of that type item g do  end put x g do  end the codice and codice are generic derivations of this class permitted combinations with codice codice codice codice are n  ilitem wlput w codice and codice are the actual generic parameters in these generic derivations it is also possible to have constrained formal parameters for which the actual parameter must inherit from a given class the constraint for example in a derivation codice is valid only if codice inherits from codice as it indeed does in typical eiffel libraries within the class having codice constrained by codice means that for codice it is possible to apply to codice all the features of codice as in codice inheritance basics to inherit from one or more others a class will include an codice clause at the beginning class c inherit   rest of class declaration  the class may redefine override some or all of the inherited features this must be explicitly announced at the beginning of the class through a codice subclause of the inheritance clause as in class c inherit see for a complete discussion of eiffel inheritance deferred classes and features classes may be defined with codice rather than with codice to indicate that the class may not be directly instantiated noninstantiatable classes are called abstract classes in some other objectoriented programming languages in eiffel parlance only an effective class can be instantiated it may be a descendent of a deferred class a feature can also be deferred by using the codice keyword in place of a codice clause if a class has any deferred features it must be declared as deferred however a class with no deferred features may nonetheless itself be deferred deferred classes play some of the same role as interfaces in languages such as java though many objectoriented programming theorists believe interfaces are themselves largely an answer to javas lack of multiple inheritance which eiffel has renaming a class that inherits from one or more others gets all its features by default under their original names it may however change their names through codice clauses this is required in the case of multiple inheritance if there are name clashes between inherited features without renaming the resulting class would violate the nooverloading principle noted above and hence would be invalid tuples tuples types may be viewed as a simple form of class providing only attributes and the corresponding setter procedure a typical tuple type reads and could be used to describe a simple notion of birth record if a class is not needed an instance of such a tuple is simply a sequence of values with the given types given in brackets such as components of such a tuple can be accessed as if the tuple tags were attributes of a class for example if codice has been assigned the above tuple then codice has value  thanks to the notion of assigner command see below dot notation can also be used to assign components of such a tuple as in the tuple tags are optional so that it is also possible to write a tuple type as codice in some compilers this is the only form of tuple as tags were introduced with the ecma standard the precise specification of eg codice is that it describes sequences of at least three elements the first three being of types codice codice codice respectively as a result codice conforms to may be assigned to codice to codice and to codice without parameters the topmost tuple type to which all tuple types conform agents eiffels agent mechanism wraps operations into objects this mechanism can be used for iteration eventdriven programming and other contexts in which it is useful to pass operations around the program structure other programming languages especially ones that emphasize functional programming allow a similar pattern using continuations closures or generators eiffels agents emphasize the languages objectoriented paradigm and use a syntax and semantics similar to code blocks in smalltalk and ruby for example to execute the codice block for each element of codice one would write to execute codice only on elements satisfying codice a limitationfilter can be added in these examples codice and codice are routines prefixing them with codice yields an object that represents the corresponding routine with all its properties in particular the ability to be called with the appropriate arguments so if codice represents that object for example because codice is the argument to codice the instruction will call the original routine with the argument codice as if we had directly called the original routine codice arguments to codice are passed as a tuple here codice it is possible to keep some arguments to an agent open and make others closed the open arguments are passed as arguments to codice they are provided at the time of agent use the closed arguments are provided at the time of agent definition for example if codice has two arguments the iteration iterates codice for successive values of codice where the second arguments remained set to codice the question mark codice indicates an open argument codice is a closed argument of the agent note that the basic syntax codice is a shorthand for codice with all arguments open it is also possible to make the target of an agent open through the notation codice where codice is the type of the target the distinction between open and closed operands operands  arguments  target corresponds to the distinction between bound and free variables in lambda calculus an agent expression such as codice with some operands closed and some open corresponds to a version of the original operation curried on the closed operands the agent mechanism also allows defining an agent without reference to an existing routine such as codice codice codice through inline agents as in mylistdoall agent s string the inline agent passed here can have all the trappings of a normal routine including precondition postcondition rescue clause not used here and a full signature this avoids defining routines when all thats needed is a computation to be wrapped in an agent this is useful in particular for contracts as in an invariant clause that expresses that all elements of a list are positive the current agent mechanism leaves a possibility of runtime type error if a routine with n arguments is passed to an agent expecting m arguments with m  n this can be avoided by a runtime check through the precondition codice of codice several proposals for a purely static correction of this problem are available including a language change proposal by ribet et al once routines a routines result can be cached using the codice keyword in place of codice nonfirst calls to a routine require no additional computation or resource allocation but simply return a previously computed result a common pattern for once functions is to provide shared objects the first call will create the object subsequent ones will return the reference to that object the typical scheme is sharedobject sometype the returned objectcodice in the examplecan itself be mutable but its reference remains the same often once routines perform a required initialization multiple calls to a library can include a call to the initialization procedure but only the first such call will perform the required actions using this pattern initialization can be decentralized avoiding the need for a special initialization module once routines are similar in purpose and effect to the singleton pattern in many programming languages and to the used in python by default a once routine is called once per thread the semantics can be adjusted to once per process or once per object by qualifying it with a once key eg codice conversions eiffel provides a mechanism to allow conversions between various types the mechanisms coexists with inheritance and complements it to avoid any confusion between the two mechanisms the design enforces the following principle for example codice may conform to codice but codice converts to codice and does not inherit from it the conversion mechanism simply generalizes the ad hoc conversion rules such as indeed between codice and codice that exist in most programming languages making them applicable to any type as long as the above principle is observed for example a codice class may be declared to convert to codice this makes it possible to create a string from a date simply through as a shortcut for using an explicit object creation with a conversion procedure to make the first form possible as a synonym for the second it suffices to list the creation procedure constructor codice in a codice clause at the beginning of the class as another example if there is such a conversion procedure listed from codice then one can directly assign a tuple to a date causing the appropriate conversion as in exception handling exception handling in eiffel is based on the principles of design by contract for example an exception occurs when a routines caller fails to satisfy a precondition or when a routine cannot ensure a promised postcondition in eiffel exception handling is not used for control flow or to correct datainput mistakes an eiffel exception handler is defined using the rescue keyword within the rescue section the retry keyword executes the routine again for example the following routine tracks the number of attempts at executing the routine and only retries a certain number of times connecttoserver server socket this example is arguably flawed for anything but the simplest programs however because connection failure is to be expected for most programs a routine name like attemptconnectingtoserver would be better and the postcondition would not promise a connection leaving it up to the caller to take appropriate steps if the connection was not opened concurrency a number of networking and threading libraries are available such as eiffelnet and eiffelthreads a concurrency model for eiffel based on the concepts of design by contract is scoop or simple concurrent objectoriented programming not yet part of the official language definition but available in eiffelstudio cameo is an unimplemented variation of scoop for eiffel concurrency also interacts with exceptions asynchronous exceptions can be troublesome where a routine raises an exception after its caller has itself finished operator and bracket syntax assigner commands eiffels view of computation is completely objectoriented in the sense that every operation is relative to an object the target so for example an addition such as a  b is conceptually understood as if it were the method call aplus b with target codice feature codice and argument codice of course the former is the conventional syntax and usually preferred operator syntax makes it possible to use either form by declaring the feature for example in codice but this applies to other basic classes and can be used in any other for which such an operator appropriate plus alias  other integer integer the range of operators that can be used as alias is quite broad they include predefined operators such as  but also free operators made of nonalphanumeric symbols this makes it possible to design special infix and prefix notations for example in mathematics and physics applications every class may in addition have one function aliased to  the bracket operator allowing the notation codice as a synonym for codice where codice is the chosen function this is particularly useful for container structures such as arrays hash tables lists etc for example access to an element of a hash table with string keys can be written assigner commands are a companion mechanism designed in the same spirit of allowing wellestablished convenient notation reinterpreted in the framework of objectoriented programming assigner commands allow assignmentlike syntax to call setter procedures an assignment proper can never be of the form codice as this violates information hiding you have to go for a setter command procedure for example the hash table class can have the function and the procedure item alias  key string element  put e element key string then to insert an element you have to use an explicit call to the setter command it is possible to write this equivalently as in the same way that codice is a synonym for codice provided the declaration of codice now starts replacement for  with this declares codice as the assigner command associated with codice and combined with the bracket alias makes  legal and equivalent to  it could also be written without taking advantage of the bracket as codice note the argument list of as assigner is constrained to be as return typeall of as argument list lexical and syntax properties eiffel is not casesensitive the tokens codice codice and codice all denote the same identifier see however the style rules below comments are introduced by codice two consecutive dashes and extend to the end of the line the semicolon as instruction separator is optional most of the time the semicolon is just omitted except to separate multiple instructions on a line this results in less clutter on the program page there is no nesting of feature and class declarations as a result the structure of an eiffel class is simple some classlevel clauses inheritance invariant and a succession of feature declarations all at the same level it is customary to group features into separate feature clauses for more readability with a standard set of basic feature tags appearing in a standard order for example class hashtable element key  hashable inherit table element end in contrast to most curly bracket programming languages eiffel makes a clear distinction between expressions and instructions this is in line with the commandquery separation principle of the eiffel method style conventions much of the documentation of eiffel uses distinctive style conventions designed to enforce a consistent lookandfeel some of these conventions apply to the code format itself and others to the standard typographic rendering of eiffel code in formats and publications where these conventions are possible while the language is caseinsensitive the style standards prescribe the use of allcapitals for class names codice alllowercase for feature names codice and initial capitals for constants codice the recommended style also suggests underscore to separate components of a multiword identifier as in codice the specification of eiffel includes guidelines for displaying software texts in typeset formats keywords in bold userdefined identifiers and constants are shown in codice comments operators and punctuation marks in codice with program text in codice as in the present article to distinguish it from explanatory text for example the hello world program given above would be rendered as below in eiffel documentation interfaces to other tools and languages eiffel is a purely objectoriented language but provides an open architecture for interfacing with external software in any other programming language it is possible for example to program machine and operatingsystem level operations in c eiffel provides a straightforward interface to c routines including support for inline c writing the body of an eiffel routine in c typically for short machinelevel operations although there is no direct connection between eiffel and c many eiffel compilers visual eiffel is one exception output c source code as an intermediate language to submit to a c compiler for optimizing and portability as such they are examples of transcompilers the eiffel compiler tecomp can execute eiffel code directly like an interpreter without going via an intermediate c code or emit c code which will be passed to a c compiler in order to obtain optimized native code on net the eiffelstudio compiler directly generates cil common intermediate language code the smarteiffel compiler can also output java bytecode