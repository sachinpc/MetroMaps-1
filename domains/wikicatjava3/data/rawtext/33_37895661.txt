sequencel sequencel is a general purpose functional programming language and autoparallelizing parallel computing tool set whose primary design objectives are performance on multicore processor hardware ease of programming platform portabilityoptimization and code clarity and readability its main advantage is that it can be used to write straightforward code that automatically takes full advantage of all the processing power available without programmers needing to be concerned with identifying parallelisms specifying vectorization avoiding race conditions and other challenges of manual directivebased programming approaches such as openmp programs written in sequencel can be compiled to multithreaded code that runs in parallel with no explicit indications from a programmer of how or what to parallelize  versions of the sequencel compiler generate parallel code in c and opencl which allows it to work with most popular programming languages including c c c fortran java and python a platformspecific runtime manages the threads safely automatically providing parallel performance according to the number of cores available history sequencel was initially developed over a year period starting in  mostly at texas tech university primary funding was from nasa which originally wanted to develop a specification language which was selfverifying that is once written the requirements could be executed and the results verified against the desired outcome the principal researcher on the project was initially dr daniel cooke who was soon joined by dr nelson rushton another texas tech professor and later dr brad nemanich then a phd student under cooke the goal of creating a language that was simple enough to be readable but unambiguous enough to be executable drove the inventors to settle on a functional declarative language approach where a programmer describes desired results rather than the means to achieve them the language is then free to solve the problem in the most efficient manner that it can find as the language evolved the researchers developed new computational approaches including consumesimplifyproduce csp in  research began to apply sequencel to parallel computing this culminated in  when it took its more complete form with the addition of the normalizetranspose nt semantic which coincided with the major vendors of central processing units cpus making a major shift to multicore processors rather than continuing to increase clock speeds nt is the semantic workhorse being used to simplify and decompose structures based on a dataflowlike execution strategy similar to gamma and nesl the nt semantic achieves a goal similar to that of the lmmel and peytonjones boilerplate elimination all other features of the language are definable from these two laws  including recursion subscripting structures function references and evaluation of function bodies though it was not the original intent these new approaches allowed the language to parallelize a large fraction of the operations it performed transparently to the programmer in  a prototype autoparallelizing compiler was developed at texas tech university in  texas tech licensed the intellectual property to texas multicore technologies tmt for followon commercial development texas tech continues research into sequencel via further research grants and collaboration with tmt sequencel has been used in commercialscale applications where algorithmic accuracy code transparency and multiprocessor performance have been crucial these applications have included spacecraft navigation aviation decision support target tracking computational fluid dynamics cfd image processing video processing audio signal processing computer network scheduling database processing seismic migration processing and industrial control systems design sequencel is designed to be as simple as possible to learn and use focusing on algorithmic code where it adds value eg the inventors chose not to reinvent io since c handled that well as a result the full language reference for sequencel is only  pages with copious examples and its formal grammar has around  production rules sequencel is strictly evaluated like lisp statically typed with type inference like haskell and uses a combination of infix and prefix operators that resemble standard informal mathematical notation like c pascal python etc it is a purely declarative language meaning that a programmer defines functions in the mathematical sense without giving instructions for their implementation for example the mathematical definition of matrix multiplication is as follows the sequencel definition mirrors that definition more or less exactly the subscripts following each parameter a and b on the left hand side of the definition indicate that a and b are depth structures ie lists of lists of scalars which are here thought of as matrices from this formal definition sequencel infers the dimensions of the defined product from the formula for its i jth entry as the set of pairs i j for which the right hand side is defined and computes each entry by the same formula as in the informal definition above notice there are no explicit instructions for iteration in this definition or for the order in which operations are to be carried out because of this the sequencel compiler can perform operations in any order including parallel order which satisfies the defining equation in this example computation of coordinates in the product will be parallelized in a way that for large matrices scales linearly with the number of processors as noted above sequencel has no builtin constructs for inputoutput io since it was designed to work in an additive manner with other programming languages the decision to compile to multithreaded c and support the  simplified wrapper and interface generator swig languages c c c java python etc means it easily fits into extant design flows training and tools it can be used to enhance extant applications create multicore libraries and even create standalone applications by linking the resulting code with other code which performs io tasks sequencel functions can also be queried from an interpreter with given inputs like python and other interpreted languages normalizetranspose the main nonscalar construct of sequencel is the sequence which is essentially a list sequences may be nested to any level to avoid the routine use of recursion common in many purely functional languages sequencel uses a technique termed normalizetranspose nt in which scalar operations are automatically distributed over elements of a sequence for example in sequencel we have this results not from overloading the  operator but from the effect of nt that extends to all operations both builtin and userdefined as another example if f is a argument function whose arguments are scalars then for any appropriate x and z we will have the nt construct can be used for multiple arguments at once as in for example it also works when the expected argument is a nonscalar of any type t and the actual argument is a list of objects of type t or in greater generality any data structure whose coordinates are of type t for example if a is a matrix and x is a list of matrices x  x and given the above definition of matrix multiply in sequencel we would have as a rule nts eliminate the need for iteration recursion or high level functional operators to this tends to account for most uses of iteration and recursion example prime numbers a good example that demonstrates the above concepts would be in finding prime numbers a prime number is defined as so a positive integer z is prime if no numbers from  through z inclusive divide evenly sequencel allows this problem to be programmed by literally transcribing the above definition into the language in sequencel a sequence of the numbers from  through z inclusive is just z so a program to find all of the primes between  and  can be written which in english just says if that condition isnt met the function returns nothing as a result running this program yields the string between  and  doesnt appear in the program rather a programmer will typically pass that part in as the argument since the program expects a scalar as an argument passing it a sequence of numbers instead will cause sequencel to perform the operation on each member of the sequence automatically since the function returns empty for failing values the result will be the input sequence but filtered to return only those numbers that satisfy the criteria for primes in addition to solving this problem with a very short and readable program sequencels evaluation of the nested sequences would all be performed in parallel components the following software components are available and supported by tmt for use in writing sequencel code all components are available on x platforms running windows os x and most varieties of linux including centos redhat opensuse and ubuntu and on arm and ibm power platforms running most varieties of linux interpreter a commandline interpreter allows writing code directly into a command shell or loading code from prewritten text files this code can be executed and the results evaluated to assist in checking code correctness or finding a quick answer it is also available via the popular eclipse integrated development environment ide code executed in the interpreter does not run in parallel it executes in one thread compiler a commandline compiler reads sequencel code and generates highly parallelized vectorized c and optionally opencl which must be linked with the sequencel runtime library to execute runtime the runtime environment is a precompiled set of libraries which works with the compiled parallelized c code to execute optimally on the target platform it builds on intel threaded building blocks tbb and handles things such as cache optimization memory management work queuesstealing and performance monitoring eclipse ide plugin with debugger an eclipse integrated development environment plugin provides standard editing abilities function rollup chromacoding etc and a sequencel debugging environment this plugin runs against the sequencel interpreter so cannot be used to debug the multithreaded code however by providing automatic parallelization debugging of parallel sequencel code is really verifying correctness of sequential sequencel code that is if it runs correctly sequentially it should run correctly in parallel  so debugging in the interpreter is sufficient libraries various math and other standard function libraries are included as sequencel source code to streamline the programming process and serve as best practice examples these may be imported in much the same way that c or c libraries are included using it typically sequencel development is done in the popular eclipse ide or a source code editor such as notepad vim text editor xcode etc on a part of extant code that a programmer either wants to speed up or enhance this is then debugged and verified for correctness using the interpreter and sequencel debugger when done the code is then passed through the sequencel compiler which emits highly parallelized and vectorized c code and optionally opencl a programmer then adds this code to their project linking to the runtime library at compile time and using their compiler of choice ranging from gcc to optimizing compilers generating one parallelized vectorized high performance executable