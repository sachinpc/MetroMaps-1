scala programming language scala   is a generalpurpose programming language scala has full support for functional programming and a very strong static type system designed to be concise many of scalas design decisions were inspired by criticism of javas shortcomings scala source code is intended to be compiled to java bytecode so that the resulting executable code runs on a java virtual machine java libraries may be used directly in scala code and vice versa language interoperability like java scala is objectoriented and uses a curlybrace syntax reminiscent of the c programming language unlike java scala has many features of functional programming languages like scheme standard ml and haskell including currying type inference immutability lazy evaluation and pattern matching it also has an advanced type system supporting algebraic data types covariance and contravariance higherorder types but not higherrank types and anonymous types other features of scala not present in java include operator overloading optional parameters named parameters raw strings and no checked exceptions the name scala is a portmanteau of scalable and language signifying that it is designed to grow with the demands of its users history the design of scala started in  at the cole polytechnique fdrale de lausanne epfl by martin odersky it followed on from work on funnel a programming language combining ideas from functional programming and petri nets odersky formerly worked on generic java and javac suns java compiler after an internal release in late  scala was released publicly in early  on the java platform and on the net framework in june  a second version v followed in march  the net support was officially dropped in  although scala had extensive support for functional programming from its inception java remained a mostly object oriented language until the inclusion of lambda expressions with java  in  on  january  the scala team won a fiveyear research grant of over  million from the european research council on  may  odersky and collaborators launched typesafe inc renamed lightbend inc  a company to provide commercial support training and services for scala typesafe received a  million investment in  from greylock partners platforms and license scala runs on the java platform java virtual machine and is compatible with existing java programs as android applications are typically written in java and translated from java bytecode into dalvik bytecode which may be further translated to native machine code during installation when packaged scalas java compatibility makes it well suited to android development more so when a functional approach is preferred scala also can compile to javascript making it possible to write scala programs that can run in web browsers the scala software distribution including compiler and libraries is released under a bsd license examples hello world example the hello world program written in scala has this form unlike the standalone hello world application for java there is no class declaration and nothing is declared to be static a singleton object created with the object keyword is used instead with the program saved in a file named codice it can be compiled from the command line to run it you may need to use the cp option to set the classpath as in java this is analogous to the process for compiling and running java code indeed scalas compiling and executing model is identical to that of java making it compatible with java build tools such as apache ant a shorter version of the hello world scala program is scala includes interactive shell and scripting support saved in a file named codice this can be run as a script with no prior compiling using commands can also be entered directly into the scala interpreter using the option  finally commands can be entered interactively in the repl basic example the following example shows the differences between java and scala syntax some syntactic differences in this code are these syntactic relaxations are designed to allow support for domainspecific languages some other basic syntactic differences example with classes the following example contrasts the definition of classes in java and scala the above code shows some of the conceptual differences between java and scalas handling of classes features with reference to java scala has the same compiling model as java and c namely separate compiling and dynamic class loading so that scala code can call java libraries scalas operational characteristics are the same as javas the scala compiler generates byte code that is nearly identical to that generated by the java compiler in fact scala code can be decompiled to readable java code with the exception of certain constructor operations to the java virtual machine jvm scala code and java code are indistinguishable the only difference is one extra runtime library codice scala adds a large number of features compared with java and has some fundamental differences in its underlying model of expressions and types which make the language theoretically cleaner and eliminate several corner cases in java from the scala perspective this is practically important because several added features in scala are also available in c examples include syntactic flexibility as mentioned above scala has a good deal of syntactic flexibility compared with java the following are some examples by themselves these may seem like questionable choices but collectively they serve the purpose of allowing domainspecific languages to be defined in scala without needing to extend the compiler for example erlangs special syntax for sending a message to an actor ie codice can be and is implemented in a scala library without needing language extensions unified type system java makes a sharp distinction between primitive types eg codice and codice and reference types any class only reference types are part of the inheritance scheme deriving from codice in scala however all types inherit from a toplevel class codice whose immediate children are codice value types such as codice and codice and codice reference types as in java this means that the java distinction between primitive types and boxed types eg codice vs codice is not present in scala boxing and unboxing is completely transparent to the user scala  allows for new value types to be defined by the user forexpressions instead of the java foreach loops for looping through an iterator scala has a much more powerful concept of codiceexpressions these are similar to list comprehensions in languages such as haskell or a combination of list comprehensions and generator expressions in python forexpressions using the codice keyword allow a new collection to be generated by iterating over an existing one returning a new collection of the same type they are translated by the compiler into a series of codice codice and codice calls where codice is not used the code approximates to an imperativestyle loop by translating to codice a simple example is the result of running it is the following vector a more complex example of iterating over a map is expression codice is an example of pattern matching see below iterating over a map returns a set of keyvalue tuples and patternmatching allows the tuples to easily be destructured into separate variables for the key and value similarly the result of the comprehension also returns keyvalue tuples which are automatically built back up into a map because the source object from the variable codice is a map note that if codice instead held a list set array or other collection of tuples exactly the same code above would yield a new collection of the same type functional tendencies while supporting all of the objectoriented features available in java and in fact augmenting them in various ways scala also provides a large number of capabilities that are normally found only in functional programming languages together these features allow scala programs to be written in an almost completely functional style and also allow functional and objectoriented styles to be mixed examples are everything is an expression unlike c or java but similar to languages such as lisp scala makes no distinction between statements and expressions all statements are in fact expressions that evaluate to some value functions that would be declared as returning codice in c or java and statements like codice that logically do not return a value are in scala considered to return the type codice which is a singleton type with only one object of that type functions and operators that never return at all eg the codice operator or a function that always exits nonlocally using an exception logically have return type codice a special type containing no objects that is a bottom type ie a subclass of every possible type this in turn makes type codice compatible with every type allowing type inference to function correctly similarly an codice statement is actually an expression which produces a value ie the result of evaluating one of the two branches this means that such a block of code can be inserted wherever an expression is desired obviating the need for a ternary operator in scala for similar reasons codice statements are unnecessary in scala and in fact are discouraged as in lisp the last expression in a block of code is the value of that block of code and if the block of code is the body of a function it will be returned by the function to make it clear that all expressions are functions even methods that return codice are written with an equals sign or equivalently with type inference and omitting the unnecessary braces type inference due to type inference the type of variables function return values and many other expressions can typically be omitted as the compiler can deduce it examples are codice for an immutable constant variable or immutable object or codice for a variable whose value can later be changed type inference in scala is essentially local in contrast to the more global hindleymilner algorithm used in haskell ml and other more purely functional languages this is done to facilitate objectoriented programming the result is that certain types still need to be declared most notably function parameters and the return types of recursive functions eg or with a return type declared for a recursive function anonymous functions in scala functions are objects and a convenient syntax exists for specifying anonymous functions an example is the expression codice which specifies a function with one parameter that compares its argument to see if it is less than  it is equivalent to the lisp form codice note that neither the type of codice nor the return type need be explicitly specified and can generally be inferred by type inference but they can be explicitly specified eg as codice or even codice anonymous functions behave as true closures in that they automatically capture any variables that are lexically available in the environment of the enclosing function those variables will be available even after the enclosing function returns and unlike in the case of javas anonymous inner classes do not need to be declared as final it is even possible to modify such variables if they are mutable and the modified value will be available the next time the anonymous function is called an even shorter form of anonymous function uses placeholder variables for example the following can be written more concisely as or even immutability scala enforces a distinction between immutable unmodifiable readonly variables whose value cannot be changed once assigned and mutable variables which can be changed a similar distinction is made between immutable and mutable objects the distinction must be made when a variable is declared immutable variables are declared with codice while mutable variables use codice similarly all of the collection objects container types in scala eg linked lists arrays sets and hash tables are available in mutable and immutable variants with the immutable variant considered the more basic and default implementation the immutable variants are persistent data types in that they create a new object that encloses the old object and adds the new members this is similar to how linked lists are built up in lisp where elements are prepended by creating a new cons cell with a pointer to the new element the head and the old list the tail this allows for very easy concurrency  no locks are needed as no shared objects are ever modified immutable structures are also constructed efficiently in the sense that modified instances reuses most of old instance data and unusedunreferenced parts are collected by gc lazy nonstrict evaluation evaluation is strict eager by default in other words scala evaluates expressions as soon as they are available rather than as needed however you can declare a variable nonstrict lazy with the codice keyword meaning that the code to produce the variables value will not be evaluated until the first time the variable is referenced nonstrict collections of various types also exist such as the type codice a nonstrict linked list and any collection can be made nonstrict with the codice method nonstrict collections provide a good semantic fit to things like serverproduced data where the evaluation of the code to generate later elements of a list that in turn triggers a request to a server possibly located somewhere else on the web only happens when the elements are actually needed tail recursion functional programming languages commonly provide tail call optimization to allow for extensive use of recursion without stack overflow problems limitations in java bytecode complicate tail call optimization on the jvm in general a function that calls itself with a tail call can be optimized but mutually recursive functions cannot trampolines have been suggested as a workaround trampoline support has been provided by the scala library with the object codice since scala  released july   a function may optionally be annotated with codice in which case it will not compile unless it is tail recursive case classes and pattern matching scala has builtin support for pattern matching which can be thought of as a more sophisticated extensible version of a switch statement where arbitrary data types can be matched rather than just simple types like integers booleans and strings including arbitrary nesting a special type of class known as a case class is provided which includes automatic support for pattern matching and can be used to model the algebraic data types used in many functional programming languages from the perspective of scala a case class is simply a normal class for which the compiler automatically adds certain behaviors that could also be provided manually eg definitions of methods providing for deep comparisons and hashing and destructuring a case class on its constructor parameters during pattern matching an example of a definition of the quicksort algorithm using pattern matching is this the idea here is that we partition a list into the elements less than a pivot and the elements not less recursively sort each part and paste the results together with the pivot in between this uses the same divideandconquer strategy of mergesort and other fast sorting algorithms the codice operator is used to do pattern matching on the object stored in codice each codice expression is tried in turn to see if it will match and the first match determines the result in this case codice only matches the literal object codice but codice matches a nonempty list and simultaneously destructures the list according to the pattern given in this case the associated code will have access to a local variable named codice holding the head of the list and another variable codice holding the tail of the list note that these variables are readonly and are semantically very similar to variable bindings established using the codice operator in lisp and scheme pattern matching also happens in local variable declarations in this case the return value of the call to codice is a tuple  in this case two lists tuples differ from other types of containers eg lists in that they are always of fixed size and the elements can be of differing types  although here they are both the same pattern matching is the easiest way of fetching the two parts of the tuple the form codice is a declaration of an anonymous function with a placeholder variable see the section above on anonymous functions the list operators codice which adds an element onto the beginning of a list similar to codice in lisp and scheme and codice which appends two lists together similar to codice in lisp and scheme both appear despite appearances there is nothing builtin about either of these operators as specified above any string of symbols can serve as function name and a method applied to an object can be written infixstyle without the period or parentheses the line above as written could also be written thusly in more standard methodcall notation methods that end with a colon are rightassociative and bind to the object to the right partial functions in the patternmatching example above the body of the codice operator is a partial function which consists of a series of codice expressions with the first matching expression prevailing similar to the body of a switch statement partial functions are also used in the exceptionhandling portion of a codice statement finally a partial function can be used alone and the result of calling it is equivalent to doing a codice over it for example the prior code for quicksort can be written thusly here a readonly variable is declared whose type is a function from lists of integers to lists of integers and bind it to a partial function note that the single parameter of the partial function is never explicitly declared or named however we can still call this variable exactly as if it were a normal function objectoriented extensions scala is a pure objectoriented language in the sense that every value is an object data types and behaviors of objects are described by classes and traits class abstractions are extended by subclassing and by a flexible mixinbased composition mechanism to avoid the problems of multiple inheritance traits are scalas replacement for javas interfaces interfaces in java versions under  are highly restricted able only to contain abstract function declarations this has led to criticism that providing convenience methods in interfaces is awkward the same methods must be reimplemented in every implementation and extending a published interface in a backwardscompatible way is impossible traits are similar to mixin classes in that they have nearly all the power of a regular abstract class lacking only class parameters scalas equivalent to javas constructor parameters since traits are always mixed in with a class the codice operator behaves specially in traits allowing traits to be chained using composition in addition to inheritance the following example is a simple window system a variable may be declared thusly the result of calling codice is in other words the call to codice first executed the code in codice the last trait mixed in then through the codice calls threaded back through the other mixedin traits and eventually to the code in codice even though none of the traits inherited from one another this is similar to the decorator pattern but is more concise and less errorprone as it doesnt require explicitly encapsulating the parent window explicitly forwarding functions whose implementation isnt changed or relying on runtime initialization of entity relationships in other languages a similar effect could be achieved at compiletime with a long linear chain of implementation inheritance but with the disadvantage compared to scala that one linear inheritance chain would have to be declared for each possible combination of the mixins expressive type system scala is equipped with an expressive static type system that enforces the safe and coherent use of abstractions in particular the type system supports scala is able to infer types by usage this makes most static type declarations optional static types need not be explicitly declared unless a compiler error indicates the need in practice some static type declarations are included for the sake of code clarity type enrichment a common technique in scala known as enrich my library originally termed as pimp my library by martin odersky in  though concerns were raised about this phrasing due to its negative connotation and immaturity allows new methods to be used as if they were added to existing types this is similar to the c concept of extension methods but more powerful because the technique is not limited to adding methods and can for instance be used to implement new interfaces in scala this technique involves declaring an implicit conversion from the type receiving the method to a new type typically a class that wraps the original type and provides the additional method if a method cannot be found for a given type the compiler automatically searches for any applicable implicit conversions to types that provide the method in question this technique allows new methods to be added to an existing class using an addon library such that only code that imports the addon library gets the new functionality and all other code is unaffected the following example shows the enrichment of type codice with methods codice and codice importing the members of codice brings the implicit conversion to extension class codice into scope concurrency scala standard library includes support for the actor model in addition to the standard java concurrency apis lightbend inc provides a platform that includes akka a separate open source framework that provides actorbased concurrency akka actors may be distributed or combined with software transactional memory transactors alternative communicating sequential processes csp implementations for channelbased message passing are communicating scala objects or simply via jcsp an actor is like a thread instance with a mailbox it can be created by codice overriding the codice method to receive messages and using the codice exclamation point method to send a message the following example shows an echoserver that can receive messages and then print them scala also comes with builtin support for dataparallel programming in the form of parallel collections integrated into its standard library since version  the following example shows how to use parallel collections to improve performance besides actor support and dataparallelism scala also supports asynchronous programming with futures and promises software transactional memory and event streams cluster computing the most wellknown open source cluster computing solution written in scala is apache spark additionally apache kafka the publishsubscribe message queue popular with spark and other stream processing technologies is written in scala testing there are several ways to test code in scala comparison with other jvm languages scala is often compared with groovy and clojure two other programming languages also using the jvm substantial differences between these languages are found in the type system in the extent to which each language supports objectoriented and functional programming and in the similarity of their syntax to the syntax of java scala is statically typed while both groovy and clojure are dynamically typed this makes the type system more complex and difficult to understand but allows almost all type errors to be caught at compiletime and can result in significantly faster execution by contrast dynamic typing requires more testing to ensure program correctness and is generally slower in order to allow greater programming flexibility and simplicity regarding speed differences current versions of groovy and clojure allow for optional type annotations to help programs avoid the overhead of dynamic typing in cases where types are practically static this overhead is further reduced when using recent versions of the jvm which has been enhanced with an invoke dynamic instruction for methods that are defined with dynamically typed arguments these advances reduce the speed gap between static and dynamic typing although a statically typed language like scala is still the preferred choice when execution efficiency is very important regarding programming paradigms scala inherits the objectoriented model of java and extends it in various ways groovy while also strongly objectoriented is more focused in reducing verbosity in clojure objectoriented programming is deemphasised with functional programming being the main strength of the language scala also has many functional programming facilities including features found in advanced functional languages like haskell and tries to be agnostic between the two paradigms letting the developer choose between the two paradigms or more frequently some combination thereof regarding syntax similarity with java scala inherits much of javas syntax as is the case with groovy clojure on the other hand follows the lisp syntax which is different in both appearance and philosophy however learning scala is also considered difficult because of its many advanced features this is not the case with groovy despite its also being a featurerich language mainly because it was designed to be mainly a scripting language adoption language rankings scala was voted the most popular jvm scripting language at the  javaone conference  all jvmbased languages scala groovy clojure are significantly less popular than the original java language which is usually ranked first or second and which is also simultaneously evolving over time the redmonk programming language rankings as of june  placed scala th based on a position in terms of number of github projects and in terms of number of questions tagged on stack overflow groovy and clojure were both in th place here scala is shown somewhat between a firsttier group of languages including c python php ruby etc and ahead of a secondtier group another measure the popularity of programming language index which tracks searches for language tutorials ranked scala th in july  with a small upward trend making it the most popular jvmbased language after java as of january  the tiobe index of programming language popularity shows scala in th place as measured by internet search engine rankings and similar publicationcounting butas mentioned under bugs  change requeststiobe is aware of issues with its methodology of using search terms which might not be commonly used in some programming language communities in this ranking scala is ahead of functional languages haskell th erlang rd and clojure  but below java st the thoughtworks technology radar which is an opinion based halfyearly report of a group of senior technologists recommends scala adoption in its languages and frameworks category according to indeedcom job trends scala demand has been rapidly increasing since  trending ahead of clojure and groovy criticism in march  former vp of the platform engineering group at twitter raffi krikorian stated he would not have chosen scala in  due to its learning curve the same month linkedin svp kevin scott stated their decision to minimize their dependence on scala in november  yammer moved away from scala for reasons that included the learning curve for new team members and incompatibility from one version of the scala compiler to the next dotty is an attempt at creating a simpler faster scala compiler based on a formal calculus that will enable faster language development and future language simplification