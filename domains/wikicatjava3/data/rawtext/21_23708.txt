pli pli programming language one pronounced  is a procedural imperative computer programming language designed for scientific engineering business and system programming uses it has been used by various academic commercial and industrial organizations since it was introduced in the s and continues to be actively used plis main domains are data processing numerical computation scientific computing and system programming it supports recursion structured programming linked data structure handling fixedpoint floatingpoint complex character string handling and bit string handling the language syntax is englishlike and suited for describing complex data formats with a wide set of functions available to verify and manipulate them early history in the s and early s business and scientific users programmed for different computer hardware using different programming languages business users were moving from autocoders via comtran to cobol while scientific users programmed in general interpretive programme gip fortran algol george and others the ibm system announced in  but not delivered until  was designed as a common machine architecture for both groups of users superseding all existing ibm architectures similarly ibm wanted a single programming language for all users it hoped that fortran could be extended to include the features needed by commercial programmers in october  a committee was formed composed originally of three ibmers from new york and three members of share the ibm scientific users group to propose these extensions to fortran given the constraints of fortran they were unable to do this and embarked on the design of a new programming language based loosely on algol labeled npl this acronym conflicted with that of the uks national physical laboratory and was replaced briefly by mppl multipurpose programming language and in  with pli with a roman numeral i  the first definition appeared in april  ibm took npl as a starting point and completed the design to a level that the first compiler could be written the npl definition was incomplete in scope and in detail control of the pli language was vested initially in the new york programming center and later at the ibm uk laboratory at hursley the share and guide user groups were involved in extending the language and had a role in ibms process for controlling the language through their pli projects the experience of defining such a large language showed the need for a formal definition of pli a project was set up in  in ibm laboratory vienna to make an unambiguous and complete specification this led in turn to one of the first large scale formal methods for development vdm fred brooks is credited with ensuring pli had the character data type the language was first specified in detail in the manual pli language specifications c written in new york from  and superseded by pli language specifications gy written in hursley from  ibm continued to develop pli in the late sixties and early seventies publishing it in the gy manual these manuals were used by the multics group and other early implementers the first compiler was delivered in  the standard for pli was approved in  goals and principles the goals for pli evolved during the early development of the language competitiveness with cobols record handling and report writing capabilities was needed the scope of usefulness of the language grew to include system programming and eventdriven programming the additional goals for pli were to meet these goals pli borrowed ideas from contemporary languages while adding substantial new capabilities and casting it with a distinctive concise and readable syntax a number of principles and capabilities combined to give the language its character and were key in meeting the goals language summary the language is designed to be all things to all programmers the summary is extracted from the ansi pli standard and the ansi pli generalpurpose subset standard a pli program consists of a set of procedures each of which is written as a sequence of statements the codice construct is used to include text from other sources during program translation all of the statement types are summarized here in groupings which give an overview of the language the standard uses this organization names may be declared to represent data of the following types either as single values or as aggregates in the form of arrays with a lowerbound and upperbound per dimension or structures comprising nested structure array and scalar variables the codice type comprises these attributes the base scale precision and scale factor of the codice type is encoded within the codice the mode is specified separately with the codice applied to both the real and the imaginary parts values are computed by expressions written using a specific set of operations and builtin functions most of which may be applied to aggregates as well as to single values together with userdefined procedures which likewise may operate on and return aggregate as well as single values the assignment statement assigns values to one or more variables there are no reserved words in pli a statement is terminated by a semicolon the maximum length of a statement is implementation defined a comment may appear anywhere in a program where a space is permitted and is preceded by the characters forward slash asterisk and is terminated by the characters asterisk forward slash ie  statements may have a labelprefix introducing an entry name codice and codice statements or label name and a condition prefix enabling or disabling a computational condition eg codice entry and label names may be single identifiers or identifiers followed by a subscript list of constants as in codice a sequence of statements becomes a group when preceded by a codice statement and followed by an codice statement groups may include nested groups and begin blocks the codice statement specifies a group or a single statement as the codice part and the codice part see the sample program the group is the unit of iteration the begin block codice may contain declarations for names and internal procedures local to the block a procedure starts with a codice statement and is terminated syntactically by an codice statement the body of a procedure is a sequence of blocks groups and statements and contains declarations for names and procedures local to the procedure or codice to the procedure an onunit is a single statement or block of statements written to be executed when one or more of these conditions occur a computational condition or an inputoutput condition or one of the conditions a declaration of an identifier may contain one or more of the following attributes but they need to be mutually consistent current compilers from kednos micro focus and particularly that from ibm implement many extensions over the standardized version of the language the ibm extensions are summarised in the implementation subsection for the compiler later although there are some extensions common to these compilers the lack of a current standard means that compatibility is not guaranteed standardization language standardization began in april  in europe with ecma tc in  ansi established a composite language development committee nicknamed kludge which fortunately was renamed xj pli standardization became a joint effort of ecma tc and ansi xj a subset of the gy document was offered to the joint effort by ibm and became the base document for standardization the major features omitted from the base document were multitasking and the attributes for program optimization eg codice and codice proposals to change the base document were voted upon by both committees in the event that the committees disagreed the chairs initially michael marcotty of general motors and car hoare representing icl had to resolve the disagreement in addition to ibm honeywell cdc data general digital equipment prime computer burroughs rca and univac served on xj along with major users eastman kodak mitre union carbide bell laboratories and various government and university representatives further development of the language occurred in the standards bodies with continuing improvements in structured programming and internal consistency and with the omission of the more obscure or contentious features as language development neared an end xjtc realized that there were a number of problems with a document written in english text discussion of a single item might appear in multiple places which might or might not agree it was difficult to determine if there were omissions as well as inconsistencies consequently david beech ibm robert freiburghouse honeywell milton barber cdc m donald maclaren argonne national laboratory craig franklin data general lois frampton digital equipment and editor dj andrews of ibm undertook to rewrite the entire document each producing one or more complete chapters the standard is couched as a formal definition using a pli machine to specify the semantics it was the first and possibly the only programming language standard to be written as a semiformal definition a pli generalpurpose subset subsetg standard was issued by ansi in  and a revision published in  the general purpose subset was widely adopted as the kernel for pli implementations implementations ibm pli f and d compilers pli was first implemented by ibm at its hursley laboratories in the united kingdom as part of the development of system the first production pli compiler was the pli f compiler for the os operating system built by john nashs team at hursley in the uk the runtime library team was managed by im nobby clarke the pli f compiler was written entirely in system assembly language release  shipped in  os was a realmemory environment and the compiler was designed for systems with as little as  kilobytes of real storage  f being  kb in s parlance to fit a large compiler into the  kilobytes of memory available on a kilobyte machine the compiler consisted of a control phase and a large number of compiler phases approaching  the phases were brought into memory from disk and released one at a time to handle particular language features and aspects of compilation aspects of the language were still being designed as pli f was implemented so some were omitted until later releases pli record io was shipped with pli f release  the list processing functions based variables pointers areas and offsets and locatemode io were first shipped in release  in a major attempt to speed up pli code to compete with fortran object code pli f release  did substantial program optimization of doloops facilitated by the reorder option on procedures a version of pli f was released on the tss timesharing operating system for the system model  adapted at the ibm mohansic lab the ibm la gaude lab in france developed language conversion programs to convert fortran cobol and algol programs to the pli f level of pli the pli d compiler using  kilobytes of memory was developed by ibm germany for the dos low end operating system it implemented a subset of the pli language requiring all strings and arrays to have fixed extents thus simplifying the runtime environment reflecting the underlying operating system it lacked dynamic storage allocation and the controlled storage class it was shipped within a year of pli f multics pli and derivatives compilers were implemented by several groups in the early s the multics project at mit one of the first to develop an operating system in a highlevel language used early pli epl a subset dialect of pli as their implementation language in  epl was developed at bell labs and mit by douglas mcilroy robert morris and others the influential multics pli compiler described on the multicians website was the source of compiler technology used by a number of manufacturers and software groups the honeywell pli compiler for series  was an implementation of the full ansi xj standard ibm pli optimizing and checkout compilers the pli optimizer and checkout compilers produced in hursley supported a common level of pli language and aimed to replace the pli f compiler the checkout compiler was a rewrite of pli f in bsl ibms plilike proprietary implementation language later pls the performance objectives set for the compilers are shown in an ibm presentation to the bcs the compilers had to produce identical results the checkout compiler was used to debug programs that would then be submitted to the optimizer given that the compilers had entirely different designs and were handling the full pli language this goal was challenging it was achieved the pli optimizing compiler took over from the pli f compiler and was ibms workhorse compiler from the s to the s like pli f it was a multiple pass compiler with a  kilobyte design point but it was an entirely new design unlike the f compiler it had to perform compile time evaluation of constant expressions using the runtime library reducing the maximum memory for a compiler phase to  kilobytes a secondtime around design it succeeded in eliminating the annoyances of pli f such as cascading diagnostics it was written in s macro assembler by a team led by tony burbridge most of whom had worked on pli f macros were defined to automate common compiler services and to shield the compiler writers from the task of managing realmode storage allowing the compiler to be moved easily to other memory models the gamut of program optimization techniques developed for the contemporary ibm fortran h compiler were deployed the optimizer equaled fortran execution speeds in the hands of good programmers announced with the ibm s in  it shipped first for the dos operating system in august  and shortly afterward for os and the first virtual memory ibm operating systems osvs mvs and vmcms the developers were unaware that while they were shoehorning the code into  kb sections ibm poughkeepsie was finally ready to ship virtual memory support in os it supported the batch programming environments and under tso and cms it could be run interactively this compiler went through many versions covering all mainframe operating systems including the operating systems of the japanese pcms the compiler has been superseded by ibm pli for os aix linux zos below the pli checkout compiler colloquially the checker announced in august  was designed to speed and improve the debugging of pli programs the team was led by brian marks the threepass design cut the time to compile a program to  of that taken by the f compiler it was run from an interactive terminal converting pli programs into an internal format htext this format was interpreted by the checkout compiler at runtime detecting virtually all types of errors pointers were represented in  bytes containing the target address and a description of the referenced item thus permitting bad pointer use to be diagnosed in a conversational environment when an error was detected control was passed to the user who could inspect any variables introduce debugging statements and edit the source program over time the debugging capability of mainframe programming environments developed most of the functions offered by this compiler and it was withdrawn in the s digital pli perhaps the most commercially successful implementation aside from ibms was digital equipments  release of the ansi pli  subset the implementation is a strict superset of the ansi x pli general purpose subset and provides most of the features of the new ansi x pli general purpose subset the front end was designed by robert freiburghouse and the code generator was implemented by dave cutler who managed the design and implementation of vaxvms it runs on vms on vax and alpha and on tru uniprise systems inc was responsible for the compiler it is currently supported by kednos corporation teaching subset compilers in the late s and early s many us and canadian universities were establishing timesharing services on campus and needed conversational compilerinterpreters for use in teaching science mathematics engineering and computer science dartmouth were developing basic but pli was a popular choice as it was concise and easy to teach as the ibm offerings were unsuitable a number of schools built their own subsets of pli and their own interactive support examples are a compiler developed at cornell university for teaching a dialect called plc which had the unusual capability of never failing to compile any program through the use of extensive automatic correction of many syntax errors and by converting any remaining syntax errors to output statements the language was almost all of pli as implemented by ibm plc was a very fast compiler plago created at the polytechnic institute of brooklyn used a simplified subset of the pli language and focused on good diagnostic error messages and fast compilation times the computer systems research group of the university of toronto produced the spk compilers which supported a sequence of subsets of pli called sp sp sp  sp for teaching programming programs that ran without errors under the spk compilers produced the same results under other contemporary pli compilers such as ibms pli f compiler ibms checkout compiler or cornell universitys plc compiler other examples are pl by p grouse at the university of new south wales plum by marvin zelkowitz at the university of maryland and pluto from the university of toronto ibm pli for os aix linux zos in a major revamp of pli ibm santa teresa in california launched an entirely new compiler in  the initial shipment was for os and included most ansig features and many new pli features subsequent releases covered additional platforms mvs vm os aix and windows and continued to add functions to make pli fully competitive with other languages offered on the pc particularly c and c in areas where it had been overtaken the corresponding ibm language environment supports interoperation of pli programs with database and transaction systems and with programs written in c c and cobol the compiler supports all the data types needed for intercommunication with these languages the pli design principles were retained and withstood this major extension comprising several new data types new statements and statement options new exception conditions and new organisations of program source the resulting language is a compatible superset of the pli standard and of the earlier ibm compilers major topics added to pli were the latest series of pli compilers for zos called enterprise pli for zos leverage code generation for the latest zarchitecture processors z zec z via the use of archlvl parm control passed during compilation and was the second high level language supported by zos language environment to do so xl cc being the first and enterprise cobol v the last object orientation codice is a new computational data type the ordinal facilities are like those in pascal eg codice but in addition the name and internal values are accessible via builtin functions builtin functions provide access to an ordinal values predecessor and successor the codice see below allows additional codices to be declared composed from plis builtin attributes the codice locator data type is similar to the codice data type but strongly typed to bind only to a particular data structure the codice operator is used to select a data structure using a handle the codice attribute equivalent to codice in early pli specifications permits several scalar variables arrays or structures to share the same storage in a unit that occupies the amount of storage needed for the largest alternative competitiveness on pc and with c these attributes were added new stringhandling functions were added to centre text to edit using a picture format and to trim blanks or selected characters from the head or tail of text codice to codice from the right and codice and codice functions compound assignment operators a la c eg codice codice codice codice were added codice is equivalent to codice additional parameter descriptors and attributes were added for omitted arguments and variable length argument lists program readability  making intentions explicit the codice attribute declares an identifier as a constant derived from a specific literal value or restricted expression parameters can have the codice pass by address or codice pass by value attributes the codice and codice attributes prevent unintended assignments codice obviates the need for the contrived construct codice the codice introduces userspecified names eg codice for combinations of builtin attributes eg codice thus codice creates the codice name codice as an alias for the set of builtin attributes fixed binary codice applies to structures and their members it provides a codice name for a set of structure attributes and corresponding substructure member declarations for use in a structure declaration a generalisation of the codice attribute structured programming additions a codice statement to exit a loop and an codice to continue with the next iteration of a loop codice and codice options on iterative groups the package construct consisting of a set of procedures and declarations for use as a unit variables declared outside of the procedures are local to the package and can use codice codice or codice storage procedure names used in the package also are local but can be made external by means of the codice option of the codice interrupt handling the codice executed in an onunit terminates execution of the onunit and raises the condition again in the procedure that called the current one thus passing control to the corresponding onunit for that procedure the codice condition handles invalid operation codes detected by the pc processor as well as illegal arithmetic operations such as subtraction of two infinite values the codice condition is provided to intercept conditions for which no specific onunit has been provided in the current procedure the codice condition is raised when an codice statement is unable to obtain sufficient storage other mainframe and minicomputer compilers a number of vendors produced compilers to compete with ibm pli f or optimizing compiler on mainframes and minicomputers in the s in the s the target was usually the emerging ansig subset usage pli implementations were developed for mainframes from the late s mini computers in the s and personal computers in the s and s although its main use has been on mainframes there are pli versions for dos microsoft windows os aix openvms and unix it has been widely used in business data processing and for system use for writing operating systems on certain platforms very complex and powerful systems have been built with pli the sas system was initially written in pli the sas data step is still modeled on pli syntax the pioneering online airline reservation system sabre was originally written for the ibm  in assembler the s version was largely written using sabretalk a purpose built subset pli compiler for a dedicated control program pli was used to write an executable formal definition to interpret ibms system network architecture pli did not fulfill its supporters hopes that it would displace fortran and cobol and become the major player on mainframes it remained a minority but significant player there cannot be a definitive explanation for this but some trends in the s and s militated against its success by progressively reducing the territory on which pli enjoyed a competitive advantage first the nature of the mainframe software environment changed application subsystems for database and transaction processing cics and ims and oracle on system  and application generators became the focus of mainframe users application development significant parts of the language became irrelevant because of the need to use the corresponding native features of the subsystems such as tasking and much of inputoutput fortran was not used in these application areas confining pli to cobols territory most users stayed with cobol but as the pc became the dominant environment for program development fortran cobol and pli all became minority languages overtaken by c java and the like second pli was overtaken in the system programming field the ibm system programming community was not ready to use pli instead ibm developed and adopted a proprietary dialect of pli for system programming  pls with the success of pls inside ibm and of c outside ibm the unique pli strengths for system programming became less valuable third the development environments grew capabilities for interactive software development that again made the unique pli interactive and debugging strengths less valuable fourth cobol and fortran added features such as structured programming character string operations and object orientation that further reduced plis relative advantages on mainframes there were substantial business issues at stake too ibms hardware competitors had little to gain and much to lose from success of pli compiler development was expensive and the ibm compiler groups had an inbuilt competitive advantage many ibm users wished to avoid being locked into proprietary solutions with no early support for pli by other vendors it was best to avoid pli evolution of the pli language this article uses the pli standard as the reference point for language features but a number of features of significance in the early implementations were not in the standard and some were offered by nonibm compilers and the de facto language continued to grow after the standard ultimately driven by developments on the personal computer significant features omitted from the standard multi tasking multi tasking was implemented by pli f the optimizer and the newer aix and zos compilers it comprised the data types codice and codice the codice on the codice fork the codice join the codice codices on the record io statements and the codice statement to unlock locked records on codice files event data identify a particular event and indicate whether it is complete b or incomplete b task data items identify a particular task or process and indicate its priority relative to other tasks preprocessor the first ibm compile time preprocessor was built by the ibm boston advanced programming center located in cambridge mass and shipped with the pli f compiler the codice statement was in the standard but the rest of the features were not the dec and kednos pli compilers implemented much the same set of features as ibm with some additions of their own ibm has continued to add preprocessor features to its compilers the preprocessor treats the written source program as a sequence of tokens copying them to an output source file or acting on them when a  token is encountered the following compile time statement is executed when an identifier token is encountered and the identifier has been codiced codiced and assigned a compile time value the identifier is replaced by this value tokens are added to the output stream if they do not require action eg codice as are the values of activated compile time expressions thus a compile time variable codice could be declared activated and assigned using codice subsequent occurrences of codice would be replaced by codice the data type supported are codice integers and codice strings of varying length with no maximum length the structure statements are and the simple statements which also may have a labellist the feature allowed programmers to use identifiers for constants eg product part numbers or mathematical constants and was superseded in the standard by named constants for computational data conditional compiling and iterative generation of source code possible with compiletime facilities was not supported by the standard several manufacturers implemented these facilities structured programming additions structured programming additions were made to pli during standardization but were not accepted into the standard these features were the codice to exit from an iterative codice the codice and codice added to codice and a case statement of the general form codice these features were all included in dec pli debug facilities pli f had offered some debug facilities that were not put forward for the standard but were implemented by others notably the checkvariablelist condition prefix codice oncondition and the codice option the ibm optimizing and checkout compilers added additional features appropriate to the conversational mainframe programming environment eg an codice condition significant features developed since the standard several attempts had been made to design a structure member type that could have one of several datatypes codice in early ibm with the growth of classes in programming theory approaches to this became possible on a pli base codice codice etc have been added by several compilers pli had been conceived in a singlebyte character world with support for japanese and chinese language becoming essential and the developments on international code pages the character string concept was expanded to accommodate wide nonasciiebcdic strings time and date handling were overhauled to deal with the millennium problem with the introduction of the datetime function that returned the date and time in one of about  different formats several other date functions deal with conversions to and from days and seconds criticisms implementation issues though the language is easy to learn and use implementing a pli compiler was difficult and timeconsuming a language as large as pli needed subsets that most vendors could produce and most users master this was not resolved until ansi g was published the compile time facilities unique to pli took added implementation effort and additional compiler passes a pli compiler was two to four times as large as comparable fortran or cobol compilers and also that much slowerfortunately offset by gains in programmer productivity this was anticipated in ibm before the first compilers were written some argued that pli was unusually hard to parse the pli keywords were not reserved so programmers could use them as variable or procedure names in programs because the original pli f compiler attempted autocorrection when it encountered a keyword used in an incorrect context it often assumed it was a variable name this led to cascading diagnostics a problem solved by later compilers the effort needed to produce good object code was perhaps underestimated during the initial design of the language program optimization needed to compete with the excellent program optimization carried out by available fortran compilers was unusually complex owing to side effects and pervasive problems with aliasing of variables unpredictable modification can occur asynchronously in exception handlers which may be provided by on statements in unseen callers together these make it difficult to reliably predict when a programs variables might be modified at runtime in typical use however userwritten error handlers the codice do not make assignments to variables in spite of the aforementioned difficulties ibm produced its pli optimising compiler in  pli contained many rarely used features such as multitasking support which added cost and complexity to the compiler and its coprocessing facilities required a multiprogramming environment with support for nonblocking multiple threads for processes by the operating system compiler writers were free to select whether to implement these features an undeclared variable was by default being declared by first occurrencethus misspelling might lead to unpredictable results this was no different from fortran programs for pli f however an attribute listing enabled the programmer to detect any misspelled or undeclared variable programmer issues many programmers were slow to move from cobol or fortran due to a perceived complexity of the language and immaturity of the pli f compiler programmers were sharply divided into scientific programmers who used fortran and business programmers who used cobol with significant tension and even dislike between the groups pli syntax borrowed from both cobol and fortran syntax so instead of noticing features that would make their job easier fortran programmers of the time noticed cobol syntax and had the opinion that it was a business language while cobol programmers noticed fortran syntax and looked upon it as a scientific language both cobol and fortran programmers viewed it as a bigger version of their own language and both were somewhat intimidated by the language and disinclined to adopt it another factor was pseudosimilarities to cobol fortran and algol these were pli elements that looked similar to one of those languages but worked differently in pli such frustrations left many experienced programmers with a jaundiced view of pli and often an active dislike for the language an early unix fortune file contained the following tongueincheek description of the language speaking as someone who has delved into the intricacies of pli i am sure that only real men could have written such a machinehogging cyclegrabbing allencompassing monster allocate an array and free the middle third sure why not multiply a character string times a bit string and assign the result to a float decimal go ahead free a controlled variable procedure parameter and reallocate it before passing it back overlay three different types of variable on the same memory location anything you say write a recursive macro well no but real men use rescan how could a language so obviously designed and written by real men not be intended for real man use on the positive side full support for pointers to all data types including pointers to structures recursion multitasking string handling and extensive builtin functions pli was indeed quite a leap forward compared to the programming languages of its time however these were not enough to convince a majority of programmers or shops to switch to pli the pli f compilers compile time preprocessor was unusual outside the lisp world in using its target languages syntax and semantics eg as compared to the c preprocessors  directives special topics in pli storage classes pli provides several storage classes to indicate how the lifetime of variables storage is to be managed codice and codice the simplest to implement is codice which indicates that memory is allocated and initialized at loadtime as is done in cobol workingstorage and early fortran this is the default for codice variables plis default storage class for codice variables is codice similar to that of other blockstructured languages influenced by algol like the auto storage class in the c language and default storage allocation in pascal and localstorage in ibm cobol storage for codice variables is allocated upon entry into the codice procedure or onunit in which they are declared the compiler and runtime system allocate memory for a stack frame to contain them and other housekeeping information if a variable is declared with an codice code to set it to an initial value is executed at this time care is required to manage the use of initialization properly large amounts of code can be executed to initialize variables every time a scope is entered especially if the variable is an array or structure storage for codice variables is freed at block exit codice or codice variables are used to retain variables contents between invocations of a procedure or block codice storage is also managed using a stack but the pushing and popping of allocations on the stack is managed by the programmer using codice and codice statements storage for codice variables is managed using codice but instead of a stack these allocations have independent lifetimes and are addressed through codice or codice variables storage type sharing there are several ways of accessing allocated storage through different data declarations some of these are well defined and safe some can be used safely with careful programming and some are inherently unsafe andor machine dependent passing a variable as an argument to a parameter by reference allows the arguments allocated storage to be referenced using the parameter the codice attribute eg codice allows part or all of a variables storage to be used with a different but consistent declaration these two usages are safe and machine independent record io and list processing produce situations where the programmer needs to fit a declaration to the storage of the next record or item before knowing what type of data structure it has based variables and pointers are key to such programs the data structures must be designed appropriately typically using fields in a data structure to encode information about its type and size the fields can be held in the preceding structure or with some constraints in the current one where the encoding is in the preceding structure the program needs to allocate a based variable with a declaration that matches the current item using expressions for extents where needed where the type and size information are to be kept in the current structure self defining structures the typedefining fields must be ahead of the type dependent items and in the same place in every version of the data structure the codiceoption is used for selfdefining extents eg string lengths as in codice where codice is used to allocate instances of the data structure for selfdefining structures any typing and codice fields are placed ahead of the real data if the records in a data set or the items in a list of data structures are organised this way they can be handled safely in a machine independent way pli implementations do not except for the pli checkout compiler keep track of the data structure used when storage is first allocated any codice declaration can be used with a pointer into the storage to access the storage inherently unsafe and machine dependent however this usage has become important for pointer arithmetic typically adding a certain amount to a known address this has been a contentious subject in computer science in addition to the problem of wild references and buffer overruns issues arise due to the alignment and length for data types used with particular machines and compilers many cases where pointer arithmetic might be needed involve finding a pointer to an element inside a larger data structure the codice function computes such pointers safely and machine independently pointer arithmetic may be accomplished by aliasing a binary variable with a pointer as in codice it relies on pointers being the same length as codice integers and aligned on the same boundaries with the prevalence of c and its free and easy attitude to pointer arithmetic recent ibm pli compilers allow pointers to be used with the addition and subtraction operators to giving the simplest syntax but compiler options can disallow these practices where safety and machine independence are paramount onunits and exception handling when pli was designed programs only ran in batch mode with no possible intervention from the programmer at a terminal an exceptional condition such as division by zero would abort the program yielding only a hexadecimal core dump pli exception handling via onunits allowed the program to stay in control in the face of hardware or operating system exceptions and to recover debugging information before closing down more gracefully as a program became properly debugged most of the exception handling could be removed or disabled this level of control became less important when conversational execution became commonplace computational exception handling is enabled and disabled by condition prefixes on statements blocksincluding onunits and procedures  eg codice operating system exceptions for inputoutput and storage management are always enabled the onunit is a single statement or codiceblock introduced by an codice executing the on statement enables the condition specified eg codice when the exception for this condition occurs and the condition is enabled the onunit for the condition is executed onunits are inherited down the call chain when a block procedure or onunit is activated the onunits established by the invoking activation are inherited by the new activation they may be overridden by another codice and can be reestablished by the codice the exception can be simulated using the codice  eg to help debug the exception handlers the dynamic inheritance principle for onunits allows a routine to handle the exceptions occurring within the subroutines it uses if no onunit is in effect when a condition is raised a standard system action is taken often this is to raise the codice condition the system action can be reestablished using the codice option of the codice with some conditions it is possible to complete executing an onunit and return to the point of interrupt eg the codice conditions and resume normal execution with other conditions such as codice the codice condition is raised when this is attempted an onunit may be terminated with a codice preventing a return to the point of interrupt but permitting the program to continue execution elsewhere as determined by the programmer an onunit needs to be designed to deal with exceptions that occur in the onunit itself the codice statement allows a nested error trap if an error occurs within an onunit control might pass to the operating system where a system dump might be produced or for some computational conditions continue execution as mentioned above the pli codice io statements have relatively simple syntax as they do not offer options for the many situations from endoffile to record transmission errors that can occur when a record is read or written instead these complexities are handled in the onunits for the various file conditions the same approach was adopted for codice suballocation and the codice condition the existence of exception handling onunits can have an effect on optimization because variables can be inspected or altered in onunits values of variables that might otherwise be kept in registers between statements may need to be returned to storage between statements this is discussed in the section on implementation issues above