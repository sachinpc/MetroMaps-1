e programming language e is an objectoriented programming language for secure distributed computing created by mark s miller dan bornstein and others at electric communities in  e is mainly descended from the concurrent language joule and from originale a set of extensions to java for secure distributed programming e combines messagebased computation with javalike syntax a concurrency model based on event loops and promises ensures that deadlock can never occur philosophy inspired by minjie shen the entire language is designed with secure computing in mind this is accomplished chiefly by strict adherence to the objectoriented computing model which in its pure form has properties that support secure computing the e language and its standard library employ a capabilitybased design philosophy throughout in order to help programmers build secure software and to enable software components to cooperate even if they dont fully trust each other in e object references serve as capabilities hence capabilities add no computational or conceptual overhead costs the language syntax is designed to be easy for people to audit for security flaws for example lexical scoping limits the amount of code that has to be examined for its effects on a given variable as another example the language uses the  operator for comparison and the  operator for assignment to avoid the possibility of confusion there is no  operator computational model in e all values are objects and computation is performed by sending messages to objects each object belongs to a vat analogous to a process each vat has a single thread of execution a stack frame and an event queue distributed programming is just a matter of sending messages to remote objects objects in other vats all communication with remote parties is encrypted by the e runtime arriving messages are placed into the vats event queue the vats event loop processes the incoming messages one by one in order of arrival e has two ways of sending messages the immediate call and the eventual send an immediate call is just like a typical function or method call in a nonconcurrent language the sender waits until the receiver finishes and returns a value an eventual send sends the message while producing a placeholder for the result called a promise the sender proceeds immediately with the promise later when the receiver finishes and yields a result the promise resolves to the result since only eventual sends are allowed when communicating with remote objects deadlocks cannot happen in distributed systems the promise mechanism also minimizes delays caused by network latency syntax and examples es syntax is most similar to java though it also bears some resemblance to python and pascal variables are dynamically typed and lexically scoped unlike java or python however e is composed entirely of expressions here is an extremely simple e program here is a recursive function for computing the factorial of a number written in e functions are defined using the def keyword in the first line int is a guard that constrains the argument and result of the function a guard is not quite the same thing as a type declaration guards are optional and can specify constraints the first int ensures that the body of the function will only have to handle an integer argument without the second int above the function would not be able to return a value being able to see up front that information escapes out of the function is helpful for security auditing since e is intended to support secure cooperation the canonical example for e programs is the mint a simple electronic money system in just a few lines of e the following code defines a function that makes mints where each mint has its own currency each mint can make purses that hold its currency and any holder of two purses of the same currency can securely transfer money between the purses by quick examination of the source code an e programmer can easily verify that only mints may change the amount of money in circulation that money can only be created and not destroyed that mints can only create money of their own currency and that only the holder of a purse can change its balance objects in e are defined with the def keyword and within the object definition the to keyword begins each method the guard expressions in this example illustrate how to specify a value constraint as in int   or balance the mint example makes use of a builtin mechanism called a sealer the function makebrandpair creates two associated objects a sealer and an unsealer such that the sealer can seal an object in a box and the unsealer is the only object that can retrieve the contents of the box see the e website for a more detailed explanation of this money example