comparison of c sharp and java this article compares two programming languages c with java while the focus of this article is mainly the languages and their features such a comparison will necessarily also consider some features of platforms and libraries for a more detailed comparison of the platforms please see comparison of the java and net platforms c and java are similar languages that are typed statically strongly and manifestly both are objectoriented classbased and designed with semiinterpretation or runtime justintime compilation both use garbagecollection and both are curly brace languages like c and c types unified type system both languages are statically typed with classbased object orientation in java the primitive types are special in that they are not objectoriented and they could not have been defined using the language itself they also do not share a common ancestor with reference types the java reference types all derive from a common root type c has a unified type system in which all types besides unsafe pointers ultimately derive from a common root type consequently all types implement the methods of this root type and extension methods defined for the codice type apply to all types even primitive codice literals and delegates note that unlike java this allows c to support objects with encapsulation that are not reference types in java compound types are synonymous with reference types methods cannot be defined for a type unless it is also a class reference type in c the concepts of encapsulation and methods have been decoupled from the reference requirement so that a type can support methods and encapsulation without being a reference type only reference types support virtual methods and specialization however both languages support many builtin types that are copied and passed by value rather than by reference java calls these types primitive types while they are called simple types in c the simpleprimitive types typically have native support from the underlying processor architecture the c primitivesimple types implement several interfaces and consequently offer many methods directly on instances of the types even on the literals the c type names are also merely aliases for common language runtimeclr types the c codice type is exactly the same type as the codice type the only difference is that the former is the canonical net name while the latter is a c alias for it java does not offer methods directly on the primitive types instead methods that operate on the primitive values are offered through companion primitive wrapper classes a fixed set of such wrapper classes exist each of which wraps one of the fixed set of primitive types as an example the java codice type is a reference type that wraps the primitive codice type they are not the same type however both java and c support signed integers with bit widths of    and  bits they use the same namealiases for the types except for the bit integer which is called a byte in java and a sbyte signed byte in c c supports unsigned in addition to the signed integer types the unsigned types are byte ushort uint and ulong for    and  bit widths respectively unsigned arithmetic operating on the types are supported as well for example adding two unsigned integers uints still yields a uint as a result not a long or signed integer data types numeric types java does not feature unsigned integer types in particular java lacks a primitive type for an unsigned byte instead javas byte type is sign extended which is a common source of bugs and confusion unsigned integers were left out of java deliberately because james gosling believed that programmers would not understand how unsigned arithmetic worksin programming language design one of the standard problems is that the language grows so complex that nobody can understand it one of the little experiments i tried was asking people about the rules for unsigned arithmetic in c it turns out nobody understands how unsigned arithmetic in c works there are a few obvious things that people understand but many people dont understand it c has a type and literal notation for highprecision  decimal digits decimal arithmetic which is appropriate for financial and monetary calculations contrary to the float and double data types decimal fractional numbers such as  can be represented exactly in the decimal representation in the float and double representations such numbers often have nonterminating binary expansions making those representations more prone to roundoff errors while java lacks such a builtin type the java library does feature an arbitrary precision decimal type this is not considered a language type and it does not support the usual arithmetic operators rather it is a reference type that must be manipulated using the type methods see more about arbitrary sizeprecision numbers below advanced numeric types both languages offer librarydefined arbitraryprecision arithmetic types for arbitrary size integers and decimal point calculations only java has a data type for arbitrary precision decimal point calculations only c has a type for working with complex numbers in both languages the number of operations that can be performed on the advanced numeric types are limited compared to the builtin ieee  floating point types for instance none of the arbitrary size types support square root or logarithms c allows library defined types to be integrated with existing types and operators by using custom implicitexplicit conversions and operator overloading see example integration of library defined types characters both languages feature a native codice character datatype as a simple type although the codice type can be used with bitwise operators this is performed by promoting the codice value to an integer value before the operation thus the result of a bitwise operation is a numeric type not a character in both languages builtin compound data types both languages treat strings as immutable objects of reference type in both languages the type contains several methods to manipulate strings parse format etc in both languages regular expressions are considered an external feature and are implemented in separate classes both languages libraries define classes for working with dates and calendars in different cultures the java codice is a mutable reference type where the c codice is a struct value type c additionally defines a codice type for working with time periods both languages support date and time arithmetic according to different cultures userdefined value type struct c allows the programmer to create userdefined value types using the codice keyword unlike classes and like the standard primitives such value types are passed and assigned by value rather than by reference they can also be part of an object either as a field or boxed or stored in an array without the memory indirection that normally exists for class types because value types have no notion of a codice value and can be used in arrays without initialization they always come with an implicit default constructor that essentially fills the struct memory space with zeroes the programmer can only define additional constructors with one or more arguments value types do not have virtual method tables and because of that and the fixed memory footprint they are implicitly sealed however value types can and frequently do implement interfaces for example the builtin integer types implement several interfaces apart from the builtin primitive types java does not include the concept of value types enumerations both languages define enumerations but they are implemented in fundamentally different ways as such enumerations are one area where tools designed to automatically translate code between the two languages such as java to c converters fail c has implemented enumerations in a manner similar to c that is as wrappers around the bitflags implemented in primitive integral types int byte short etc this has performance benefits and improves interaction with cc compiled code but provides fewer features and can lead to bugs if lowlevel value types are directly cast to an enumeration type as is allowed in the c language in contrast java implements enumerations as full featured collection of instances requiring more memory and not aiding interaction with cc code but providing additional features in reflection and intrinsic behavior the implementation in each language is described in the table below in both c and java programmers can use enumerations in a switch statement without conversion to a string or primitive integer type however c disallows fallthroughs unless the case statement does not contain any code as they are a main cause for hardtofind bugs fallthroughs must be explicitly declared using goto case delegates method references c implements objectoriented method pointers in the form of delegates a delegate is a special type that can capture a typesafe reference to a method this reference can then be stored in a delegatetype variable or passed to a method through a delegate parameter for later invocation c delegates support covariance and contravariance and can hold a reference to any signaturecompatible static method instance method anonymous method or lambda expression delegates should not be confused with closures and inline functions the concepts are related because a reference to a closureinline function must be captured in a delegate reference to be useful at all but a delegate does not always reference an inline function it can also reference existing static or instance methods delegates form the basis of c events but should not be confused with those either delegates were deliberately left out of java because they were considered unnecessary and detrimental to the language and because of potential performance issues instead alternative mechanisms are used the wrapper pattern which resembles the delegates of c in that it allows the client to access one or more clientdefined methods through a known interface is one such mechanism another is the use of adapter objects using inner classes which the designers of java argued are a better solution than bound method references see also example c delegates and equivalent java constructs lifted nullable types c allows valueprimitivesimple types to be lifted to allow the special codice value in addition to the types native values a type is lifted by adding a codice suffix to the type name this is equivalent to using the codice generic type where codice is the type to be lifted conversions are implicitly defined to convert between values of the base and the lifted type the lifted type can be compared against codice or it can be tested for codice also lifted operators are implicitly and automatically defined based on their nonlifted base where  with the exception of some boolean operators  a null argument will propagate to the result java does not support type lifting as a concept but all of the builtin primitive types have corresponding wrapper types which do support the codice value by virtue of being reference types classes according to the java spec any attempt to dereference the codice reference must result in an exception being thrown at runtime specifically a codice it would not make sense to dereference it otherwise because by definition it points to no object in memory this also applies when attempting to unbox a variable of a wrapper type which evaluates to codice the program will throw an exception because there is no object to be unboxed  and thus no boxed value to take part in the subsequent computation the following example illustrates the different behavior in c the lifted  operator propagates the codice value of the operand in java unboxing the null reference throws an exception not all c lifted operators have been defined to propagate codice unconditionally if one of the operands is codice specifically the boolean operators have been lifted to support ternary logic thus keeping impedance with sql the java boolean operators do not support ternary logic nor is it implemented in the base class library latebound dynamic type c features a late bound dynamic type that supports noreflection dynamic invocation interoperability with dynamic languages and adhoc binding to for example document object models the codice type resolves member access dynamically at runtime as opposed to staticallyvirtual at compile time the member lookup mechanism is extensible with traditional reflection as a fallback mechanism there are several use cases for the codice type in c java does not support a latebound type the use cases for c dynamic type have different corresponding constructs in java see also example interoperability with dynamic languages pointers java precludes pointers and pointerarithmetic within the java runtime environment the java language designers reasoned that pointers are one of the main features that enable programmers to put bugs in their code and chose not to support them java does not allow for directly passing and receiving objectsstructures tofrom the underlying operating system and thus does not need to model objectsstructures to such a specific memory layout layouts which frequently would involve pointers javas communication with the underlying operating system is instead based upon java native interface jni where communication withadaption to an underlying operating system is handled through an external glue layer while c does allow use of pointers and corresponding pointer arithmetic the c language designers had the same concerns that pointers could potentially be used to bypass the strict rules for object access thus c by default also precludes pointers however because pointers are needed when calling many native functions pointers are allowed in an explicit unsafe mode code blocks or methods that use the pointers must be marked with the codice keyword to be able to use pointers and the compiler requires the codice switch to allow compiling such code assemblies which are compiled using the codice switch are marked as such and may only execute if explicitly trusted this allows using pointers and pointer arithmetic to directly pass and receive objects tofrom the operating system or other native apis using the native memory layout for those objects while at the same time isolating such potentially unsafe code in specifically trusted assemblies reference types in both languages references are a central concept all instances of classes are by reference while not directly evident in the language syntax per se both languages support the concept of weak references an instance that is only referenced by weak references is eligible for garbage collection just as if there were no references at all in both languages this feature is exposed through the associated libraries even though it is really a core runtime feature along with weak references java has soft references they are much like weak references but the jvm will not deallocate softlyreferenced objects until the memory is needed arrays and collections arrays and collections are concepts featured by both languages the syntax used to declare and access arrays is identical except that c has added syntax for declaring and manipulating multidimensional arrays multidimensional arrays can in some cases increase performance because of increased locality as there is one pointer dereference instead of one for every dimension of the array as is the case for jagged arrays however since all array element access in a multidimensional array requires multiplicationshift between the two or more dimensions this is an advantage only in very random access scenarios another difference is that the entire multidimensional array can be allocated with a single application of operator codice while jagged arrays require loops and allocations for every dimension note though that java provides a syntactic construct for allocating a jagged array with regular lengths the loops and multiple allocations are then performed by the virtual machine and need not be explicit at the source level both languages feature an extensive set of collection types that includes various ordered and unordered types of lists mapsdictionaries sets etc java also supports the syntax of cc expressions and operators boxing and unboxing both languages allow automatic boxing and unboxing ie they allow for implicit casting between any primitive types and the corresponding reference types in c the primitive types are subtypes of the object type in java this is not true any given primitive type and the corresponding wrapper type have no specific relationship with each other except for autoboxing and unboxing which act as syntactic sugar for interchanging between them this was done intentionally to maintain backward compatibility with prior versions of java in which no automatic casting was allowed and the programmer worked with two separate sets of types the primitive types and the wrapper reference type hierarchy this difference has the following consequences first of all in c primitive types can define methods such as an override of objects codice method in java this task is accomplished by the primitive wrapper classes secondly in java an extra cast is needed whenever one tries to directly dereference a primitive value as it will not be boxed automatically the expression codice will convert an integer literal to string in java while codice performs the same operation in c this is because the latter one is an instance call on the primitive value codice while the former one is an instance call on an object of type javalanginteger finally another difference is that java makes heavy use of boxed types in generics see below syntax both languages are considered curly brace languages in the cc family overall the syntaxes of the languages are very similar the syntax at the statement and expression level is almost identical with obvious inspiration from the cc tradition at type definition level classes and interfaces some minor differences exist java is explicit about extending classes and implementing interfaces while c infers this from the kind of types a new classinterface derives from c supports more features than java which to some extent is also evident in the syntax that specifies more keywords and more grammar rules than java keywords and backward compatibility as the languages evolved the language designers for both languages have faced situations where they wanted to extend the languages with new keywords or syntax new keywords in particular may break existing code at source level ie older code may no longer compile if presented to a compiler for a later version of the language language designers are keen to avoid such regressions the designers of the two languages have been following different paths when addressing this problem java language designers have avoided new keywords as much as possible preferring instead to introduce new syntactic constructs that were not legal before or to reuse existing keywords in new contexts this way they didnt jeopardize backward compatibility an example of the former can be found in how the codice loop was extended to accept iterable types an example of the latter can be found in how the codice and especially the codice keywords were reused for specifying type bounds when generics were introduced in java  at one time java  a new keyword codice was introduced that was not reserved as a keyword before this had the potential to render previously valid code invalid if for instance the code used codice as an identifier the designers chose to address this problem with a fourstep solution  introducing a compiler switch that indicates if java  or later should be used  only marking codice as a keyword when compiling as java  and later  defaulting to  to avoid rendering previous non  aware code invalid and  issue warnings if the keyword is used in java  mode in order to allow the developers to change the code c language designers have introduced several new keywords since the first version however instead of defining these keywords as global keywords they define them as context sensitive keywords this means that even when they introduced among others the codice and codice keywords in c  the use of those words as identifiers is still valid as there is no clash possible between the use as keyword and the use as identifier given the context thus the present c syntax is fully backward compatible with source code written for any previous version without specifying the language version to be used objectoriented programming both c and java are designed from the ground up as objectoriented languages using dynamic dispatch with syntax similar to c c in turn derives from c neither language is a superset of c or c however partial class c allows a class definition to be split across several source files using a feature called partial classes each part must be marked with the keyword codice all the parts must be presented to the compiler as part of a single compilation parts can reference members from other parts parts can implement interfaces and one part can define a base class the feature is useful in code generation scenarios such as user interface ui design where a code generator can supply one part and the developer another part to be compiled together the developer can thus edit their part without the risk of a code generator overwriting that code at some later time unlike the class extension mechanism a partial class allows circular dependencies among its parts as they are guaranteed to be resolved at compile time java has no corresponding concept inner and local classes both languages allow inner classes where a class is defined lexically inside another class however in each language these inner classes have rather different semantics in java unless the inner class is declared codice a reference to an instance of an inner class carries a reference to the outer class with it as a result code in the inner class has access to both the static and nonstatic members of the outer class to create an instance of a nonstatic inner class the instance of the embracing outer class must be named this is done via a new codiceoperator introduced in jdk  codice this can be done in any class that has a reference to an instance of the outer class in c an inner class is conceptually the same as a normal class in a sense the outer class only acts as a namespace thus code in the inner class cannot access nonstatic members of the outer class unless it does so through an explicit reference to an instance of the outer class programmers can declare the inner class private to allow only the outer class to have any access to it java provides another feature called local classes or anonymous classes which can be defined within a method body these are generally used to implement an interface with only one or two methods which are typically event handlers however they can also be used to override virtual methods of a superclass the methods in those local classes have access to the outer methods local variables declared codice c satisfies the usecases for these by providing anonymous delegates see event handling for more about this c also provides a feature called anonymous typesclasses but it is rather different from javas concept with the same name it allows the programmer to instantiate a class by providing only a set of names for the properties the class should have and an expression to initialize each the types of the properties are inferred from the types of those expressions these implicitlydeclared classes are derived directly from object event c multicastdelegates are used with events events provide support for eventdriven programming and is an implementation of the observer pattern to support this there is a specific syntax to define events in classes and operators to register unregister or combine event handlers see here for information about how events are implemented in java operator overloading and conversions operator overloading and userdefined casts are separate features that both aim to allow new types to become firstclass citizens in the type system by using these features in c types such as codice and codice have been integrated so that the usual operators like addition and multiplication work with the new types unlike c c does restrict the use of operator overloading prohibiting it for the operators codice codice codice codice codice and any variations of compound statements like codice but compound operators will call overloaded simple operators like codice calling codice and codice java does not include operator overloading nor custom conversions in order to prevent abuse of the feature and to keep the language simple indexer c also includes indexers that can be considered a special case of operator overloading like the c codice or parameterized codicecodice properties an indexer is a property named codice that uses one or more parameters indexes the indices can be objects of any type java does not include indexers the common java pattern involves writing explicit getters and setters where a c programmer would use an indexer fields and initialization object initialization in both c and java an objects fields can be initialized either by variable initializers expressions that can be assigned to variables where they are defined or by constructors special subroutines that are executed when an object is being created in addition java contains instance initializers which are anonymous blocks of code with no arguments that are run after the explicit or implicit call to a superclasss constructor but before the constructor is executed c initializes object fields in the following order when creating an object some of the above fields may not be applicable eg if an object does not have static fields derived fields are those that are defined in the objects direct class while base field is a term for the fields that are defined in one of the objects superclasses note that an object representation in memory contains all fields defined in its class or any of its superclasses even if some fields in superclasses are defined as private it is guaranteed that any field initializers take effect before any constructors are called since both the instance constructor of the objects class and its superclasses are called after field initializers are called there is however a potential trap in object initialization when a virtual method is called from a base constructor the overridden method in a subclass may reference a field that is defined in the subclass but this field may not have been initialized because the constructor of the subclass that contains field initialization is called after the constructor of its base class in java the order of initialization is as follows like in c a new object is created by calling a specific constructor within a constructor the first statement may be an invocation of another constructor if this is omitted the call to the argumentless constructor of the superclass is added implicitly by the compiler otherwise either another overloaded constructor of the objects class can be called explicitly or a superclass constructor can be called in the former case the called constructor will again call another constructor either of the objects class or its subclass and the chain sooner or later ends up at the call to one of the constructors of the superclass after another constructor is called that causes direct invocation of the superclass constructor and so forth down to the object class instance variables defined in the objects class are initialized even if there are no variable initializers explicitly defined for some variables these variables are initialized to default values note that instance variables defined in superclasses are already initialized by this point because they were initialized by a superclass constructor when it was called either by the constructors code or by variable initializers performed before the constructors code or implicitly to default values in java variable initializers are executed according to their textual order in the source file finally the constructor body is executed this ensures proper order of initialization ie the fields of a base class finish initialization before initialization of the fields of an object class begins there are two main potential traps in javas object initialization first variable initializers are expressions that can contain method calls since methods can reference any variable defined in the class the method called in a variable initializer can reference a variable that is defined below the variable being initialized since initialization order corresponds to textual order of variable definitions such a variable would not be initialized to the value prescribed by its initializer and would contain the default value another potential trap is when a method that is overridden in the derived class is called in the base class constructor which can lead to behavior the programmer would not expect when an object of the derived class is created according to the initialization order the body of the base class constructor is executed before variable initializers are evaluated and before the body of the derived class constructor is executed the overridden method called from the base class constructor can however reference variables defined in the derived class but these are not yet initialized to the values specified by their initializers or set in the derived class constructor the latter issue applies to c as well but in a less critical form since in c methods are not overridable by default resource disposal both languages mainly use garbage collection as a means of reclaiming memory resources rather than explicit deallocation of memory in both cases if an object holds resources of different kinds other than memory such as file handles graphical resources etc then it must be notified explicitly when the application no longer uses it both c and java offer interfaces for such deterministic disposal and both c and java since java  feature automatic resource management statements that will automatically invoke the disposalclose methods on those interfaces methods extension methods and default methods using a special this designator on the first parameter of a method c allows the method to act as if it were a member method of the type of the first parameter this extension of the foreign class is purely syntactical the extension method must be declared static and defined within a purely static class the method must obey any member access restriction like any other method external to the class thus static methods cannot break object encapsulation the extension is only active within scopes where the namespace of the static host class has been imported since java  java has a similar feature called default methods which are methods with a body declared on interfaces as opposed to c extension methods java default methods are instance methods on the interface which declare them definition of default methods in classes that implement the interface is optional if the class does not define the method the default definition is used instead both the c extension methods and the java default methods allow a class to override the default implementation of the extensiondefault method respectively in both languages this override is achieved by defining a method on the class that should use an alternate implementation of the method c scope rules defines that if a matching method is found on a class it takes precedence over a matching extension method in java any class declared to implement an interface with default method is assumed to have the default methods implementions unless the class implements the method itself partial methods related to partial classes c allows partial methods to be specified within partial classes a partial method is an intentional declaration of a method with several restrictions on the signature the restrictions ensure that if a definition is not provided by any class part then the method and every call to it can be safely erased this feature allows code to provide a large number of interception points like the template method gof design pattern without paying any runtime overhead if these extension points are not being used by another class part at compile time java has no corresponding concept virtual methods methods in c are nonvirtual by default and must be declared virtual explicitly if desired in java all nonstatic nonprivate methods are virtual virtuality guarantees that the most recent override for the method will always be called but incurs a certain runtime cost on invocation as these invocations cannot be normally inlined and require an indirect call via the virtual method table however some jvm implementations including the oracle reference implementation implement inlining of the most commonly called virtual methods java methods are virtual by default although they can be sealed by using the codice modifier to disallow overriding there is no way to let derived classes define a new unrelated method with the same name this means that by default in java and only when explicitly enabled in c new methods may be defined in a derived class with the same name and signature as those in its base class when the method is called on a superclass reference of such an object the deepest overridden implementation of the base class method will be called according to the specific subclass of the object being referenced in some cases when a subclass introduces a method with the same name and signature as a method already present in the base class problems can occur in java this will mean that the method in the derived class will implicitly override the method in the base class even though that may not be the intent of the designers of either class to mitigate this c requires that if a method is intended to override an inherited method the codice keyword must be specified otherwise the method will hide the inherited method if the keyword is absent compiler warning to this effect is issued which can be silenced by specifying the codice keyword this avoids the problem that can arise from a base class being extended with a nonprivate method ie an inherited part of the namespace whose signature is already in use by a derived class java has a similar compiler check in the form of the codice method annotation but it is not compulsory and in its absence most compilers will not provide comment but the method will be overridden constantimmutable parameters in java it is possible to prevent reassignment of a local variable or method parameter by using the keyword applying this keyword to a primitive type variable causes the variable to become immutable however applying to a reference type variable only prevents that another object is assigned to it it will not prevent the data contained by the object from being mutated there is no c equivalent both languages do not support essential feature of constcorrectness that exists in cc which makes a method constant interestingly java defines the word constant arbitrarily as a field only these variables are capitalonly variables where the names are separated with an underscore a parameter that is only is not considered as a constant although it may be so in the case of a primitive data type or an immutable class like a  generator methods any c method declared as returning codice codice or the generic versions of these interfaces can be implemented using codice syntax this is a form of limited compilergenerated continuations and can drastically reduce the code needed to traverse or generate sequences although that code is just generated by the compiler instead the feature can also be used to implement infinite sequences eg the sequence of fibonacci numbers java does not have an equivalent feature instead generators are typically defined by providing a specialized implementation of a wellknown collection or iterable interface which will compute each element on demand for such a generator to be used in a for each statement it must implement interface codice see also example fibonacci sequence below explicit interface implementation c also has explicit interface implementation that allows a class to specifically implement methods of an interface separate to its own class methods or to provide different implementations for two methods with the same name and signature inherited from two base interfaces in either language if a method or property in c is specified with the same name and signature in multiple interfaces the members will clash when a class is designed that implements those interfaces an implementation will by default implement a common method for all of the interfaces if separate implementations are needed because the methods serve separate purposes or because return values differ between the interfaces cs explicit interface implementation will solve the problem though allowing different results for the same method depending on the current cast of the object in java there is no way to solve this problem other than refactoring one or more of the interfaces to avoid name clashes reference inout parameters the arguments of primitive types eg int double to a method are passed by value in java the objects are passed by reference this means that a method operates on copies of the primitives passed to it instead of on the actual variables on the contrary the actual objects in some cases can be changed in the following example object string is not changed object of class a is changed in c it is possible to enforce a reference with the codice keyword similar to c and in a sense to c this feature of c is particularly useful when one wants to create a method that returns more than one object in java trying to return multiple values from a method is unsupported exceptions checked exceptions java supports checked exceptions along with unchecked exceptions c only supports unchecked exceptions checked exceptions force the programmer to either declare the exception thrown in a method or to catch the thrown exception using a codice clause checked exceptions can encourage good programming practice ensuring that all errors are dealt with however anders hejlsberg chief c language architect argues that they were to some extent an experiment in java and that they have not been shown to be worthwhile except in small example programs one criticism is that checked exceptions encourage programmers to use an empty catch block codice which silently swallows exceptions rather than letting the exceptions propagate to a higherlevel exceptionhandling routine in some cases however exception chaining can be applied instead by rethrowing the exception in a wrapper exception for example if an object is changed to access a database instead of a file an could be caught and rethrown as an  since the caller may not need to know the inner workings of the object however not all programmers agree with this stance james gosling and others maintain that checked exceptions are useful and misusing them has caused the problems silently catching exceptions is possible yes but it must be stated explicitly what to do with the exception versus unchecked exceptions that allow doing nothing by default it can be ignored but code must be written explicitly to ignore it trycatchfinally there are also differences between the two languages in treating the codice statement the codice block is always executed even if the codice block contains controlpassing statements like codice or codice in java this may result in unexpected behavior if the codice block is left by a codice statement with some value and then the codice block that is executed afterward is also left by a codice statement with a different value c resolves this problem by prohibiting any controlpassing statements like codice or codice in the codice block a common reason for using codice blocks is to guard resource managing code thus guaranteeing the release of precious resources in the finally block c features the codice statement as a syntactic shorthand for this common scenario in which the codice method of the object of the codice is always called a rather subtle difference is the moment a stack trace is created when an exception is being thrown in java the stack trace is created in the moment the exception is created the exception in the statement above will always contain the constructors stacktrace  no matter how often foo is called in c on the other hand the stacktrace is created the moment throw is executed in the code above the exception will contain the stacktrace of the first throwline when catching an exception there are two options in case the exception should be rethrown codice will just rethrow the original exception with the original stack while codice would have created a new stack trace finally blocks java allows flow of control to leave the codice block of a codice statement regardless of the way it was entered this can cause another control flow statement such as codice to be terminated midexecution for example in the above code the codice statement within codice block causes control to leave it and thus codice block is executed before the actual return happens however codice block itself performs a return also thus the original return that caused it to be entered is not executed and the above method returns  rather than  c does not allow any statements that allow control flow to leave the codice block prematurely except for codice in particular codice is not allowed at all codice is not allowed if the target label is outside the codice block and codice and codice are not allowed if the nearest enclosing loop is outside the codice block generics in the field of generics the two languages show a superficial syntactical similarity but they have deep underlying differences type erasure versus reified generics generics in java are a languageonly construction they are implemented only in the compiler the generated classfiles include generic signatures only in form of metadata allowing the compiler to compile new classes against them the runtime has no knowledge of the generic type system generics are not part of the jvm instead generics classes and methods are transformed during compiling via a process termed type erasure during this the compiler replaces all generic types with their raw version and inserts castschecks appropriately in client code where the type and its methods are used the resulting byte code will contain no references to any generic types or parameters see also generics in java the language specification intentionally prohibits certain uses of generics this is necessary to allow for implementing generics through type erasure and to allow for migration compatibility c builds on support for generics from the virtual execution system ie it is not just a language feature the language is merely a frontend for crosslanguage generics support in the clr during compiling generics are verified for correctness but code generation to implement the generics are deferred to classload time client code code invoking generic methodsproperties are fully compiled and can safely assume generics to be typesafe this is called reification at runtime when a unique set of type parameters for a generic classmethoddelegate is encountered for the first time the class loaderverifier will synthesize a concrete class descriptor and generate method implementations during the generation of method implementations all reference types will be considered one type as reference types can safely share the same implementations this is merely for the purpose of implementing code different sets of reference types will still have unique type descriptors their method tables will merely point to the same code the following list illustrates some differences between java and c when managing generics it is not exhaustive c allows generics directly for primitive types java instead allows the use of boxed types as type parameters eg codice instead of codice this comes at a cost since all such values need to be boxedunboxed when used and they all need to be heapallocated however a generic type can be specialized with an array type of a primitive type in java for example codice is allowed migration compatibility javas type erasure design was motivated by a design requirement to achieve migration compatibility  not to be confused with backward compatibility in particular the original requirement was  there should be a clean demonstrable migration path for the collections apis that were introduced in the java  platform this was designed so that any new generic collections should be passable to methods that expected one of the preexisting collection classes c generics were introduced into the language while preserving full backward compatibility but did not preserve full migration compatibility old code pre c  runs unchanged on the new genericsaware runtime without recompilation as for migration compatibility new generic collection classes and interfaces were developed that supplemented the nongeneric net x collections rather than replacing them in addition to generic collection interfaces the new generic collection classes implement the nongeneric collection interfaces where possible this prevents the use of new generic collections with preexisting nongeneric aware methods if those methods are coded to use the collection classes covariance and contravariance covariance and contravariance is supported by both languages java has usesite variance that allows a single generic class to declare members using both co and contravariance c has definesite variance for generic interfaces and delegates variance is unsupported directly on classes but is supported through their implementation of variant interfaces c also has usesite covariance support for methods and delegates functional programming closures a closure is an inline function that captures variables from its lexical scope c supports closures as anonymous methods or lambda expressions with fullfeatured closure semantics in java anonymous inner classes will remain the preferred way to emulate closures until java  has become the new standard this is a more verbose construction this approach also has some differences compared to real closures notably more controlled access to variables from the enclosing scopes only final members can be referenced java  however introduces lambdas that fully inherit the current scope and in fact do not introduce a new scope when a reference to a method can be passed around for later execution a problem arises about what to do when the method has references to variablesparameters in its lexical scope c closures can access any variableparameter from its lexical scope in javas anonymous inner classes only references to final members of the lexical scope are allowed thus requiring the developer to mark which variables to make available and in what state possibly requiring boxing lambdas and expression trees c and java feature a special type of inline closures called lambdas these are anonymous methods they have a signature and a body but no name they are mainly used to specify local functionvalued arguments in calls to other methods a technique mainly associated with functional programming c unlike java allows the use of lambda functions as a way to define special data structures called expression trees whether they are seen as an executable function or as a data structure depends on compiler type inference and what type of variable or parameter they are assigned or cast to lambdas and expression trees play key roles in language integrated query linq preprocessing compilation and packaging namespaces and file contents in c namespaces are similar to those in c unlike package names in java a namespace is not in any way tied to the location of the source file while it is not strictly necessary for a java source file location to mirror its package directory structure it is the conventional organization both languages allow importing of classes eg codice in java allowing a class to be referenced using only its name sometimes classes with the same name exist in multiple namespaces or packages such classes can be referenced by using fully qualified names or by importing only selected classes with different names to do this java allows importing a single class eg codice c allows importing classes under a new local name using the following syntax codice it also allows importing specializations of classes in the form of codice java has a static import syntax that allows using the short name of some or all of the static methodsfields in a class eg allowing codice where codice can be statically imported from another class c has a static class syntax not to be confused with static inner classes in java which restricts a class to only contain static methods c  introduces extension methods to allow users to statically add a method to a type eg allowing codice where codice can be an imported extension method working on the type of codice the sun microsystems java compiler requires that a source file name must match the only public class inside it while c allows multiple public classes in the same file and puts no restrictions on the file name c  and later allows splitting a class definition into several files by using the codice keyword in the source code in java a public class will always be in its own source file in c source code files and logical units separation are not tightly related conditional compilation unlike java c implements conditional compilation using preprocessor directives it also provides a codice attribute to define methods that are only called when a given compilation constant is defined this way assertions can be provided as a framework feature with the method codice which is only evaluated when the codice constant is defined since version  java provides a language feature for assertions which are turned off at runtime by default but can be enabled using the codice or codice switch when invoking the jvm threading and asynchronous features both languages include thread synchronization mechanisms as part of their language syntax taskbased parallelism for c with net framework  a new taskbased programming model was introduced to replace the existing eventbased asynchronous model the api is based around the codice and codice classes tasks can be composed and chained by convention every method that returns a codice should have its name postfixed with async in c  a set of language and compiler extensions was introduced to make it easier to work with the task model these language extensions included the notion of codice methods and the codice statement that make the program flow appear synchronous from this syntactic sugar the c compiler generates a statemachine that handles the necessary continuations without developers having to think about it taskbased parallelism for java java supports threads since jdk  java offers a high versatility for running threads often called tasks this is done by implementing a functional interface a codice interface defining a single void noargs method as demonstrated in the following example also its possible extending codice as below similar to c java has since version  a higher level replacement for working with threads directly codice are capable of running asynchronous tasks and typically manage a pool of threads all threads of the internal pool will be reused under the hood for revenant tasks so we can run as many concurrent tasks as we want throughout the lifecycle of our application with a single executor service this is how the first threadexample looks like using executors in addition to codice codice supports a codice interface another functional interface like codice but returns a value calling the method codice blocks the current thread and waits until the callable completes before returning the value in the example a web page content a better practice could be ask to the users waiting while the task is completed additional features numeric applications to adequately support applications in the field of mathematical and financial computation several language features exist javas strictfp keyword enables strict floatingpoint calculations for a region of code strict floatingpoint calculations require that even if a platform offers higher precision during calculations intermediate results must be converted to singledouble this ensures that strict floating point calculations return exactly the same result on all platforms without strict floating point a platform implementation is free to use higher precision for intermediate results during calculation c allows an implementation for a given hardware architecture to always use a higher precision for intermediate results if available ie c does not allow the programmer to optionally force intermediate results to use the potential lower precision of floatdouble although javas floating point arithmetic is largely based on ieee  standard for binary floatingpoint arithmetic certain features are unsupported even when using the strictfp modifier such as exception flags and directed roundings abilities mandated by ieee standard  see criticism of java floating point arithmetic c provides a builtin decimal type which has higher precision but less range than the javac double the decimal type is a bit data type suitable for financial and monetary calculations the decimal type can represent values ranging from    to approximately    with  significant digits the structure uses c operator overloading so that decimals can be manipulated using operators such as    and  like other primitive data types the and types provided with java allow arbitraryprecision representation of decimal numbers and integer numbers respectively java standard library does not have classes to deal with complex numbers the biginteger and complex types provided with c allow representation and manipulation of arbitraryprecision integers and complex numbers respectively the structures use c operator overloading so that instances can be manipulated using operators such as    and  like other primitive data types c standard library does not have classes to deal with arbitraryprecision floating point numbers see software for arbitraryprecision arithmetic c can help mathematical applications with the codice and codice operators that allow the enabling or disabling of runtime checking for arithmetic overflow for a region of code language integrated query linq cs language integrated query linq is a set of features designed to work together to allow inlanguage querying abilities and is a distinguishing feature between c and java linq consists of the following features native interoperability the java native interface jni feature allows java programs to call nonjava code however jni does require the code being called to follow several conventions and imposes restrictions on types and names used this means that an extra adaption layer between legacy code and java is often needed this adaption code must be coded in a nonjava language often c or c java native access jna allows easier calling of native code that only requires writing java code but comes at a performance cost in addition third party libraries provide javacomponent object model com bridging eg jacob free and jintegra for com proprietary net platform invoke pinvoke offers the same ability by allowing calls from c to what microsoft terms unmanaged code through metadata attributes the programmer can control exactly how the parameters and results are marshalled thus avoiding the external glue code needed by the equivalent jni in java pinvoke allows almost complete access to procedural apis such as win or posix but limited access to c class libraries in addition net framework also provides a netcom bridge allowing access to com components as if they were firstclass net objects c also allows the programmer to disable the normal typechecking and other safety features of the clr which then enables the use of pointer variables when using this feature the programmer must mark the code using the codice keyword jni pinvoke and unsafe code are equally risky features exposing possible security holes and application instability an advantage of unsafe managed code over pinvoke or jni is that it allows the programmer to continue to work in the familiar c environment to accomplish some tasks that otherwise would require calling out to unmanaged code an assembly program or library using unsafe code must be compiled with a special switch and will be marked as such this enables runtime environments to take special precautions before executing potentially harmful code runtime environments java the programming language is designed to execute on the java platform via the java runtime environment jre the java platform includes the java virtual machine jvm and a common set of libraries the jre was originally designed to support interpreted execution with final compiling as an option most jre environments execute fully or at least partially compiled programs possibly with adaptive optimization the java compiler produces java bytecode upon execution the bytecode is loaded by the java runtime and either interpreted directly or compiled to machine instructions and then executed c is designed to execute on the common language runtime clr the clr is designed to execute fully compiled code the c compiler produces common intermediate language instructions upon execution the runtime loads this code and compiles to machine instructions on the target architecture examples inputoutput example illustrating how to copy text one line at a time from one file to another using both languages integration of library defined types c allows library defined types to be integrated with existing types and operators by using custom implicitexplicit conversions and operator overloading as illustrated by the following example interoperability with dynamic languages this example illustrates how java and c can be used to create and invoke an instance of class which is implemented in another programming language the deepthought class is implemented using the ruby programming language and represents a simple calculator which will multiply two input values a and b when the calculate method is invoked fibonacci sequence this example illustrates how the fibonacci sequence can be implemented using the two languages the c version takes advantage of c generator methods the java version takes the advantage of the java  using the stream interface and method references both the java and the c examples use kr style for code formatting of classes methods and statements