enterprise javabeans enterprise javabeans ejb is a managed server software for modular construction of enterprise software and one of several java apis ejb is a serverside software component that encapsulates the business logic of an application the ejb specification is a subset of the java ee specification an ejb web container provides a runtime environment for web related software components including computer security java servlet lifecycle management transaction processing and other web services specification the ejb specification was originally developed in  by ibm and later adopted by sun microsystems ejb  and  in  and enhanced under the java community process as jsr  ejb  jsr  ejb  jsr  ejb  jsr  ejb  and jsr  ejb  the ejb specification intends to provide a standard way to implement the serverside also called backend business software typically found in enterprise applications as opposed to frontend user interface software such machine code addresses the same types of problems and solutions to these problems are often repeatedly reimplemented by programmers enterprise javabeans is intended to handle such common concerns as persistence transactional integrity and security in a standard way leaving programmers free to concentrate on the particular parts of the enterprise software at hand general responsibilities the ejb specification details how an application server provides the following responsibilities additionally the enterprise javabean specification defines the roles played by the ejb container and the ejbs as well as how to deploy the ejbs in a container note that the current ejb  specification does not detail how an application server provides persistence a task delegated to the jpa specification but instead details how business logic can easily integrate with the persistence services offered by the application server rapid adoption followed by criticism the vision was persuasively presented by ejb advocates such as ibm and sun microsystems and enterprise javabeans were quickly adopted by large companies problems were quick to appear with initial versions some developers felt that the apis of the ejb standard were far more complex than those developers were used to an abundance of checked exceptions required interfaces and the implementation of the bean class as an abstract class were unusual and counterintuitive for programmers the problems that the ejb standard was attempting to address such as objectrelational mapping and transactional integrity were complex however many programmers found the apis to be just as difficult leading to a perception that ejbs introduced complexity without delivering real benefits in addition businesses found that using ejbs to encapsulate business logic brought a performance penalty this is because the original specification only allowed for remote method invocation through corba and optionally other protocols even though the large majority of business applications actually do not require this distributed computing functionality the ejb  specification addressed this concern by adding the concept of local interfaces which could be called directly without performance penalties by applications that were not distributed over multiple servers the complexity issue continued to hinder ejbs acceptance although developer tools made it easy to create and use ejbs by automating most of the repetitive tasks these tools did not make it any easier to learn how to use the technology moreover a countermovement had grown up on the grassroots level among programmers the main products of this movement were the socalled lightweight ie in comparison to ejb technologies of hibernate for persistence and objectrelational mapping and the spring framework which provided an alternate and far less verbose way to encode business logic despite lacking the support of big businesses these technologies grew in popularity and were adopted by businesses reinventing ejbs gradually an industry consensus emerged that the original ejb specifications primary virtue  enabling transactional integrity over distributed applications  was of limited use to most enterprise applications and the functionality delivered by simpler frameworks like spring and hibernate was more useful accordingly the ejb  specification jsr  was a radical departure from its predecessors following this new paradigm it shows a clear influence from spring in its use of plain java objects and its support for dependency injection to simplify configuration and integration of heterogeneous systems gavin king the creator of hibernate participated in the ejb  process and is an outspoken advocate of the technology many features originally in hibernate were incorporated in the java persistence api the replacement for entity beans in ejb  the ejb  specification relies heavily on the use of annotations a feature added to the java language with its  release and convention over configuration to enable a much less verbose coding style accordingly in practical terms ejb  is much more lightweight and nearly a completely new api bearing little resemblance to the previous ejb specifications example the following shows a basic example of what an ejb looks like in code the above defines a service class for persisting a customer object via or mapping the ejb takes care of managing the persistence context and the addcustomer method is transactional and threadsafe by default as demonstrated the ejb focuses only on business logic and persistence and knows nothing about any particular presentation such an ejb can be used by a class in eg the web layer as follows the above defines a javaserver faces jsf backing bean in which the ejb is injected by means of the ejb annotation its addcustomer method is typically bound to some ui component like a button contrary to the ejb the backing bean does not contain any business logic or persistence code but delegates such concerns to the ejb the backing bean does know about a particular presentation of which the ejb had no knowledge types of enterprise beans an ejb container holds two major types of beans session beans stateful session beans stateful session beans are business objects having state that is they keep track of which calling client they are dealing with throughout a session and thus access to the bean instance is strictly limited to only one client at a time if concurrent access to a single bean is attempted anyway the container serializes those requests but via the accesstimeout annotation the container can instead throw an exception stateful session beans state may be persisted passivated automatically by the container to free up memory after the client hasnt accessed the bean for some time the jpa extended persistence context is explicitly supported by stateful session beans stateless session beans stateless session beans are business objects that do not have state associated with them however access to a single bean instance is still limited to only one client at a time concurrent access to the bean is prohibited if concurrent access to a single bean is attempted the container simply routes each request to a different instance this makes a stateless session bean automatically threadsafe instance variables can be used during a single method call from a client to the bean but the contents of those instance variables are not guaranteed to be preserved across different client method calls instances of stateless session beans are typically pooled if a second client accesses a specific bean right after a method call on it made by a first client has finished it might get the same instance the lack of overhead to maintain a conversation with the calling client makes them less resourceintensive than stateful beans singleton session beans singleton session beans are business objects having a global shared state within a jvm concurrent access to the one and only bean instance can be controlled by the container containermanaged concurrency cmc or by the bean itself beanmanaged concurrency bmc cmc can be tuned using the lock annotation that designates whether a read lock or a write lock will be used for a method call additionally singleton session beans can explicitly request to be instantiated when the ejb container starts up using the startup annotation message driven beans message driven beans are business objects whose execution is triggered by messages instead of by method calls the message driven bean is used among others to provide a high level easeofuse abstraction for the lower level jms java message service specification it may subscribe to jms message queues or message topics which typically happens via the activationconfig attribute of the messagedriven annotation they were added in ejb to allow eventdriven processing unlike session beans an mdb does not have a client view localremotenointerface ie clients cannot lookup an mdb instance an mdb just listens for any incoming message on for example a jms queue or topic and processes them automatically only jms support is required by the java ee spec but message driven beans can support other messaging protocols such protocols may be asynchronous but can also be synchronous since session beans can also be synchronous or asynchronous the prime difference between session and message driven beans is not the synchronicity but the difference between object oriented method calling and messaging execution ejbs are deployed in an ejb container typically within an application server the specification describes how an ejb interacts with its container and how client code interacts with the containerejb combination the ejb classes used by applications are included in the package the package is a service provider interface used only by ejb container implementations clients of ejbs do not instantiate those beans directly via javas new operator but instead have to obtain a reference via the ejb container this reference is usually not a reference to the implementation bean itself but to a proxy which either dynamically implements the local or remote business interface that the client requested or dynamically implements a subtype of the actual bean the proxy can then be directly cast to the interface or bean a client is said to have a view on the ejb and the local interface remote interface and bean type itself respectively correspond with the local view remote view and nointerface view this proxy is needed in order to give the ejb container the opportunity to transparently provide crosscutting aoplike services to a bean like transactions security interceptions injections remoting etc eg a client invokes a method on a proxy which will then first start a transaction with the help of the ejb container and then call the actual bean method when the actual bean method returns the proxy ends the transaction ie by committing it or doing a rollback and transfers control back to the client transactions ejb containers must support both container managed acid transactions and bean managed transactions containermanaged transactions cmt are by default active for calls to session beans that is no explicit configuration is needed this behavior may be declaratively tuned by the bean via annotations and if needed such configuration can later be overridden in the deployment descriptor tuning includes switching off transactions for the whole bean or specific methods or requesting alternative strategies for transaction propagation and starting or joining a transaction such strategies mainly deal with what should happen if a transaction is or isnt already in progress at the time the bean is called the following variations are supported alternatively the bean can also declare via an annotation that it wants to handle transactions programmatically via the jta api this mode of operation is called bean managed transactions bmt since the bean itself handles the transaction instead of the container events jms java message service is used to send messages from beans to clients to let clients receive asynchronous messages from these beans mdbs can be used to receive messages from clients asynchronously using either a jms queue or a topic naming and directory services as an alternative to injection clients of an ejb can obtain a reference to the session beans proxy object the ejb stub using java naming and directory interface jndi this alternative can be used in cases where injection is not available such as in nonmanaged code or standalone remote java se clients or when its necessary to programmatically determine which bean to obtain jndi names for ejb session beans are assigned by the ejb container via the following scheme entries in square brackets denote optional parts a single bean can be obtained by any name matching the above patterns depending on the location of the client clients in the same module as the required bean can use the module scope and larger scopes clients in the same application as the required bean can use the app scope and higher etc eg code running in the same module as the customerservice bean as given by the example shown earlier in this article could use the following code to obtain a local reference to it remotingdistributed execution ejb session beans have elaborate support for remoting for communication with a client thats also written in the java programming language a session bean can expose a remoteview via an remote annotated interface this allows those beans to be called from clients in other jvms which themselves may be located on other remote systems from the point of view of the ejb container any code in another jvm is remote stateless and singleton session beans may also expose a web service client view for remote communication via wsdl and soap or plain xml this follows the jaxrpc and jaxws specifications jaxrpc support however is proposed for future removal to support jaxws the session bean is annotated with the webservice annotation and methods that are to be exposed remotely with the webmethod annotation although the ejb specification does not mention exposure as restful web services in any way and has no explicit support for this form of communication the jaxrs specification does explicitly support ejb following the jaxrs spec stateless and singleton session beans can be root resources via the path annotation and ejb business methods can be mapped to resource methods via the get put post and delete annotations this however does not count as a web service client view which is used exclusively for jaxws and jaxrpc communication via web services is typical for clients not written in the java programming language but is also convenient for java clients who have trouble reaching the ejb server via a firewall additionally web service based communication can be used by java clients to circumvent the arcane and illdefined requirements for the socalled clientlibraries a set of jar files that a java client must have on its classpath in order to communicate with the remote ejb server these clientlibraries potentially conflict with libraries the client may already have for instance if the client itself is also a full java ee server and such a conflict is deemed to be a very hard or impossible to resolve message driven beans have no specific support for remoting but being listeners to endpoints eg jms queues they are implicitly remote components by virtue of the properties of whatever type of endpoint they are listening to security the ejb container is responsible for ensuring the client code has sufficient access rights to an ejb security aspects can be declaratively applied to an ejb via annotations legacy home interfaces and required business interface with ejb  and earlier each ejb had to provide a java implementation class and two java interfaces the ejb container created instances of the java implementation class to provide the ejb implementation the java interfaces were used by client code of the ejb the two interfaces referred to as the home and the remote interface specified the signatures of the ejbs remote methods the methods were split into two groups required deployment descriptor with ejb  and earlier the ejb specification required a deployment descriptor to be present this was needed to implement a mechanism that allowed ejbs to be deployed in a consistent manner regardless of the specific ejb platform that was chosen information about how the bean should be deployed such as the name of the home or remote interfaces whether and how to store the bean in a database etc had to be specified in the deployment descriptor the deployment descriptor is an xml document having an entry for each ejb to be deployed this xml document specifies the following information for each ejb old ejb containers from many vendors required more deployment information than that in the ejb specification they would require the additional information as separate xml files or some other configuration file format an ejb platform vendor generally provided their own tools that would read this deployment descriptor and possibly generated a set of classes that would implement the now deprecated home and remote interfaces since ejb  jsr  the xml descriptor is replaced by java annotations set in the enterprise bean implementation at source level although it is still possible to use an xml descriptor instead of or in addition to the annotations if an xml descriptor and annotations are both applied to the same attribute within an enterprise bean the xml definition overrides the corresponding sourcelevel annotation although some xml elements can also be additive eg an activationconfigproperty in xml with a different name than already defined via an activationconfigproperty annotation will be added instead of replacing all existing properties container variations starting with ejb  the ejb specification defines two variants of the ejb container a full version and a limited version the limited version adheres to a proper subset of the specification called ejb  lite and is part of java ee s web profile which is itself a subset of the full java ee  specification ejb  lite excludes support for the following features ejb  lite excludes less features particularly it no longer excludes asynchronous and scheduletimeout but for schedule it does not support the persistent attribute that full ejb  does support the complete excluded list for ejb  lite is version history ejb  final release  jsr  enterprise javabeans  was a relatively minor release that mainly contained specification clarifications and lifted some restrictions that were imposed by the spec but over time appeared to serve no real purpose a few existing full ejb features were also demanded to be in ejb  lite and functionality that was proposed to be pruned in ejb  was indeed pruned made optional the following features were added ejb  final release  jsr  the purpose of the enterprise javabeans  specification is to further simplify the ejb architecture by reducing its complexity from the developers point of view while also adding new functionality in response to the needs of the community ejb  final release  jsr   major changes this release made it much easier to write ejbs using annotations rather than the complex deployment descriptors used in version x the use of home and remote interfaces and the ejbjarxml file were also no longer required in this release having been replaced with a business interface and a bean that implements the interface ejb  final release  jsr   major changes ejb  final release  jsr   major changes overall goals ejb  final release  major changes goals for release  ejb   announced at javaone  suns third java developers conference march  through  goals for release 