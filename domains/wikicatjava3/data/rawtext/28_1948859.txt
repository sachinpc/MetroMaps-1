jruby jruby is an implementation of the ruby programming language atop the java virtual machine written largely in java it is free software released under a threeway eplgpllgpl license jruby is tightly integrated with java to allow the embedding of the interpreter into any java application with full twoway access between the java and the ruby code similar to jython for the python language jrubys lead developers are charles oliver nutter and thomas enebo with many current and past contributors including ola bini and nick sieger in september  sun microsystems hired enebo and nutter to work on jruby fulltime in june  thoughtworks hired ola bini to work on ruby and jruby in july  the jruby developers left sun to continue jruby development at engine yard in may  nutter and enebo left engine yard to work on jruby at red hat history jruby was originally created by jan arne petersen in  at that time and for several years following the code was a direct port of the ruby  c code with the release of ruby  an effort began to update jruby to  features and semantics since  several contributors have assisted the project leading to the current  core team of around six members jruby  added justintime compilation and aheadoftime compilation modes to jruby and was already faster in most cases than the thencurrent ruby  reference implementation jruby packages are available for most platforms fedora  was among the first to include it as a standard package at jruby  in july  the core jruby developers at sun microsystems charles oliver nutter thomas enebo and nick sieger joined engine yard to continue jruby development in may  nutter and enebo left engine yard to work on jruby at red hat jruby has supported compatibility with ruby mri versions  through  jruby  supported ruby  with jruby  updating that compatibility to ruby  jruby  added simultaneous support for ruby  with jruby  making ruby  the default execution mode ruby  compatibility is available via a commandline flag jruby  added support for ruby  ruby on rails jruby has been able to run the ruby on rails web framework since version  may  with the ability to execute rubygems and webrick since the hiring of the two lead developers by sun rails compatibility and speed have improved greatly jruby version  successfully passed nearly all of railss own test cases since then developers have begun to use jruby for rails applications in production environments multiple virtual machine collaboration on february   sun microsystems and the university of tokyo announced a jointresearch project to implement a virtual machine capable of executing more than one ruby or jruby application on one interpreter dynamic invocation on java virtual machines jsr  supporting dynamically typed languages on the javatm platform proposes the sun open source project multi language virtual machine aims to prototype this jsr the first working prototype developed as a patch on openjdk was announced and made available on end of august  the jruby team has implemented dynamic invocation into their codebase dynamic invocation initially shipped with the  release in a primitive form version  enabled it by default on java  builds release history this table presents only releases that present significant steps in jruby history aside from versions that mainly fixed bugs and improved performance performance improvements are also not shown in the table below as every release has usually brought such improvements the project gets coordinated here at codehausorg you can find also the official release history resp plan there design since early  the current jruby core team has endeavored to move jruby beyond being a simple c port to support better performance and to aid eventual compilation to java bytecode to support this end the team set an ambitious goal to be able to run ruby on rails unmodified using jruby in the process of achieving this goal the jruby test suite expanded to such extent that the team gained confidence in the correctness of jruby as a result toward the end of  and in the beginning of  they began to commit much more complicated redesigns and refactorings of jrubys core subsystems jruby is designed to work as a mixedmode virtual machine for ruby where code can be either interpreted directly justintime compiled at runtime to java bytecode or aheadoftime compiled to java bytecode before execution until october  only the interpreted mode supported all rubys constructs but a full aotjit compiler is available since version  the compiler design allows for interpreted and compiled code to run sidebyside as well as decompilation to reoptimize and outputting generated bytecode as java class files frameworks support jruby has builtin support for rails rspec rake and rubygems it embeds an ffi subsystem to allow the use of c libraries bundled as gems it also allows launching the interactive ruby shell irb as ruby mri does the netbeans ruby pack available in netbeans  allows ide development with ruby and jruby as well as ruby on rails for the two implementations of ruby it is no longer included in netbeans  and later programming ruby meets java jruby is similar to the standard ruby interpreter except written in java jruby features some of the same concepts including objectoriented programming and dynamictyping as ruby the key difference is that jruby is tightly integrated with java and can be called directly from java programs java has significant footing in the development of web applications jruby calling java one powerful feature of jruby is its ability to invoke the classes of the java platform to do this one must first load jrubys java support by calling require java the following example creates a java  with a  jruby also allows the user to call java code using the more rubylike underscore method naming and to refer to javabean properties as attributes calling jruby from java jruby can just as easily be called from java using either the jsr  scripting for java  or the apache bean scripting framework more information on this is available in the jruby wiki article performance according to some benchmarks jruby is faster than alternatives since implementations vary in how much code is loaded before execution different methods of measuring speed can lead to biased interpretations of performance advantages the time it takes for a java virtual machine itself to load is often excluded from execution times when calculating benchmarks jruby has the significant architectural advantage to be able to leverage jvm threads without being constrained by a global interpreter lock similarly to rubinius therefore achieving full parallelism within a process which ruby mri cannot achieve despite leveraging os threads in a real mongrel web server application tested in  jruby performance is better than ruby mri  after the java virtual machine had been instantiated in a  benchmark of ruby implementations jruby was faster than ruby mri  in some tests but yarv outperformed both of them as of april  in the computer language benchmarks game jruby  typically has the same performance as ruby mri  but uses more memory