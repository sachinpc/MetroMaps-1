common lisp common lisp cl is a dialect of the lisp programming language published in ansi standard document ansi incits  r formerly x r the common lisp hyperspec a hyperlinked html version has been derived from the ansi common lisp standard the common lisp language was developed as a standardized and improved successor of maclisp by the early s several groups were already at work on diverse successors to maclisp lisp machine lisp aka zetalisp spice lisp nil and s lisp common lisp sought to unify standardise and extend the features of these maclisp dialects common lisp is not an implementation but rather a language specification several implementations of the common lisp standard are available including free and open source software and proprietary products common lisp is a generalpurpose multiparadigm programming language it supports a combination of procedural functional and objectoriented programming paradigms as a dynamic programming language it facilitates evolutionary and incremental software development with iterative compilation into efficient runtime programs this incremental development is often done interactively without interrupting the running application it also supports optional type annotation and casting which can be added as necessary at the later profiling and optimization stages to permit the compiler to generate more efficient code for instance codice can hold an unboxed integer in a range supported by the hardware and implementation permitting more efficient arithmetic than on big integers or arbitrary precision types similarly the compiler can be told on a permodule or perfunction basis which type safety level is wanted using optimize declarations common lisp includes clos an object system that supports multimethods and method combinations it is often implemented with a metaobject protocol common lisp is extensible through standard features such as lisp macros code transformations and reader macros input parsers for characters common lisp provides some backwards compatibility to maclisp and to john mccarthys original lisp this allows older lisp software to be ported to common lisp history work on common lisp started in  after an initiative by arpa manager bob engelmore to develop a single community standard lisp dialect much of the initial language design was done via electronic mail guy lewis steele jr gave at the  acm symposium on lisp and functional programming the first overview of common lisp the first language documentation was published  as common lisp the language first edition a second edition published in  incorporated many changes to the language made during the ansi common lisp standardization process the final ansi common lisp standard then was published in  since then no update to the standard has been published various extensions and improvements to common lisp examples are unicode concurrency closbased io have been provided by implementations and libraries many available via quicklisp syntax common lisp is a dialect of lisp it uses sexpressions to denote both code and data structure function calls macro forms and special forms are written as lists with the name of the function first as in these examples data types common lisp has many data types scalar types number types include integers ratios floatingpoint numbers and complex numbers common lisp uses bignums to represent numerical values of arbitrary size and precision the ratio type represents fractions exactly a facility not available in many languages common lisp automatically coerces numeric values among these types as appropriate the common lisp character type is not limited to ascii characters most modern implementations allow unicode characters the symbol type is common to lisp languages but largely unknown outside them a symbol is a unique named data object with several parts name value function property list and package of these value cell and function cell are the most important symbols in lisp are often used similarly to identifiers in other languages to hold the value of a variable however there are many other uses normally when a symbol is evaluated its value is returned some symbols evaluate to themselves for example all symbols in the keyword package are selfevaluating boolean values in common lisp are represented by the selfevaluating symbols t and nil common lisp has namespaces for symbols called packages a number of functions are available for rounding scalar numeric values in various ways the function codice rounds the argument to the nearest integer with halfway cases rounded to the even integer the functions codice codice and codice round towards zero down or up respectively all these functions return the discarded fractional part as a secondary value for example codice yields   codice yields   codice yields   and codice yields   data structures sequence types in common lisp include lists vectors bitvectors and strings there are many operations which can work on any sequence type as in almost all other lisp dialects lists in common lisp are composed of conses sometimes called cons cells or pairs a cons is a data structure with two slots called its car and cdr a list is a linked chain of conses or the empty list each conss car refers to a member of the list possibly another list each conss cdr refers to the next consexcept for the last cons in a list whose cdr refers to the codice value conses can also easily be used to implement trees and other complex data structures though it is usually advised to use structure or class instances instead it is also possible to create circular data structures with conses common lisp supports multidimensional arrays and can dynamically resize adjustable arrays if required multidimensional arrays can be used for matrix mathematics a vector is a onedimensional array arrays can carry any type as members even mixed types in the same array or can be specialized to contain a specific type of members as in a vector of bits usually only a few types are supported many implementations can optimize array functions when the array used is typespecialized two typespecialized array types are standard a string is a vector of characters while a bitvector is a vector of bits hash tables store associations between data objects any object may be used as key or value hash tables are automatically resized as needed packages are collections of symbols used chiefly to separate the parts of a program into namespaces a package may export some symbols marking them as part of a public interface packages can use other packages structures similar in use to c structs and pascal records represent arbitrary complex data structures with any number and type of fields called slots structures allow singleinheritance classes are similar to structures but offer more dynamic features and multipleinheritance see clos classes have been added late to common lisp and there is some conceptual overlap with structures objects created of classes are called instances a special case are generic functions generic functions are both functions and instances functions common lisp supports firstclass functions for instance it is possible to write functions that take other functions as arguments or return functions as well this makes it possible to describe very general operations the common lisp library relies heavily on such higherorder functions for example the codice function takes a relational operator as an argument and key function as an optional keyword argument this can be used not only to sort any type of data but also to sort data structures according to a key the evaluation model for functions is very simple when the evaluator encounters a form codice then it presumes that the symbol named f is one of the following if f is the name of a function then the arguments a a  an are evaluated in lefttoright order and the function is found and invoked with those values supplied as parameters defining functions the macro codice defines functions where a function definition gives the name of the function the names of any arguments and a function body function definitions may include compiler directives known as declarations which provide hints to the compiler about optimization settings or the data types of arguments they may also include documentation strings docstrings which the lisp system may use to provide interactive documentation anonymous functions function literals are defined using codice expressions eg codice for a function that squares its argument lisp programming style frequently uses higherorder functions for which it is useful to provide anonymous functions as arguments local functions can be defined with codice and codice there are a number of other operators related to the definition and manipulation of functions for instance a function may be compiled with the codice operator some lisp systems run functions using an interpreter by default unless instructed to compile others compile every function defining generic functions and methods the macro codice defines generic functions the macro codice defines methods generic functions are a collection of methods methods can specialize their parameters over clos standard classes system classes structure classes or objects for many types there are corresponding system classes when a generic function is called multipledispatch will determine the effective method to use generic functions are also a first class data type there are many more features to generic functions and methods than described above the function namespace the namespace for function names is separate from the namespace for data variables this is a key difference between common lisp and scheme for common lisp operators that define names in the function namespace include codice codice codice codice and codice to pass a function by name as an argument to another function one must use the codice special operator commonly abbreviated as codice the first codice example above refers to the function named by the symbol codice in the function namespace with the code codice conversely to call a function passed in such a way one would use the codice operator on the argument schemes evaluation model is simpler there is only one namespace and all positions in the form are evaluated in any order  not just the arguments code written in one dialect is therefore sometimes confusing to programmers more experienced in the other for instance many common lisp programmers like to use descriptive variable names such as list or string which could cause problems in scheme as they would locally shadow function names whether a separate namespace for functions is an advantage is a source of contention in the lisp community it is usually referred to as the lisp vs lisp debate lisp refers to schemes model and lisp refers to common lisps model these names were coined in a  paper by richard p gabriel and kent pitman which extensively compares the two approaches multiple return values common lisp supports the concept of multiple values where any expression always has a single primary value but it might also have any number of secondary values which might be received and inspected by interested callers this concept is distinct from returning a list value as the secondary values are fully optional and passed via a dedicated side channel this means that callers may remain entirely unaware of the secondary values being there if they have no need for them and it makes it convenient to use the mechanism for communicating information that is sometimes useful but not always necessary for example let x  defun getanswer library defun theanswer library multiple values are supported by a handful of standard forms most common of which are the codice special form for accessing secondary values and codice for returning multiple values other types other data types in common lisp include scope like programs in many other programming languages common lisp programs make use of names to refer to variables functions and many other kinds of entities named references are subject to scope the association between a name and the entity which the name refers to is called a binding scope refers to the set of circumstances in which a name is determined to have a particular binding determiners of scope the circumstances which determine scope in common lisp include to understand what a symbol refers to the common lisp programmer must know what kind of reference is being expressed what kind of scope it uses if it is a variable reference dynamic versus lexical scope and also the runtime situation in what environment is the reference resolved where was the binding introduced into the environment et cetera kinds of environment global some environments in lisp are globally pervasive for instance if a new type is defined it is known everywhere thereafter references to that type look it up in this global environment dynamic one type of environment in common lisp is the dynamic environment bindings established in this environment have dynamic extent which means that a binding is established at the start of the execution of some construct such as a codice block and disappears when that construct finishes executing its lifetime is tied to the dynamic activation and deactivation of a block however a dynamic binding is not just visible within that block it is also visible to all functions invoked from that block this type of visibility is known as indefinite scope bindings which exhibit dynamic extent lifetime tied to the activation and deactivation of a block and indefinite scope visible to all functions which are called from that block are said to have dynamic scope common lisp has support for dynamically scoped variables which are also called special variables certain other kinds of bindings are necessarily dynamically scoped also such as restarts and catch tags function bindings cannot be dynamically scoped using codice which only provides lexically scoped function bindings but function objects a firstlevel object in common lisp can be assigned to dynamically scoped variables bound using codice in dynamic scope then called using codice or codice dynamic scope is extremely useful because it adds referential clarity and discipline to global variables global variables are frowned upon in computer science as potential sources of error because they can give rise to adhoc covert channels of communication among modules that lead to unwanted surprising interactions in common lisp a special variable which has only a toplevel binding behaves just like a global variable in other programming languages a new value can be stored into it and that value simply replaces what is in the toplevel binding careless replacement of the value of a global variable is at the heart of bugs caused by use of global variables however another way to work with a special variable is to give it a new local binding within an expression this is sometimes referred to as rebinding the variable binding a dynamically scoped variable temporarily creates a new memory location for that variable and associates the name with that location while that binding is in effect all references to that variable refer to the new binding the previous binding is hidden when execution of the binding expression terminates the temporary memory location is gone and the old binding is revealed with the original value intact of course multiple dynamic bindings for the same variable can be nested in common lisp implementations which support multithreading dynamic scopes are specific to each thread of execution thus special variables serve as an abstraction for thread local storage if one thread rebinds a special variable this rebinding has no effect on that variable in other threads the value stored in a binding can only be retrieved by the thread which created that binding if each thread binds some special variable codice then codice behaves like threadlocal storage among threads which do not rebind codice it behaves like an ordinary global all of these threads refer to the same toplevel binding of codice dynamic variables can be used to extend the execution context with additional context information which is implicitly passed from function to function without having to appear as an extra function parameter this is especially useful when the control transfer has to pass through layers of unrelated code which simply cannot be extended with extra parameters to pass the additional data a situation like this usually calls for a global variable that global variable must be saved and restored so that the scheme doesnt break under recursion dynamic variable rebinding takes care of this and that variable must be made threadlocal or else a big mutex must be used so the scheme doesnt break under threads dynamic scope implementations can take care of this also in the common lisp library there are many standard special variables for instance all standard io streams are stored in the toplevel bindings of wellknown special variables the standard output stream is stored in standardoutput suppose a function foo writes to standard output to capture its output in a character string standardoutput can be bound to a string stream and called lexical common lisp supports lexical environments formally the bindings in a lexical environment have lexical scope and may have either indefinite extent or dynamic extent depending on the type of namespace lexical scope means that visibility is physically restricted to the block in which the binding is established references which are not textually ie lexically embedded in that block simply do not see that binding the tags in a tagbody have lexical scope the expression go x is erroneous if it is not actually embedded in a tagbody which contains a label x however the label bindings disappear when the tagbody terminates its execution because they have dynamic extent if that block of code is reentered by the invocation of a lexical closure it is invalid for the body of that closure to try to transfer control to a tag via go when the tagbody is executed it first evaluates the setf form which stores a function in the special variable stashed then the go endlabel transfers control to endlabel skipping the code print hello since endlabel is at the end of the tagbody the tagbody terminates yielding nil suppose that the previously remembered function is now called this situation is erroneous one implementations response is an error condition containing the message go tagbody for tag somelabel has already been left the function tried to evaluate go somelabel which is lexically embedded in the tagbody and resolves to the label however the tagbody isnt executing its extent has ended and so the control transfer cannot take place local function bindings in lisp have lexical scope and variable bindings also have lexical scope by default by contrast with go labels both of these have indefinite extent when a lexical function or variable binding is established that binding continues to exist for as long as references to it are possible even after the construct which established that binding has terminated references to lexical variables and functions after the termination of their establishing construct are possible thanks to lexical closures lexical binding is the default binding mode for common lisp variables for an individual symbol it can be switched to dynamic scope either by a local declaration by a global declaration the latter may occur implicitly through the use of a construct like defvar or defparameter it is an important convention in common lisp programming that special ie dynamically scoped variables have names which begin and end with an asterisk sigil codice in what is called the earmuff convention if adhered to this convention effectively creates a separate namespace for special variables so that variables intended to be lexical are not accidentally made special lexical scope is useful for several reasons firstly references to variables and functions can be compiled to efficient machine code because the runtime environment structure is relatively simple in many cases it can be optimized to stack storage so opening and closing lexical scopes has minimal overhead even in cases where full closures must be generated access to the closures environment is still efficient typically each variable becomes an offset into a vector of bindings and so a variable reference becomes a simple load or store instruction with a baseplusoffset addressing mode secondly lexical scope combined with indefinite extent gives rise to the lexical closure which in turn creates a whole paradigm of programming centered around the use of functions being firstclass objects which is at the root of functional programming thirdly perhaps most importantly even if lexical closures are not exploited the use of lexical scope isolates program modules from unwanted interactions due to their restricted visibility lexical variables are private if one module a binds a lexical variable x and calls another module b references to x in b will not accidentally resolve to the x bound in a b simply has no access to x for situations in which disciplined interactions through a variable are desirable common lisp provides special variables special variables allow for a module a to set up a binding for a variable x which is visible to another module b called from a being able to do this is an advantage and being able to prevent it from happening is also an advantage consequently common lisp supports both lexical and dynamic scope macros a macro in lisp superficially resembles a function in usage however rather than representing an expression which is evaluated it represents a transformation of the program source code the macro gets the source it surrounds as arguments binds them to its parameters and computes a new source form this new form can also use a macro the macro expansion is repeated until the new source form does not use a macro the final computed form is the source code executed at runtime typical uses of macros in lisp various standard common lisp features also need to be implemented as macros such as macros are defined by the defmacro macro the special operator macrolet allows the definition of local lexically scoped macros it is also possible to define macros for symbols using definesymbolmacro and symbolmacrolet paul grahams book on lisp describes the use of macros in common lisp in detail doug hoytes book let over lambda extends the discussion on macros claiming macros are the single greatest advantage that lisp has as a programming language and the single greatest advantage of any programming language hoyte provides several examples of iterative development of macros example using a macro to define a new control structure macros allow lisp programmers to create new syntactic forms in the language one typical use is to create new control structures the example macro provides an codice looping construct the syntax is the macro definition for until tagbody is a primitive common lisp special operator which provides the ability to name tags and use the go form to jump to those tags the backquote  provides a notation that provides code templates where the value of forms preceded with a comma are filled in forms preceded with comma and atsign are spliced in the tagbody form tests the end condition if the condition is true it jumps to the end tag otherwise the provided body code is executed and then it jumps to the start tag an example form using above until macro the code can be expanded using the function macroexpand the expansion for above example looks like this during macro expansion the value of the variable test is  random   and the value of the variable body is writeline hello the body is a list of forms symbols are usually automatically upcased the expansion uses the tagbody with two labels the symbols for these labels are computed by gensym and are not interned in any package two go forms use these tags to jump to since tagbody is a primitive operator in common lisp and not a macro it will not be expanded into something else the expanded form uses the when macro which also will be expanded fully expanding a source form is called code walking in the fully expanded walked form the when form is replaced by the primitive if all macros must be expanded before the source code containing them can be evaluated or compiled normally macros can be considered functions that accept and return abstract syntax trees lisp sexpressions these functions are invoked before the evaluator or compiler to produce the final source code macros are written in normal common lisp and may use any common lisp or thirdparty operator available variable capture and shadowing common lisp macros are capable of what is commonly called variable capture where symbols in the macroexpansion body coincide with those in the calling context allowing the programmer to create macros wherein various symbols have special meaning the term variable capture is somewhat misleading because all namespaces are vulnerable to unwanted capture including the operator and function namespace the tagbody label namespace catch tag condition handler and restart namespaces variable capture can introduce software defects this happens in one of the following two ways the scheme dialect of lisp provides a macrowriting system which provides the referential transparency that eliminates both types of capture problem this type of macro system is sometimes called hygienic in particular by its proponents who regard macro systems which do not automatically solve this problem as unhygienic in common lisp macro hygiene is ensured one of two different ways one approach is to use gensyms guaranteedunique symbols which can be used in a macroexpansion without threat of capture the use of gensyms in a macro definition is a manual chore but macros can be written which simplify the instantiation and use of gensyms gensyms solve type  capture easily but they are not applicable to type  capture in the same way because the macro expansion cannot rename the interfering symbols in the surrounding code which capture its references gensyms could be used to provide stable aliases for the global symbols which the macro expansion needs the macro expansion would use these secret aliases rather than the wellknown names so redefinition of the wellknown names would have no ill effect on the macro another approach is to use packages a macro defined in its own package can simply use internal symbols in that package in its expansion the use of packages deals with type  and type  capture however packages dont solve the type  capture of references to standard common lisp functions and operators the reason is that the use of packages to solve capture problems revolves around the use of private symbols symbols in one package which are not imported into or otherwise made visible in other packages whereas the common lisp library symbols are external and frequently imported into or made visible in userdefined packages the following is an example of unwanted capture in the operator namespace occurring in the expansion of a macro the codice macro will expand into a form which calls codice which is intended to refer to the standard common lisp macro codice however in this context codice may have a completely different meaning so codice may not work properly common lisp solves the problem of the shadowing of standard operators and functions by forbidding their redefinition because it redefines the standard operator codice the preceding is actually a fragment of nonconforming common lisp which allows implementations to diagnose and reject it condition system the condition system is responsible for exception handling in common lisp it provides conditions handlers and restarts conditions are objects describing an exceptional situation for example an error if a condition is signaled the common lisp system searches for a handler for this condition type and calls the handler the handler can now search for restarts and use one of these restarts to repair the current problem as part of a user interface for example of a debugger these restarts can also be presented to the user so that the user can select and invoke one of the available restarts since the condition handler is called in the context of the error without unwinding the stack full error recovery is possible in many cases where other exception handling systems would have already terminated the current routine the debugger itself can also be customized or replaced using the codice dynamic variable in the following example using symbolics genera the user tries to open a file in a lisp function test called from the readevalprintloop repl when the file does not exist the lisp system presents four restarts the user selects the retry open using a different pathname restart and enters a different pathname lispminitlisp instead of lispmintlisp the user code does not contain any error handling code the whole error handling and restart code is provided by the lisp system which can handle and repair the error without terminating the user code common lisp object system clos common lisp includes a toolkit for objectoriented programming the common lisp object system or clos which is one of the most powerful object systems available in any language for example peter norvig explains how many design patterns are simpler to implement in a dynamic language with the features of clos multiple inheritance mixins multimethods metaclasses method combinations etc several extensions to common lisp for objectoriented programming have been proposed to be included into the ansi common lisp standard but eventually clos was adopted as the standard objectsystem for common lisp clos is a dynamic object system with multiple dispatch and multiple inheritance and differs radically from the oop facilities found in static languages such as c or java as a dynamic object system clos allows changes at runtime to generic functions and classes methods can be added and removed classes can be added and redefined objects can be updated for class changes and the class of objects can be changed clos has been integrated into ansi common lisp generic functions can be used like normal functions and are a firstclass data type every clos class is integrated into the common lisp type system many common lisp types have a corresponding class there is more potential use of clos for common lisp the specification does not say whether conditions are implemented with clos pathnames and streams could be implemented with clos these further usage possibilities of clos for ansi common lisp are not part of the standard actual common lisp implementations are using clos for pathnames streams inputoutput conditions the implementation of clos itself and more compiler and interpreter several implementations of earlier lisp dialects provided both an interpreter and a compiler unfortunately often the semantics were different these earlier lisps implemented lexical scoping in the compiler and dynamic scoping in the interpreter common lisp requires that both the interpreter and compiler use lexical scoping by default the common lisp standard describes both the semantics of the interpreter and a compiler the compiler can be called using the function compile for individual functions and using the function compilefile for files common lisp allows type declarations and provides ways to influence the compiler code generation policy for the latter various optimization qualities can be given values between  not important and  most important speed space safety debug and compilationspeed there is also a function to evaluate lisp code codice codice takes code as preparsed sexpressions and not like in some other languages as text strings this way code can be constructed with the usual lisp functions for constructing lists and symbols and then this code can be evaluated with the function codice several common lisp implementations like clozure cl and sbcl are implementing codice using their compiler this way code is compiled even though it is evaluated using the function codice the file compiler is invoked using the function compilefile the generated file with compiled code is called a fasl from fast load file these fasl files and also source code files can be loaded with the function load into a running common lisp system depending on the implementation the file compiler generates bytecode for example for the java virtual machine c language code which then is compiled with a c compiler or directly native code common lisp implementations can be used interactively even though the code gets fully compiled the idea of an interpreted language thus does not apply for interactive common lisp the language makes distinction between readtime compiletime loadtime and runtime and allows user code to also make this distinction to perform the wanted type of processing at the wanted step some special operators are provided to especially suit interactive development for instance codice will only assign a value to its provided variable if it wasnt already bound while codice will always perform the assignment this distinction is useful when interactively evaluating compiling and loading code in a live image some features are also provided to help writing compilers and interpreters symbols consist of firstlevel objects and are directly manipulable by user code the codice special operator allows to create lexical bindings programmatically while packages are also manipulable the lisp compiler itself is available at runtime to compile files or individual functions these make it easy to use lisp as an intermediate compiler or interpreter for another language code examples birthday paradox the following program calculates the smallest number of people in a room for whom the probability of completely unique birthdays is less than  the birthday paradox where for  person the probability is obviously  for  it is  etc the answer is  calling the example function using the repl read eval print loop sorting a list of person objects we define a class codice and a method for displaying the name and age of a person next we define a group of persons as a list of codice objects then we iterate over the sorted list it prints the three names with descending age exponentiating by squaring use of the loop macro is demonstrated example use compare with the built in exponentiation find the list of available shells withopenfile is a macro that opens a file and provides a stream when the form is returning the file is automatically closed funcall calls a function object the loop collects all lines that match the predicate the function availableshells calls above function listmatchinglines with a pathname and an anonymous function as the predicate the predicate returns the pathname of a shell or nil if the string is not the filename of a shell example results on mac os x  comparison with other lisps common lisp is most frequently compared with and contrasted to schemeif only because they are the two most popular lisp dialects scheme predates cl and comes not only from the same lisp tradition but from some of the same engineersguy l steele with whom gerald jay sussman designed scheme chaired the standards committee for common lisp common lisp is a generalpurpose programming language in contrast to lisp variants such as emacs lisp and autolisp which are extension languages embedded in particular products unlike many earlier lisps common lisp like scheme uses lexical variable scope by default for both interpreted and compiled code most of the lisp systems whose designs contributed to common lispsuch as zetalisp and franz lispused dynamically scoped variables in their interpreters and lexically scoped variables in their compilers scheme introduced the sole use of lexically scoped variables to lisp an inspiration from algol  which was widely recognized as a good idea cl supports dynamically scoped variables as well but they must be explicitly declared as special there are no differences in scoping between ansi cl interpreters and compilers common lisp is sometimes termed a lisp and scheme a lisp referring to cls use of separate namespaces for functions and variables in fact cl has many namespaces such as those for go tags block names and codice keywords there is a longstanding controversy between cl and scheme advocates over the tradeoffs involved in multiple namespaces in scheme it is broadly necessary to avoid giving variables names which clash with functions scheme functions frequently have arguments named codice codice or codice so as not to conflict with the system function codice however in cl it is necessary to explicitly refer to the function namespace when passing a function as an argumentwhich is also a common occurrence as in the codice example above cl also differs from scheme in its handling of boolean values scheme uses the special values t and f to represent truth and falsity cl follows the older lisp convention of using the symbols t and nil with nil standing also for the empty list in cl any nonnil value is treated as true by conditionals such as codice whereas in scheme all nonf values are treated as true these conventions allow some operators in both languages to serve both as predicates answering a booleanvalued question and as returning a useful value for further computation but in scheme the value  which is equivalent to nil in common lisp evaluates to true in a boolean expression lastly the scheme standards documents require tailcall optimization which the cl standard does not most cl implementations do offer tailcall optimization although often only when the programmer uses an optimization directive nonetheless common cl coding style does not favor the ubiquitous use of recursion that scheme style preferswhat a scheme programmer would express with tail recursion a cl user would usually express with an iterative expression in codice codice codice or more recently with the codice package implementations see the category  common lisp is defined by a specification like ada and c rather than by one implementation like perl before version  there are many implementations and the standard details areas in which they may validly differ in addition implementations tend to come with extensions which provide functionality not covered in the standard free and open source software libraries have been created to support extensions to common lisp in a portable way and are most notably found in the repositories of the commonlispnet and common lisp open code collection projects common lisp implementations may use any mix of native code compilation byte code compilation or interpretation common lisp has been designed to support incremental compilers file compilers and block compilers standard declarations to optimize compilation such as function inlining or type specialization are proposed in the language specification most common lisp implementations compile source code to native machine code some implementations can create optimized standalone applications others compile to interpreted bytecode which is less efficient than native code but eases binarycode portability there are also compilers that compile common lisp code to c code the misconception that lisp is a purely interpreted language is most likely because lisp environments provide an interactive prompt and that code is compiled onebyone in an incremental way with common lisp incremental compilation is widely used some unixbased implementations clisp sbcl can be used as a scripting language that is invoked by the system transparently in the way that a perl or unix shell interpreter is applications see the category  common lisp is used to develop research applications often in artificial intelligence for rapid development of prototypes or for deployed applications common lisp is used in many commercial applications including the yahoo store webcommerce site which originally involved paul graham and was later rewritten in c and perl other notable examples include there also exist opensource applications written in common lisp such as libraries since  zach beane with support of the common lisp foundation maintains the quicklisp library manager it allows easy access to several hundred libraries written in common lisp bibliography a chronological list of books published or about to be published about common lisp the language or about programming with common lisp especially ai programming