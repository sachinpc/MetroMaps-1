lpc programming language lpc short for lars pensj c is an objectoriented programming language derived from c and developed originally by lars pensj to facilitate mud building on lpmuds though designed for game development its flexibility has led to it being used for a variety of purposes and to its evolution into the language pike lpc syntax places it in the family of clike languages with c and c its strongest influences basic structure almost everything in lpc is an object however lpc does not precisely use the concept of a class mudos has something called a class but it is really a struct instead lpc objects are blueprint objects and clones of blueprint objects in a prototypebased programming model one can treat a blueprint object much as a class in other objectoriented languages each object has variables attributes and functions methods the variables store the objects state the functions are executable routines that can be called in the object an object is uniquely defined by the name of the file in which it comes from plus if a clone a numeric identifier in a typical implementation a clone of the file codice which is the third clone created in the current run session will be codice the blueprint object corresponding to codice is simply codice in a mud game common objects include rooms weapons armor and nonplayer character npcs most mudlibs define inheritable objects for such common things in the lpmud  mudlib for example the parent object for all rooms is codice in lpc it is not possible to syntactically declare classonly or instanceonly methods and attributes all functions and variables may be accessed identically in blueprints and in clones for example codice would call the codice function directly in the blueprint instance of codice however a controversial mechanism in many drivers called shadowing allows instance methods to be emulated to some extent by permitting one object to overlay its function set onto another in effect interposing itself between external function calls and the shadowed object direct external access to variables is also not supported all interaction between objects is carried out through function calls notwithstanding that data structures pointed to by variables are independent of objects and changes to them are visible in all objects referencing those data structures simultaneously and that some drivers have privileged functions allowing a cumbersome form of external variable access that permits inspection but not mutation a simple room in a typical mudlib because lpc is generally used to code muds rooms are often created as objects that store information describing a particular scene along with exits that point to other room objects this is the most common usage of lpc other uses that are not game related are possible the following example shows a very simple traditional room that leverages functions defined in the mudlib object codice however not all mudlibs define or determine rooms in the same way so this is not the only method of defining a room the first line tells the object to inherit functionality from the codice object this example assumes the codice object defines functions for codice and codice this example contains a single function codice most drivers call or can be set to call codice to allow an object to initialize itself with startup values it is the standard constructor in this case the example calls functions that set up the basic room attributes in the inherited codice the functions called here are highly dependent on the mudlib in use since the mudlib defines the actual room parent most drivers also support applying type modifiers to inherit statements causing the inherited object to behave with respect to its inheritor as if the type modifier were applied to its functions andor variables as appropriate data types pseudotypes and type modifiers where the term object variable is used above this means a variable which is an element of an object ie an attribute as opposed to a local variable exists only within a function or block or a global variable nonexistent in lpc  if someone speaks of a global variable in reference to lpc they probably mean an object variable passing values primitive lpc types int string status float etc are passed by value data structure types object array mapping class struct are passed by reference this feature can be powerful but it can also lead to security holes in most muds the people building the world are generally less trusted than the staff running the game if an object passes a mapping with sensitive values like access control information an author of another object can modify that and thus increase their access rights mudlib developers and server administrators should thus be careful when passing complex types to lower access objects function types lpc environments generally categorize functions into several major types according to how they are implemented master object lpc implementations generally have a master object which is a specific lpc object that is loaded first by the lpc driver and which essentially controls what will happen past that point the master object will typically tell the driver where the simulefun object is preload any objects which need to be present at startup define what functions will be called when an object is loaded and otherwise configure the drivers operation the driver will refer back to the master object when it needs to interact with a central point of reference for the running environment such as for accepting network connections handling errors and validating attempts to perform privileged operations