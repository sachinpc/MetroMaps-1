generics in java generics are a facility of generic programming that were added to the java programming language in  within jse  they extend javas type system to allow a type or method to operate on objects of various types while providing compiletime type safety in particular the java collections framework supports generics to specify the type of objects stored in a collection instance in  philip wadler created generic java an extension to the java language to support generic types generic java was incorporated with the addition of wildcards into the official java language version jse  hierarchy and classification according to java language specification motivation the following block of java code illustrates a problem that exists when not using generics first it declares an codice of type codice then it adds a codice to the codice finally it attempts to retrieve the added codice and cast it to an codice although the code is compiled without error it throws a runtime exception codice when executing the third line of code this type of problem can be avoided by using generics and is the primary motivation for using generics using generics the above code fragment can be rewritten as follows the type parameter codice within the angle brackets declares the codice to be constituted of codice a descendant of the codices generic codice constituents with generics it is no longer necessary to cast the third line to any particular type because the result of codice is defined as codice by the code generated by the compiler compiling the third line of this fragment with jse  or later will yield a compiletime error because the compiler will detect that codice returns codice instead of codice for a more elaborate example see reference here is a small excerpt from the definition of the interfaces codice and codice in package  type wildcards a type argument for a parameterized type is not limited to a concrete class or interface java allows the use of type wildcards to serve as type arguments for parameterized types wildcards are type arguments in the form  possibly with an upper or lower bound given that the exact type represented by a wildcard is unknown restrictions are placed on the type of methods that may be called on an object which uses parameterized types as an example of an unbounded wildcard codice indicates a list which has an unknown object type methods which take such a list as a parameter will accept any type of list as argument reading from the list will return objects of type codice and adding nonnull elements to the list is not allowed since the element type is not known to specify the upper bound of a type wildcard the codice keyword is used which indicates that the type argument is a subtype of the bounding class so codice means that the given list contains objects of some unknown type which extend the codice class for example the list could be codice or codice reading an element from the list will return a codice while adding nonnull elements is once again not allowed the use of wildcards above adds flexibility since there is not any inheritance relationship between any two parameterized types with concrete type as type argument neither codice nor codice is a subtype of the other even though codice is a subtype of codice so any method that takes codice as a parameter does not accept an argument of codice if it did it would be possible to insert a codice that is not an codice into it which violates type safety here is sample code that explains the contradiction it brings if codice were a subtype of codice the solution with wildcards works because it disallows operations that would violate type safety to specify the lower bounding class of a type wildcard the codice keyword is used this keyword indicates that the that the type argument is a supertype of the bounding class so codice could represent codice or codice reading from a list defined as codice returns elements of type codice adding to such a list requires elements of type codice or any super type of codice the mnemonic pecs producer extends consumer super from the book effective java by joshua bloch gives an easy way to remember when to use wildcards corresponding to covariance and contravariance in java generic class definitions here is an example of a generic java class which can be used to represent individual entries key to value mappings in a map this generic class could be used in the following ways for example it outputs diamond operator java se  and  allow the programmer to substitute an empty pair of angle brackets codice called the diamond operator for a pair of angle brackets containing the one or more type parameters that a sufficientlyclose context implies thus the above code example using codice can be rewritten as generic method definitions here is an example of a generic method using the generic class above note if we remove the first in the above method we will get compilation error cannot find symbol type since it represents the declaration of the symbol in many cases the user of the method need not indicate the type parameters as they can be inferred the parameters can be explicitly added if needed the use of primitive types is not allowed and boxed versions must be used instead there is also the possibility to create generic methods based on given parameters in such cases you cant use primitive types either eg generics in throws clause although exceptions themselves cannot be generic generic parameters can appear in a throws clause problems with type erasure generics are checked at compiletime for typecorrectness the generic type information is then removed in a process called type erasure for example codice will be converted to the nongeneric type codice which ordinarily contains arbitrary objects the compiletime check guarantees that the resulting code is typecorrect because of type erasure type parameters cannot be determined at runtime for example when an codice is examined at runtime there is no general way to determine whether before type erasure it was an codice or an codice many people are dissatisfied with this restriction there are partial approaches for example individual elements may be examined to determine the type they belong to for example if an codice contains an codice that arraylist may have been parameterized with codice however it may have been parameterized with any parent of codice such as codice or codice demonstrating this point the following code outputs equal another effect of type erasure is that a generic class cannot extend the throwable class in any way directly or indirectly the reason why this is not supported is due to type erasure due to type erasure the runtime will not know which catch block to execute so this is prohibited by the compiler java generics differ from c templates java generics generate only one compiled version of a generic class or function regardless of the number of parameterizing types used furthermore the java runtime environment does not need to know which parameterized type is used because the type information is validated at compiletime and is not included in the compiled code consequently instantiating a java class of a parameterized type is impossible because instantiation requires a call to a constructor which is unavailable if the type is unknown for example the following code cannot be compiled because there is only one copy per generic class at runtime static variables are shared among all the instances of the class regardless of their type parameter consequently the type parameter cannot be used in the declaration of static variables or in static methods project valhalla project valhalla is an experimental project to incubate improved java generics  language features for future versions potentially from java  onwards potential enhancements include