java concurrency the java programming language and the java virtual machine jvm have been designed to support concurrent programming and all execution takes place in the context of threads objects and resources can be accessed by many separate threads each thread has its own path of execution but can potentially access any object in the program the programmer must ensure read and write access to objects is properly coordinated or synchronized between threads thread synchronization ensures that objects are modified by only one thread at a time and that threads are prevented from accessing partially updated objects during modification by another thread the java language has builtin constructs to support this coordination processes and threads most implementations of the java virtual machine run as a single process and in the java programming language concurrent programming is mostly concerned with threads also called lightweight processes multiple processes can only be realized with multiple jvms thread objects threads share the processs resources including memory and open files this makes for efficient but potentially problematic communication every application has at least one thread called the main thread the main thread has the ability to create additional threads as codice or codice objects the codice interface is similar to codice in that both are designed for classes whose instances are potentially executed by another thread a codice however does not return a result and cannot throw a checked exception each thread can be scheduled on a different cpu core or use timeslicing on a single hardware processor or timeslicing on many hardware processors there is no generic solution to how java threads are mapped to native os threads every jvm implementation can do it in a different way each thread is associated with an instance of the class thread threads can be managed either directly using thread objects or using abstract mechanisms such as codices and codice collections starting a thread two ways to start a thread interrupts an interrupt is an indication to a thread that it should stop what it is doing and do something else a thread sends an interrupt by invoking interrupt on the thread object for the thread to be interrupted the interrupt mechanism is implemented using an internal flag known as the interrupt status invoking codice sets this flag by convention any method that exits by throwing an codice clears interrupt status when it does so however its always possible that interrupt status will immediately be set again by another thread invoking interrupt joins the codice methods allow one thread to wait for the completion of another exceptions uncaught exceptions thrown by code will terminate the thread the codice thread prints exceptions to the console but usercreated threads need a handler registered to do so memory model the java memory model describes how threads in the java programming language interact through memory on modern platforms code is frequently not executed in the order it was written it is reordered by the compiler the processor and the memory subsystem to achieve maximum performance the java programming language does not guarantee linearizability or even sequential consistency when reading or writing fields of shared objects and this is to allow for compiler optimizations such as register allocation common subexpression elimination and redundant read elimination all of which work by reordering memory readswrites synchronization threads communicate primarily by sharing access to fields and the objects that reference fields refer to this form of communication is extremely efficient but makes two kinds of errors possible thread interference and memory consistency errors the tool needed to prevent these errors is synchronization reorderings can come into play in incorrectly synchronized multithreaded programs where one thread is able to observe the effects of other threads and may be able to detect that variable accesses become visible to other threads in a different order than executed or specified in the program most of the time one thread doesnt care what the other is doing but when it does thats what synchronization is for to synchronize threads java uses monitors which are a highlevel mechanism for allowing only one thread at a time to execute a region of code protected by the monitor the behavior of monitors is explained in terms of locks there is a lock associated with each object synchronization has several aspects the most wellunderstood is mutual exclusiononly one thread can hold a monitor at once so synchronizing on a monitor means that once one thread enters a synchronized block protected by a monitor no other thread can enter a block protected by that monitor until the first thread exits the synchronized block but there is more to synchronization than mutual exclusion synchronization ensures that memory writes by a thread before or during a synchronized block are made visible in a predictable manner to other threads which synchronize on the same monitor after we exit a synchronized block we release the monitor which has the effect of flushing the cache to main memory so that writes made by this thread can be visible to other threads before we can enter a synchronized block we acquire the monitor which has the effect of invalidating the local processor cache so that variables will be reloaded from main memory we will then be able to see all of the writes made visible by the previous release readswrites to fields are linearizable if either the field is volatile or the field is protected by a unique lock which is acquired by all readers and writers locks and synchronized blocks a thread can achieve mutual exclusion either by entering a synchronized block or method which acquires an implicit lock or by acquiring an explicit lock such as the reentrantlock from the javautilconcurrentlocks package both approaches have the same implications for memory behavior if all accesses to a particular field are protected by the same lock then readswrites to that field are linearizable atomic volatile fields when applied to a field the java codice guarantees that volatile fields are linearizable reading a volatile field is like acquiring a lock the working memory is invalidated and the volatile fields current value is reread from memory writing a volatile field is like releasing a lock the volatile field is immediately written back to memory final fields a field declared to be final cannot be modified once it has been initialized an objects final fields are initialized in its constructor if the constructor follows certain simple rules then the correct value of any final fields will be visible to other threads without synchronization the rule is simple the codice reference must not be released from the constructor before the constructor returns history since jdk  java has included a standard set of collection classes the java collections framework doug lea who also participated in the java collections framework implementation developed a concurrency package comprising several concurrency primitives and a large battery of collectionrelated classes this work was continued and updated as part of jsr  which was chaired by doug lea jdk  incorporated many additions and clarifications to the java concurrency model the concurrency apis developed by jsr  were also included as part of the jdk for the first time jsr  provided support for welldefined atomic operations in a multithreadedmultiprocessor environment both the java se  and java se  releases introduced updated versions of the jsr  apis as well as several new additional apis