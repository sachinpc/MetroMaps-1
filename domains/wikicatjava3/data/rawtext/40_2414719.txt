final java in the java programming language the codice keyword is used in several different contexts to define an entity that can only be assigned once once a codice variable has been assigned it always contains the same value if a codice variable holds a reference to an object then the state of the object may be changed by operations on the object but the variable will always refer to the same object this property of codice is called nontransitivity this applies also to arrays because arrays are objects if a codice variable holds a reference to an array then the components of the array may be changed by operations on the array but the variable will always refer to the same array final classes a final class cannot be subclassed doing this can confer security and efficiency benefits so many of the java standard library classes are final such as and  example final methods a final method cannot be overridden or hidden by subclasses this is used to prevent unexpected behavior from a subclass altering a method that may be crucial to the function or consistency of the class example a common misconception is that declaring a method as codice improves efficiency by allowing the compiler to directly insert the method wherever it is called see inline expansion because the method is loaded at runtime compilers are unable to do this only the runtime environment and jit compiler know exactly which classes have been loaded and so only they are able to make decisions about when to inline whether or not the method is final machine code compilers which generate directly executable platformspecific machine code are an exception when using static linking the compiler can safely assume that methods and variables computable at compiletime may be inlined final variables a final variable can only be initialized once either via an initializer or an assignment statement it does not need to be initialized at the point of declaration this is called a blank final variable a blank final instance variable of a class must be definitely assigned in every constructor of the class in which it is declared similarly a blank final static variable must be definitely assigned in a static initializer of the class in which it is declared otherwise a compiletime error occurs in both cases note if the variable is a reference this means that the variable cannot be rebound to reference another object but the object that it references is still mutable if it was originally mutable unlike the value of a constant the value of a final variable is not necessarily known at compile time it is considered good practice to represent final constants in all uppercase using underscore to separate words example any attempt to reassign codice codice codice or codice will result in a compile error in fact even if the constructor doesnt set a final variable attempting to set it outside the constructor will result in a compilation error to illustrate that finality doesnt guarantee immutability suppose we replace the three position variables with a single one where codice is an object with three properties codice codice and codice then codice cannot be assigned to but the three properties can unless they are final themselves like full immutability the use of final variables has great advantages especially in optimization for instance codice will probably have a function returning its volume knowing that its radius is constant allows us to memoize the computed volume if we have relatively few codices and we need their volumes very often the performance gain might be substantial making the radius of a codice codice informs developers and compilers that this sort of optimization is possible in all code that uses codices though it appears to violate the codice principle the following is a legal statement since the obj variable goes out of scope with each iteration of the loop it is actually redeclared each iteration allowing the same token ie codice to be used to represent multiple variables final and inner classes when an anonymous inner class is defined within the body of a method all variables declared codice in the scope of that method are accessible from within the inner class for scalar values once it has been assigned the value of the codice variable cannot change for object values the reference cannot change this allows the java compiler to capture the value of the variable at runtime and store a copy as a field in the inner class once the outer method has terminated and its stack frame has been removed the original variable is gone but the inner classs private copy persists in the classs own memory blank final the blank final which was introduced in java  is a final variable whose declaration lacks an initializer a blank final can only be assigned once and must be unassigned when an assignment occurs in order to do this a java compiler runs a flow analysis to ensure that for every assignment to a blank final variable the variable is definitely unassigned before the assignment otherwise a compiletime error occurs cc analog of final variables in c and c the analogous construct is the codice keyword this differs substantially from codice in java most basically in being a type qualifier codice is part of the type not only part of the identifier variable this also means that the constancy of a value can be changed by casting explicit type conversion in this case known as const casting nonetheless casting away constness and then modifying the object results in undefined behavior further because c and c expose pointers and references directly there is a distinction between whether the pointer itself is constant and whether the data pointed to by the pointer is constant applying codice to a pointer itself as in codice means that the contents being referenced can be modified but the reference itself cannot without casting this usage results in behaviour which mimics the behaviour of a codice variable reference in java by contrast when applying const to the referenced data only as in codice the contents cannot be modified without casting but the reference itself can both the reference and the contents being referenced can be declared as codice due to casting c codice is a soft guideline and it can easily be overridden by the programmer the programmer can easily cast a const reference to an nonconst reference javas final is a strict rule such that it is impossible to compile code that directly breaks or bypasses the final restrictions using reflection however it is often possible to still modify final variables this feature is mostly made use of when deserializing objects with final members