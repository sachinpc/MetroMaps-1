flowbased programming in computer programming flowbased programming fbp is a programming paradigm that defines applications as networks of black box processes which exchange data across predefined connections by message passing where the connections are specified externally to the processes these black box processes can be reconnected endlessly to form different applications without having to be changed internally fbp is thus naturally componentoriented fbp is a particular form of dataflow programming based on bounded buffers information packets with defined lifetimes named ports and separate definition of connections introduction flowbased programming defines applications using the metaphor of a data factory it views an application not as a single sequential process which starts at a point in time and then does one thing at a time until it is finished but as a network of asynchronous processes communicating by means of streams of structured data chunks called information packets ips in this view the focus is on the application data and the transformations applied to it to produce the desired outputs the network is defined externally to the processes as a list of connections which is interpreted by a piece of software usually called the scheduler the processes communicate by means of fixedcapacity connections a connection is attached to a process by means of a port which has a name agreed upon between the process code and the network definition more than one process can execute the same piece of code at any point in time a given ip can only be owned by a single process or be in transit between two processes ports may either be simple or arraytype as used eg for the input port of the collate component described below it is the combination of ports with asynchronous processes that allows many longrunning primitive functions of data processing such as sort merge summarize etc to be supported in the form of software black boxes because fbp processes can continue executing as long they have data to work on and somewhere to put their output fbp applications generally run in less elapsed time than conventional programs and make optimal use of all the processors on a machine with no special programming required to achieve this the network definition is usually diagrammatic and is converted into a connection list in some lowerlevel language or notation fbp is thus a visual programming language at this level more complex network definitions have a hierarchical structure being built up from subnets with sticky connections fbp has much in common with the linda language in that it is in gelernter and carrieros terminology a coordination language it is essentially languageindependent indeed given a scheduler written in a sufficiently lowlevel language components written in different languages can be linked together in a single network fbp thus lends itself to the concept of domainspecific languages or minilanguages fbp exhibits data coupling described in the article on coupling as the loosest type of coupling between components the concept of loose coupling is in turn related to that of serviceoriented architectures and fbp fits a number of the criteria for such an architecture albeit at a more finegrained level than most examples of this architecture fbp promotes highlevel functional style of specifications that simplify reasoning about system behavior an example of this is the distributed data flow model for constructively specifying and analyzing the semantics of distributed multiparty protocols history flowbased programming was invented by j paul morrison in the early s and initially implemented in software for a canadian bank fbp at its inception was strongly influenced by some ibm simulation languages of the period in particular gpss but its roots go all the way back to conways seminal paper on what he called coroutines fbp has undergone a number of name changes over the years the original implementation was called amps advanced modular processing system one large application in canada went live in  and as of  has been in continuous production use running daily for almost  years because ibm considered the ideas behind fbp too much like a law of nature to be patentable they instead put the basic concepts of fbp into the public domain by means of a technical disclosure bulletin data responsive modular interleaved task programming system in  an article describing its concepts and experience using it was published in  in the ibm research ibm systems journal under the name dslm a second implementation was done as a joint project of ibm canada and ibm japan under the name data flow development manager dfdm and was briefly marketed in japan in the late s under the name data flow programming manager generally the concepts were referred to within ibm as data flow but this term was felt to be too general and eventually the name flowbased programming was adopted from the early s to  j paul morrison and ibm architect wayne stevens refined and promoted the concepts behind fbp stevens wrote several articles describing and supporting the fbp concept and included material about it in several of his books in  morrison published a book describing fbp and providing empirical evidence that fbp led to reduced development times in  a european fbpbased project called noflo was implemented in javascript it is being used mainly in the area of web site design incorporating a number of ai concepts concepts the following diagram shows the major entities of an fbp diagram apart from the information packets such a diagram can be converted directly into a list of connections which can then be executed by an appropriate engine software or hardware a b and c are processes executing code components o o and the two ins are ports connecting the connections m and n to their respective processes it is permitted for processes b and c to be executing the same code so each process must have its own set of working storage control blocks etc whether or not they do share code b and c are free to use the same port names as port names only have meaning within the components referencing them and at the network level of course m and n are what are often referred to as bounded buffers and have a fixed capacity in terms of the number of ips that they can hold at any point in time the concept of ports is what allows the same component to be used at more than one place in the network in combination with a parametrization ability called initial information packets iips ports provide fbp with a component reuse ability making fbp a componentbased architecture fbp thus exhibits what raoul de campo and nate edwards of ibm research have termed configurable modularity information packets or ips are allocated in what might be called ip space just as lindas tuples are allocated in tuple space and have a welldefined lifetime until they are disposed of and their space is reclaimed  in fbp this must be an explicit action on the part of an owning process ips traveling across a given connection actually it is their handles that travel constitute a stream which is generated and consumed asynchronously  this concept thus has similarities to the lazy cons concept described in the  article by friedman and wise ips are usually structured chunks of data  some ips however may not contain any real data but are used simply as signals an example of this is bracket ips which can be used to group data ips into sequential patterns within a stream called substreams substreams may in turn be nested ips may also be chained together to form ip trees which travel through the network as single objects the system of connections and processes described above can be ramified to any size during the development of an application monitoring processes may be added between pairs of processes processes may be exploded to subnets or simulations of processes may be replaced by the real process logic fbp therefore lends itself to rapid prototyping this is really an assembly line image of data processing the ips travelling through a network of processes may be thought of as widgets travelling from station to station in an assembly line machines may easily be reconnected taken off line for repair replaced and so on oddly enough this image is very similar to that of unit record equipment that was used to process data before the days of computers except that decks of cards had to be handcarried from one machine to another implementations of fbp may be nonpreemptive or preemptive  the earlier implementations tended to be nonpreemptive mainframe and c language whereas the latest java implementation see below uses java thread class and is preemptive examples telegram problem fbp components often form complementary pairs this example uses two such pairs the problem described seems very simple as described in words but in fact is surprisingly difficult to accomplish using conventional procedural logic the task called the telegram problem originally described by peter naur is to write a program which accepts lines of text and generates output lines containing as many words as possible where the number of characters in each line does not exceed a certain length the words may not be split and we assume no word is longer than the size of the output lines this is analogous to the wordwrapping problem in text editors in conventional logic the programmer rapidly discovers that neither the input nor the output structures can be used to drive the call hierarchy of control flow in fbp on the other hand the problem description itself suggests a solution here is the most natural solution in fbp there is no single correct solution in fbp but this seems like a natural fit where dc and rc stand for decompose and recompose respectively as mentioned above initial information packets iips can be used to specify parametric information such as the desired output record length required by the rightmost two components or file names iips are data chunks associated with a port in the network definition which become normal ips when a receive is issued for the relevant port batch update this type of program involves passing a file of details changes adds and deletes against a master file and producing at least an updated master file and one or more reports update programs are generally quite hard to code using synchronous procedural code as two sometimes more input streams have to be kept synchronized even though there may be masters without corresponding details or vice versa in fbp a reusable component collate based on the unit record idea of a collator makes writing this type of application much easier as collate merges the two streams and inserts bracket ips to indicate grouping levels significantly simplifying the downstream logic suppose that one stream masters in this case consists of ips with key values of   and  and the second stream ips details have key values of       and  where the first digit corresponds to the master key values using bracket characters to represent bracket ips the collated output stream will be as follows as there was no master with a value of  the last group consists of a single detail plus brackets the structure of the above stream can be described succinctly using a bnflike notation such as collate is a reusable black box which only needs to know where the control fields are in its incoming ips even this is not strictly necessary as transformer processes can be inserted upstream to place the control fields in standard locations and can in fact be generalized to any number of input streams and any depth of bracket nesting collate uses an arraytype port for input allowing a variable number of input streams multiplexing processes flowbased programming supports process multiplexing in a very natural way since components are readonly any number of instances of a given component processes can run asynchronously with each other when computers usually had a single processor this was useful when a lot of io was going on now that machines usually have multiple processors this is starting to become useful when processes are cpuintensive as well the diagram in this section shows a single load balancer process distributing data between  processes labeled s s and s respectively which are instances of a single component which in turn feed into a single process on a firstcome first served basis simple interactive network in this general schematic requests transactions coming from users enter the diagram at the upper left and responses are returned at the lower left the back ends on the right side communicate with systems at other sites eg using corba mqseries etc the crossconnections represent requests that do not need to go to the back ends or requests that have to cycle through the network more than once before being returned to the user as different requests may use different backends and may require differing amounts of time for the backends if used to process them provision must be made to relate returned data to the appropriate requesting transactions eg hash tables or caches the above diagram is schematic in the sense that the final application may contain many more processes processes may be inserted between other processes to manage caches display connection traffic monitor throughput etc also the blocks in the diagram may represent subnets  small networks with one or more open connections comparison with other paradigms and methodologies jackson structured programming jsp and jackson system development jsd this methodology assumes that a program must be structured as a single procedural hierarchy of subroutines its starting point is to describe the application as a set of main lines based on the input and output data structures one of these main lines is then chosen to drive the whole program and the others are required to be inverted to turn them into subroutines hence the name jackson inversion this sometimes results in what is called a clash requiring the program to be split into multiple programs or coroutines when using fbp this inversion process is not required as every fbp component can be considered a separate main line fbp and jsp share the concept of treating a program or some components as a parser of an input stream in jacksons later work jackson system development jsd the ideas were developed further in jsd the design is maintained as a network design until the final implementation stage the model is then transformed into a set of sequential processes to the number of available processors jackson discusses the possibility of directly executing the network model that exists prior to this step in section  of his book italics added fbp was recognized by m a jackson as an approach that follows his method of program decomposition into sequential processes communicating by a coroutinelike mechanism applicative programming wb ackerman defines an applicative language as one which does all of its processing by means of operators applied to values the earliest known applicative language was lisp an fbp component can be regarded as a function transforming its input streams into its output streams these functions are then combined to make more complex transformations as shown here if we label streams as shown with lower case letters then the above diagram can be represented succinctly as follows just as in functional notation f can be used twice because it only works with values and therefore has no side effects in fbp two instances of a given component may be running concurrently with each other and therefore fbp components must not have sideeffects either functional notation could clearly be used to represent at least a part of an fbp network the question then arises whether fbp components can themselves be expressed using functional notation wh burge showed how stream expressions can be developed using a recursive applicative style of programming but this work was in terms of streams of atomic values in fbp it is necessary to be able to describe and process structured data chunks fbp ips furthermore most applicative systems assume that all the data is available in memory at the same time whereas fbp applications need to be able to process longrunning streams of data while still using finite resources friedman and wise suggested a way to do this by adding the concept of lazy cons to burges work this removed the requirement that both of the arguments of cons be available at the same instant of time lazy cons does not actually build a stream until both of its arguments are realized  before that it simply records a promise to do this this allows a stream to be dynamically realized from the front but with an unrealized back end the end of the stream stays unrealized until the very end of the process while the beginning is an everlengthening sequence of items linda many of the concepts in fbp seem to have been discovered independently in different systems over the years linda mentioned above is one such the difference between the two techniques is illustrated by the linda school of piranhas load balancing technique  in fbp this requires an extra load balancer component which routes requests to the component in a list which has the smallest number of ips waiting to be processed clearly fbp and linda are closely related and one could easily be used to simulate the other objectoriented programming an object in oop can be described as a semiautonomous unit comprising both information and behaviour objects communicate by means of method calls which are essentially subroutine calls done indirectly via the class to which the receiving object belongs the objects internal data can only be accessed by means of method calls so this is a form of information hiding or encapsulation encapsulation however predates oop  david parnas wrote one of the seminal articles on it in the early s  and is a basic concept in computing encapsulation is the very essence of an fbp component which may be thought of as a black box performing some conversion of its input data into its output data in fbp part of the specification of a component is the data formats and stream structures that it can accept and those it will generate this constitutes a form of design by contract in addition the data in an ip can only be accessed directly by the currently owning process encapsulation can also be implemented at the network level by having outer processes protect inner ones a paper by c ellis and s gibbs distinguishes between active objects and passive objects passive objects comprise information and behaviour as stated above but they cannot determine the timing of this behaviour active objects on the other hand can do this in their article ellis and gibbs state that active objects have much more potential for the development of maintainable systems than do passive objects an fbp application can be viewed as a combination of these two types of object where fbp processes would correspond to active objects while ips would correspond to passive objects