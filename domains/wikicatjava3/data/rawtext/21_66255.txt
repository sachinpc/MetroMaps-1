bzip bzip is a free and opensource file compression program that uses the burrowswheeler algorithm it only compresses single files and is not a file archiver it is developed and maintained by julian seward seward made the first public release of bzip version  in july  the compressors stability and popularity grew over the next several years and seward released version  in late  compression efficiency bzip compresses most files more effectively than the older lzw z and deflate zip and gz compression algorithms but is considerably slower lzma is generally more spaceefficient than bzip at the expense of even slower compression speed while having much faster decompression bzip compresses data in blocks of size between  and  kb and uses the burrowswheeler transform to convert frequentlyrecurring character sequences into strings of identical letters it then applies movetofront transform and huffman coding bzips ancestor bzip used arithmetic coding instead of huffman the change was made because of a software patent restriction bzip performance is asymmetric as decompression is relatively fast motivated by the large cpu time required for compression a modified version was created in  called pbzip that supported multithreading giving almost linear speed improvements on multicpu and multicore computers  this functionality has not been incorporated into the main project like gzip bzip is only a data compressor it is not an archiver like tar or zip the program itself has no facilities for multiple files encryption or archivesplitting but in the unix tradition relies instead on separate external utilities such as tar and gnupg for these tasks compression stack bzip uses several layers of compression techniques stacked on top of each other which occur in the following order during compression and the reverse order during decompression initial runlength encoding any sequence of  to  consecutive duplicate symbols is replaced by the first four symbols and a repeat length between  and  thus the sequence codice is replaced with codice where codice and codice represent byte values  and  respectively runs of symbols are always transformed after four consecutive symbols even if the runlength is set to zero to keep the transformation reversible in the worst case it can cause an expansion of  and best case a reduction to   while the specification theoretically allows for runs of length  to be encoded the reference encoder will not produce such output the author of bzip has stated that the rle step was a historical mistake and was only intended to protect the original bwt implementation from pathological cases burrowswheeler transform this is the reversible blocksort that is at the core of bzip the block is entirely selfcontained with input and output buffers remaining the same sizein bzip the operating limit for this stage is for the blocksort a notional matrix is created in which row formula contains the whole of the buffer rotated to start from the formula symbol following rotation the rows of the matrix are sorted into alphabetic numerical order a bit pointer is stored marking the starting position for when the block is untransformed in practice it is not necessary to construct the full matrix rather the sort is performed using pointers for each position in the buffer the output buffer is the last column of the matrix this contains the whole buffer but reordered so that it is likely to contain large runs of identical symbols move to front transform again this transform does not alter the size of the processed block each of the symbols in use in the document is placed in an array when a symbol is processed it is replaced by its location index in the array and that symbol is shuffled to the front of the array the effect is that immediately recurring symbols are replaced by zero symbols long runs of any arbitrary symbol thus become runs of zero symbols while other symbols are remapped according to their local frequency much natural data contains identical symbols that recur within a limited range text is a good example as the mtf transform assigns low values to symbols that reappear frequently this results in a data stream which contains many symbols in the low integer range many of them being identical different recurring input symbols can actually map to the same output symbol such data can be very efficiently encoded by any legacy compression method runlength encoding of mtf result long strings of zeros in the output of the movetofront transform which come from repeated symbols in the output of the bwt are replaced by a sequence of two special codes runa and runb which represent the runlength as a binary number actual zeros are never encoded in the output a lone zero becomes runa this step in fact is done at the same time as mtf is whenever mtf would produce zero it instead increases a counter to then encode with runa and runb the sequence codice would be represented as codice codice represents the value  as described below the runlength code is terminated by reaching another normal symbol this rle process is more flexible than the initial rle step as it is able to encode arbitrarily long integers in practice this is usually limited by the block size so that this step does not encode a run of more than  bytes the runlength is encoded in this fashion assigning place values of  to the first bit  to the second  to the third etc in the sequence multiply each place value in a runb spot by  and add all the resulting place values for runa and runb values alike together this is similar to base bijective numeration thus the sequence codice results in the value        as a more complicated example huffman coding this process replaces fixed length symbols in the range  with variable length codes based on the frequency of use more frequently used codes end up shorter  bits whilst rare codes can be allocated up to  bits the codes are selected carefully so that no sequence of bits can be confused for a different code the endofstream code is particularly interesting if there are n different bytes symbols used in the uncompressed data then the huffman code will consist of two rle codes runa and runb n   symbol codes and one endofstream code because of the combined result of the mtf and rle encodings in the previous two steps there is never any need to explicitly reference the first symbol in the mtf table would be zero in the ordinary mtf thus saving one symbol for the endofstream marker and explaining why only n   symbols are coded in the huffman tree in the extreme case where only one symbol is used in the uncompressed data there will be no symbol codes at all in the huffman tree and the entire block will consist of runa and runb implicitly repeating the single byte and an endofstream marker with value  multiple huffman tables several identicallysized huffman tables can be used with a block if the gain from using them is greater than the cost of including the extra table at least two  and up to six  tables can be present with the most appropriate table being reselected before every  symbols processed this has the advantage of having very responsive huffman dynamics without having to continuously supply new tables as would be required in deflate runlength encoding in the previous step is designed to take care of codes that have an inverse probability of use higher than the shortest code huffman code in use unary encoding of huffman table selection if multiple huffman tables are in use the selection of each table numbered  is done from a list by a zeroterminated bit run between one  and six  bits in length the selection is into a mtf list of the tables using this feature results in a maximum expansion of around  but generally less this expansion is likely to be greatly overshadowed by the advantage of selecting more appropriate huffman tables and the commoncase of continuing to use the same huffman table is represented as a single bit rather than unary encoding effectively this is an extreme form of a huffman tree where each code has half the probability of the previous code delta encoding huffman code bitlengths are required to reconstruct each of the used canonical huffman tables each bitlength is stored as an encoded difference against the previous code bitlength a zerobit  means that the previous bitlength should be duplicated for the current code whilst a onebit  means that a further bit should be read and the bitlength incremented or decremented based on that value in the common case a single bit is used per symbol per table and the worst casegoing from length one  to length twenty would require approximately  bits as a result of the earlier mtf encoding code lengths would start at  bits long very frequently used codes and gradually increase meaning that the delta format is fairly efficientrequiring around  bits  bytes per full huffman table sparse bit array a bitmap is used to show which symbols are used inside the block and should be included in the huffman trees binary data is likely to use all  symbols representable by a byte whereas textual data may only use a small subset of available values perhaps covering the ascii range between  and  storing  zero bits would be inefficient if they were mostly unused a sparse method is used the  symbols are divided up into  ranges and only if symbols are used within that block is a bit array included the presence of each of these  ranges is indicated by an additional bit bit array at the front the total bitmap uses between  and  bits of storage  bytes for contrast the deflate algorithm would show the absence of symbols by encoding the symbols as having a zero bitlength with run length encoding and additional huffman coding file format a codice stream consists of a byte header followed by zero or more compressed blocks immediately followed by an endofstream marker containing a bit crc for the plaintext whole stream processed the compressed blocks are bitaligned and no padding occurs because of the firststage rle compression see above the maximum length of plaintext that a single kb bzip block can contain is around mb bytes this can occur if the whole plaintext consists entirely of repeated values the resulting codice file in this case is bytes long an even smaller file of bytes can be achieved by using an input containing entirely values of  an apparent compression ratio of  the compressed blocks in bzip can be independently decompressed without having to process earlier blocks this means that bzip files can be decompressed in parallel making it a good format for use in big data applications with cluster computing frameworks like hadoop and apache spark implementations in addition to julian sewards original reference implementation the following programs support bzip format