java memory model the java memory model describes how threads in the java programming language interact through memory together with the description of singlethreaded execution of code the memory model provides the semantics of the java programming language the original java memory model developed in  was widely perceived as broken preventing many runtime optimizations and not providing strong enough guarantees for code safety it was updated through the java community process as java specification request  jsr which took effect in  for tiger java  context the java programming language and platform provide thread capabilities synchronization between threads is notoriously difficult for developers this difficulty is compounded because java applications can run on a wide range of processors and operating systems to be able to draw conclusions about a programs behavior javas designers decided they had to clearly define possible behaviors of all java programs on modern platforms code is frequently not executed in the order it was written it is reordered by the compiler the processor and the memory subsystem to achieve maximum performance on multiprocessor architectures individual processors may have their own local caches that are out of sync with main memory it is generally undesirable to require threads to remain perfectly in sync with one another because this would be too costly from a performance point of view this means that at any given time different threads may see different values for the same shared data in a singlethreaded environment it is easy to reason about code execution the typical approach requires the system to implement asifserial semantics for individual threads in isolation when an individual thread executes it will appear as if all of the actions taken by that thread occur in the order they appear in the program even if the actions themselves occur out of order if one thread executes its instructions out of order then another thread might see the fact that those instructions were executed out of order even if that did not affect the semantics of the first thread for example consider two threads with the following instructions executing concurrently where the variables x and y are both initialized to  if no reorderings are performed and the read of y in thread  returns the value  then the subsequent read of x should return the value  because the write to x was performed before the write to y however if the two writes are reordered then the read of y can return the value  and the read of x can return the value  the java memory model jmm defines the allowable behavior of multithreaded programs and therefore describes when such reorderings are possible it places executiontime constraints on the relationship between threads and main memory in order to achieve consistent and reliable java applications by doing this it makes it possible to reason about code execution in a multithreaded environment even in the face of optimizations performed by the dynamic compiler the processors and the caches the memory model for execution of a single thread the rules are simple the java language specification requires a java virtual machine to observe withinthread asifserial semantics the runtime which in this case usually refers to the dynamic compiler the processor and the memory subsystem is free to introduce any useful execution optimizations as long as the result of the thread in isolation is guaranteed to be exactly the same as it would have been had all the statements been executed in the order the statements occurred in the program also called program order the major caveat of this is that asifserial semantics do not prevent different threads from having different views of the data the memory model provides clear guidance about what values are allowed to be returned when the data are read the basic rules imply that individual actions can be reordered as long as the asifserial semantics of the thread are not violated and actions that imply communication between threads such as the acquisition or release of a lock ensure that actions that happen prior to them are seen by other threads that see their effects for example everything that happens before the release of a lock will be seen to be ordered before and visible to everything that happens after a subsequent acquisition of that same lock mathematically there is a partial order called the happensbefore order over all actions performed by the program the happensbefore order subsumes the program order if one action occurs before another in the program order it will occur before the other in the happensbefore order in addition releases and subsequent acquires of locks form edges in the happensbefore graph a read is allowed to return the value of a write if that write is the last write to that variable before the read along some path in the happensbefore order or if the write is not ordered with respect to that read in the happensbefore order impact the java memory model was the first attempt to provide a comprehensive memory model for a popular programming language it was justified by the increasing prevalence of concurrent and parallel systems and the need to provide tools and technologies with clear semantics for such systems since then the need for a memory model has been more widely accepted with similar semantics being provided for languages such as c