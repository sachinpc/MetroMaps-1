java concurrentmap the java programming languages java collections framework version  and later defines and implements the original regular singlethreaded maps and also new threadsafe maps implementing the interface among other concurrent interfaces in java  the  interface was added extending  and the interface was added as a subinterface combination java map interfaces the version  map interface diagram has the shape below sets can be considered subcases of corresponding maps in which the values are always a particular constant which can be ignored although the set api uses corresponding but differently named methods at the bottom is the javautilconcurrentconcurrentnavigablemap which is a multipleinheritance implementations concurrenthashmap for unordered access as defined in the javautilmap interface the javautilconcurrentconcurrenthashmap implements javautilconcurrentconcurrentmap the mechanism is a hash access to a hash table with lists of entries each entry holding a key a value the hash and a next reference previous to java  there were multiple locks each serializing access to a segment of the table in java  native synchronization is used on the heads of the lists themselves and the lists can mutate into small trees when they threaten to grow too large due to unfortunate hash collisions also java  uses the compareandset primitive optimistically to place the initial heads in the table which is very fast performance is on but there are delays occasionally when rehashing is necessary after the hash table expands it never shrinks possibly leading to a memory leak after entries are removed concurrentskiplistmap for ordered access as defined by the javautilnavigablemap interface javautilconcurrentconcurrentskiplistmap was added in java  and implements javautilconcurrentconcurrentmap and also javautilconcurrentconcurrentnavigablemap it is a skip list which uses lockfree techniques to make a tree performance is ologn concurrent modification problem one problem solved by the java  javautilconcurrent package is that of concurrent modification the collection classes it provides may be reliably used by multiple threads all threadshared nonconcurrent maps and other collections need to use some form of explicit locking such as native synchronization in order to prevent concurrent modification or else there must be a way to prove from the program logic that concurrent modification cannot occur concurrent modification of a map by multiple threads will sometimes destroy the internal consistency of the data structures inside the map leading to bugs which manifest rarely or unpredictably and which are difficult to detect and fix also concurrent modification by one thread with read access by another thread or threads will sometimes give unpredictable results to the reader although the maps internal consistency will not be destroyed using external program logic to prevent concurrent modification increases code complexity and creates an unpredictable risk of errors in existing and future code although it enables nonconcurrent collections to be used however either locks or program logic cannot coordinate external threads which may come in contact with the collection modification counters in order to help with the concurrent modification problem the nonconcurrent map implementations and other collections use internal modification counters which are consulted before and after a read to watch for changes the writers increment the modification counters a concurrent modification is supposed to be detected by this mechanism throwing a javautilconcurrentmodificationexception but it is not guaranteed to occur in all cases and should not be relied on the counter maintenance is also a performance reducer for performance reasons the counters are not volatile so it is not guaranteed that changes to them will be propagated between threads collectionssynchronizedmap one solution to the concurrent modification problem is using a particular wrapper class provided by a factory in collections codice which wraps an existing nonthreadsafe map with methods that synchronize on an internal mutex there are also wrappers for the other kinds of collections this is a partial solution because it is still possible that the underlying map can be accessed inadvertently by threads which keep or obtain unwrapped references also all collections implement the but the synchronizedwrapped maps and other wrapped collections do not provide synchronized iterators so the synchronization is left to the client code which is slow and error prone and not possible to expect to be duplicated by other consumers of the synchronized map the entire duration of the iteration must be protected as well furthermore a map which is wrapped twice in different places will have different internal mutex objects on which the synchronizations operate allowing overlap the delegation is a performance reducer but modern justintime compilers often inline heavily limiting the performance reduction here is how the wrapping works inside the wrapper  the mutex is just a final object and m is the final wrapped map the synchronization of the iteration is recommended as follows however this synchronizes on the wrapper rather than on the internal mutex allowing overlap native synchronization any map can be used safely in a multithreaded system by ensuring that all accesses to it are handled by the java synchronization mechanism reentrantreadwritelock the code using a javautilconcurrentreentrantreadwritelock is similar to that for native synchronization however for safety the locks should be used in a tryfinally block so that early exit such as exception throwing or breakcontinue will be sure to pass through the unlock this technique is better than using synchronization because reads can overlap each other there is a new issue in deciding how to prioritize the writes with respect to the reads for simplicity a javautilconcurrentreentrantlock can be used instead which makes no readwrite distinction more operations on the locks are possible than with synchronization such as codice and codice convoys mutual exclusion has a lock convoy problem in which threads may pile up on a lock causing the jvm to need to maintain expensive queues of waiters and to park the waiting threads it is expensive to park and unpark a thread and a slow context switch may occur context switches require from microseconds to milliseconds while the maps own basic operations normally take nanoseconds performance can drop to a small fraction of a single threads throughput as contention increases when there is no or little contention for the lock there is little performance impact however except for the locks contention test modern jvms will inline most of the lock code reducing it to only a few instructions keeping the nocontention case very fast reentrant techniques like native synchronization or javautilconcurrentreentrantreadwritelock however have extra performancereducing baggage in the maintenance of the reentrancy depth affecting the nocontention case as well the convoy problem seems to be easing with modern jvms but it can be hidden by slow context switching in this case latency will increase but throughput will continue to be acceptable with hundreds of threads a context switch time of ms produces a latency in seconds multiple cores mutual exclusion solutions fail to take advantage of all of the computing power of a multiplecore system because only one thread is allowed inside the map code at a time the implementations of the particular concurrent maps provided by the java collections framework and others sometimes take advantage of multiple cores using lock free programming techniques lockfree techniques use operations like the compareandset intrinsic method available on many of the java classes such as atomicreference to do conditional updates of some mapinternal structures atomically the compareandset primitive is augmented in the jcf classes by native code that can do compareandset on special internal parts of some objects for some algorithms using unsafe access the techniques are complex relying often on the rules of interthread communication provided by volatile variables the happensbefore relation special kinds of lockfree retry loops which are not like spin locks in that they always produce progress the compareandset relies on special processorspecific instructions it is possible for any java code to use for other purposes the compareandset method on various concurrent classes to achieve lockfree or even waitfree concurrency which provides finite latency lockfree techniques are simple in many common cases and with some simple collections like stacks the diagram indicates how synchronizing using collectionssynchronizedmap wrapping a regular hashmap purple may not scale as well as concurrenthashmap red the others are the ordered concurrentnavigablemaps airconcurrentmap blue and concurrentskiplistmap cslm green the flat spots may be rehashes producing tables that are bigger than the nursery and concurrenthashmap takes more space note y axis should say puts k system is core i ghz with xmsm to prevent gc gc and jvm process expansion change the curves considerably and some internal lockfree techniques generate garbage on contention predictable latency yet another problem with mutual exclusion approaches is that the assumption of complete atomicity made by some singlethreaded code creates sporadic unacceptably long interthread delays in a concurrent environment in particular iterators and bulk operations like putall and others can take a length of time proportional to the map size delaying other threads that expect predictably low latency for nonbulk operations for example a multithreaded web server cannot allow some responses to be delayed by longrunning iterations of other threads executing other requests that are searching for a particular value related to this is the fact that threads that lock the map do not actually have any requirement ever to relinquish the lock and an infinite loop in the owner thread may propagate permanent blocking to other threads slow owner threads can sometimes be interrupted hashbased maps also are subject to spontaneous delays during rehashing weak consistency the javautilconcurrency packages solution to the concurrent modification problem the convoy problem the predictable latency problem and the multicore problem includes an architectural choice called weak consistency this choice means that reads like get will not block even when updates are in progress and it is allowable even for updates to overlap with themselves and with reads weak consistency allows for example the contents of a concurrentmap to change during an iteration of it by a single thread the iterators are designed to be used by one thread at a time so for example a map containing two entries that are interdependent may be seen in an inconsistent way by a reader thread during modification by another thread an update that is supposed to change the key of an entry kv to an entry kv atomically would need to do a removek and then a putk v while an iteration might miss the entry or see it in two places retrievals return the value for a given key that reflects the latest previous completed update for that key thus there is a happensbefore relation there is no way for concurrentmaps to lock the entire table there is no possibility of concurrentmodificationexception as there is with inadvertent concurrent modification of nonconcurrent maps the size method may take a long time as opposed to the corresponding nonconcurrent maps and other collections which usually include a size field for fast access because they may need to scan the entire map in some way when concurrent modifications are occurring the results reflect the state of the map at some time but not necessarily a single consistent state hence size isempty and containsvalue may be best used only for monitoring concurrentmap  methods there are some operations provided by concurrentmap that are not in map  which it extends  to allow atomicity of modifications the replacek v v will test for the existence of v in the entry identified by k and only if found then the v is replaced by v atomically the new replacekv will do a putkv only if k is already in the map also putifabsentkv will do a putkv only if k is not already in the map and removek v will remove the entry for v only if v is present this atomicity can be important for some multithreaded use cases but is not related to the weakconsistency constraint for concurrentmaps the following are atomic mputifabsentk v is atomic but equivalent to m replacek v is atomic but equivalent to mreplacek v v is atomic but equivalent to mremovek v is atomic but equivalent to concurrentmap  methods because map and concurrentmap are interfaces new methods cannot be added to them without breaking implementations however java  added the capability for default interface implementations and it added to the map interface default implementations of some new methods getordefaultobject v foreachbiconsumer replaceallbifunction computeifabsentk function computeifpresentk bifunction computekbifunction and mergek v bifunction the default implementations in map do not guarantee atomicity but in the concurrentmap overriding defaults these use lock free techniques to achieve atomicity and existing concurrentmap implementations will automatically be atomic the lockfree techniques may be slower than overrides in the concrete classes so concrete classes may choose to implement them atomically or not and document the concurrency properties lockfree atomicity it is possible to use lockfree techniques with concurrentmaps because they include methods of a sufficiently high consensus number namely infinity meaning that any number of threads may be coordinated this example could be implemented with the java  merge but it shows the overall lockfree pattern which is more general this example is not related to the internals of the concurrentmap but to the client codes use of the concurrentmap for example if we want to multiply a value in the map by a constant c atomically the putifabsentk v is also useful when the entry for the key is allowed to be absent this example could be implemented with the java  compute but it shows the overall lockfree pattern which is more general the replacekvv does not accept null parameters so sometimes a combination of them is necessary in other words if v is null then putifabsentk v is invoked otherwise replacekvv is invoked history the java collections framework was designed and developed primarily by joshua bloch and was introduced in jdk  the original concurrency classes came from doug leas collection package