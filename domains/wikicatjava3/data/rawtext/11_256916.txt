oz programming language oz is a multiparadigm programming language developed in the programming systems lab at universit catholique de louvain for programming language education it has a canonical textbook concepts techniques and models of computer programming oz was first designed by gert smolka and his students in  in  development of oz continued in cooperation with the research group of seif haridi and peter van roy at the swedish institute of computer science since  oz has been continually developed by an international group the mozart consortium which originally consisted of saarland university the swedish institute of computer science and the universit catholique de louvain in  the responsibility for managing mozart development was transferred to a core group the mozart board with the express purpose of opening mozart development to a larger community the mozart programming system is the primary implementation of oz it is released with an open source license by the mozart consortium mozart has been ported to different flavors of unix freebsd linux windows and os x language features oz contains most of the concepts of the major programming paradigms including logic functional both lazy evaluation and eager evaluation imperative objectoriented constraint distributed and concurrent programming oz has both a simple formal semantics see chapter  of the book mentioned below and an efficient implementation oz is a concurrencyoriented language as the term was introduced by joe armstrong the main designer of the erlang language a concurrencyoriented language makes concurrency easy to use and efficient oz supports a canonical graphical user interface gui language qtk in addition to multiparadigm programming the major strengths of oz are in constraint programming and distributed programming due to its factored design oz is able to successfully implement a networktransparent distributed programming model this model makes it easy to program open faulttolerant applications within the language for constraint programming oz introduces the idea of computation spaces which allow userdefined search and distribution strategies orthogonal to the constraint domain language overview data structures oz is based on a core language with very few datatypes that can be extended into more practical ones through syntactic sugar basic data structures those data structures are values constant first class and dynamically type checked variable names in oz start with an uppercase letter to distinguish them from literals which always begin with lowercase letter functions functions are first class values allowing higher order functional programming functions may be used with both free and bound variables free variable values is found using static lexical scoping higherorder programming functions are like other oz objects a function can be passed as an attribute to other functions or can be returned in a function anonymous functions like many other functional languages oz supports use of anonymous functions ie functions which do not have a name with higher order programming the symbol  is used to denote these in the following the square function is defined anonymously and passed causing codice to be browsed since anonymous functions dont possess a name it is not possible to define recursive anonymous functions procedures functions in oz are supposed to return a value at the last statement encountered in the body of the function during its execution in the example below the function ret returns  if x   and  otherwise but oz also provides a facility in case a function must not return values such functions are called procedures procedures are defined using the construct proc as follows the above example doesnt return any value it just prints  or  in the oz browser depending on the sign of x dataflow variables and declarative concurrency when the program encounters an unbound variable it waits for a value for example below the thread will wait until both x and y are bound to a value before showing the value of z the value of a dataflow variable cannot be changed once it is bound dataflow variables make it easy to create concurrent stream agents because of the way dataflow variables work it is possible to put threads anywhere in a program and guaranteed that it will have the same result this makes concurrent programming very easy threads are very cheap it is possible to have  threads running at once example trial division sieve this example computes a stream of prime numbers using the trial division algorithm by recursively creating concurrent stream agents that filter out nonprime numbers laziness oz uses eager evaluation by default but lazy evaluation is possible below the fact is only computed when value of x is needed to compute the value of y lazy evaluation gives the possibility of storing truly infinite data structures in oz the power of lazy evaluation can be seen from the following code sample the code above elegantly computes all the regular numbers in an infinite list the actual numbers are computed only when they are needed message passing concurrency the declarative concurrent model can be extended with message passing via simple semantics with a port and a thread asynchronous agents can be defined state and objects it is again possible to extend the declarative model to support state and objectoriented programming with very simple semantics to create a new mutable data structure called cells with these simple semantic changes the whole objectoriented paradigm can be supported with a little syntactic sugar oop becomes well integrated in oz execution speed the execution speed of a program produced by the mozart compiler version  implementing oz  is very slow on a set of benchmarks it averages about  times slower than that of the gnu compiler collection gcc for the c language solving the benchmarkstasks