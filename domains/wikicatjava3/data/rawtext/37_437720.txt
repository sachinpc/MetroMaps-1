memcached memcached pronunciation memcashdee is a generalpurpose distributed memory caching system it is often used to speed up dynamic databasedriven websites by caching data and objects in ram to reduce the number of times an external data source such as a database or api must be read memcached is free and opensource software licensed under the revised bsd license memcached runs on unixlike operating systems at least linux and os x and on microsoft windows it depends on the libevent library memcacheds apis provide a very large hash table distributed across multiple machines when the table is full subsequent inserts cause older data to be purged in least recently used lru order applications using memcached typically layer requests and additions into ram before falling back on a slower backing store such as a database the size of this hash table is often very large it is limited to available memory across all the servers in the cluster of servers in a data centre where high volume wide audience web publishing requires it this may stretch to many gigabytes memcached can be equally valuable for situations where either the number of requests for content is high or the cost of generating a particular piece of content is high memcached was originally developed by danga interactive for livejournal but is now used by many other systems including mocospace youtube reddit survata zynga facebook orange twitter tumblr and wikipedia engine yard and jelastic are using memcached as part of their platform as a service technology stack and heroku offers several memcached services as part of their platform as a service google app engine appscale microsoft azure ibm bluemix and amazon web services also offer a memcached service through an api history memcached was first developed by brad fitzpatrick for his website livejournal on may   it was originally written in perl then later rewritten in c by anatoly vorobey then employed by livejournal software architecture the system uses a clientserver architecture the servers maintain a keyvalue associative array the clients populate this array and query it by key keys are up to  bytes long and values can be at most  megabyte in size clients use clientside libraries to contact the servers which by default expose their service at port  each client knows all servers the servers do not communicate with each other if a client wishes to set or read the value corresponding to a certain key the clients library first computes a hash of the key to determine which server to use then it contacts that server this gives a simple form of sharding and scalable sharednothing architecture across the servers the server computes a second hash of the key to determine where to store or read the corresponding value the servers keep the values in ram if a server runs out of ram it discards the oldest values therefore clients must treat memcached as a transitory cache they cannot assume that data stored in memcached is still there when they need it other databases such as memcachedb couchbase server provide persistent storage while maintaining memcached protocol compatibility if all client libraries use the same hashing algorithm to determine servers then clients can read each others cached data a typical deployment has several servers and many clients however it is possible to use memcached on a single computer acting simultaneously as client and server security most deployments of memcached are within trusted networks where clients may freely connect to any server however sometimes memcached is deployed in untrusted networks or where administrators want to exercise control over the clients that are connecting for this purpose memcached can be compiled with optional sasl authentication support the sasl support requires the binary protocol a presentation at blackhat usa  revealed that a number of large public websites had left memcached open to inspection analysis retrieval and modification of data even within a trusted organisation the flat trust model of memcached may have security implications for efficient simplicity all memcached operations are treated equally clients with a valid need for access to lowsecurity entries within the cache gain access to all entries within the cache even when these are highersecurity and that client has no justifiable need for them if the cache key can be either predicted guessed or found by exhaustive searching its cache entry may be retrieved some attempt to isolate setting and reading data may be made in situations such as high volume web publishing a farm of outwardfacing content servers have read access to memcached containing published pages or page components but no write access where new content is published and is not yet in memcached a request is instead sent to content generation servers that are not publicly accessible to create the content unit and add it to memcached the content server then retries to retrieve it and serve it outwards example code note that all functions described on this page are pseudocode only memcached calls and programming languages may vary based on the api used converting database or object creation queries to use memcached is simple typically when using straight database queries example code would be as follows after conversion to memcached the same call might look like the following the client would first check whether a memcached value with the unique key userrowuserid exists where userid is some number if the result does not exist it would select from the database as usual and set the unique key using the memcached api add function call however if only this api call were modified the server would end up fetching incorrect data following any database update actions the memcached view of the data would become out of date therefore in addition to creating an add call an update call would also be needed using the memcached set function this call would update the currently cached data to match the new data in the database assuming the database query succeeds an alternative approach would be to invalidate the cache with the memcached delete function so that subsequent fetches result in a cache miss similar action would need to be taken when database records were deleted to maintain either a correct or incomplete cache an alternate cacheinvalidation strategy is to store a random number in an agreedupon cache entry and to incorporate this number into all keys that are used to store a particular kind of entry to invalidate all such entries at once change the random number existing entries which were stored using the old number will no longer be referenced and so will eventually expire or be recycled