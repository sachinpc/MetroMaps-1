java native interface in computing the java native interface jni is a programming framework that enables java code running in a java virtual machine jvm to call and be called by native applications programs specific to a hardware and operating system platform and libraries written in other languages such as c c and assembly purpose and features jni enables programmers to write native methods to handle situations when an application cannot be written entirely in the java programming language eg when the standard java class library does not support the platformspecific features or program library it is also used to modify an existing applicationwritten in another programming languageto be accessible to java applications many of the standard library classes depend on jni to provide functionality to the developer and the user eg file io and sound capabilities including performance and platformsensitive api implementations in the standard library allows all java applications to access this functionality in a safe and platformindependent manner the jni framework lets a native method use java objects in the same way that java code uses these objects a native method can create java objects and then inspect and use these objects to perform its tasks a native method can also inspect and use objects created by java application code how the jni works in the jni framework native functions are implemented in separate c or cpp files c provides a slightly simpler interface with jni when the jvm invokes the function it passes a codice pointer a codice pointer and any java arguments declared by the java method a jni function may look like this the codice pointer is a structure that contains the interface to the jvm it includes all of the functions necessary to interact with the jvm and to work with java objects example jni functions are converting native arrays tofrom java arrays converting native strings tofrom java strings instantiating objects throwing exceptions etc basically anything that java code can do can be done using codice albeit with considerably less ease the argument codice is a reference to the java object inside which this native method has been declared for example the following converts a java string to a native string native data types can be mapped tofrom java data types for compound types such as objects arrays and strings the native code must explicitly convert the data by calling methods in the codice mapping types the following table shows the mapping of types between java jni and native code in addition the signature codice would mean the class uniquely specified by that name eg the signature codice refers to the class codice also prefixing codice to the signature makes the array of that type for example codice means the int array type finally a codice signature uses the codice code here these types are interchangeable you can use codice where you normally use an codice and vice versa without any typecasting required however mapping between java strings and arrays to native strings and arrays is different if you use a codice in where a codice would be your code could crash the jvm this is similar with java arrays as illustrated in the example below that takes the sum of all the elements in an array of course there is much more to it than this look for links below for more information jnienv a jni environment pointer jnienv is passed as an argument for each native function mapped to a java method allowing for interaction with the jni environment within the native method this jni interface pointer can be stored but remains valid only in the current thread other threads must first call attachcurrentthread to attach themselves to the vm and obtain a jni interface pointer once attached a native thread works like a regular java thread running within a native method the native thread remains attached to the vm until it calls detachcurrentthread to detach itself to attach to the current thread and get a jni interface pointer to detach from the current thread advanced uses native awt painting not only can native code interface with java it can also draw on a java  which is possible with the java awt native interface the process is almost the same with just a few changes the java awt native interface is only available since jse  access to assembly code jni also allows direct access to assembly code without even going through a c bridge accessing java applications from assembly is also possible in the same way microsofts jdirect and rni microsofts discontinued proprietary implementation of a java virtual machine visual j has a similar mechanism for calling native code from java called the raw native interface rni in addition it has an easy way to call existing native code that isnt itself aware of java such as but not limited to the windows api called jdirect however following the sun  microsoft litigation about this implementation visual j is no longer maintained rni was less clumsy to use than jni because no bookkeeping with a java environment pointer was needed instead all java objects could be accessed directly to facilitate this a tool was used that generated header files from java classes similarly jdirect was easier to use than using the necessary intermediate native library and jni although at present jna is an alternative examples helloworld makesh export ldlibrarypathldlibrarypath javac helloworldjava javah helloworld export javahomeusrlibjvmjavaopenjdk gcc shared fpic i javahomeinclude i javahomeincludelinux libhelloworldc o libhelloworldso java helloworld buildbat set vccprogram files xmicrosoft visual studio vc set msdkcprogram files xmicrosoft sdkswindowsva set javahomecprogram files xjavajdk call vcvcvarsallbat javac helloworldjava javah helloworld vcbincl ijavahomeinclude ijavahomeincludewin ivcinclude ivclib imsdklib libhelloworldc fehelloworlddll ld java helloworld helloworldjava class helloworld helloworldh  do not edit this file  it is machine generated   header for class helloworld  extern c   class helloworld jniexport void jnicall javahelloworldprint libhelloworldc invocation  chmod x makesh  makesh