cilk cilk cilk and cilk plus are generalpurpose programming languages designed for multithreaded parallel computing they are based on the c and c programming languages which they extend these with constructs to express parallel loops and the forkjoin idiom originally developed in the s at the massachusetts institute of technology mit in the group of charles e leiserson cilk was later commercialized as cilk by a spinoff company cilk arts that company was subsequently acquired by intel which increased compatibility with existing c and c code calling the result cilk plus history mit cilk the cilk programming language grew out of three separate projects at the mit laboratory for computer science in april  the three projects were combined and christened cilk the name cilk is not an acronym but an allusion to nice threads silk and the c programming language the cilk compiler was released in september  the original cilk language was based on ansi c with the addition of cilkspecific keywords to signal parallelism when the cilk keywords are removed from cilk source code the result should always be a valid c program called the serial elision or c elision of the full cilk program with the same semantics as the cilk program running on a single processor despite several similarities cilk is not directly related to att bell labs concurrent c cilk was implemented as a translator to c targeting the gnu c compiler gcc the last version cilk  is available from the mit computer science and artificial intelligence laboratory csail but is no longer supported a showcase for cilks capabilities was the cilkchess parallel chessplaying program which won several computer chess prizes in the s including the  open dutch computer chess championship cilk arts and cilk prior to  the market for cilk was restricted to highperformance computing the emergence of multicore processors in mainstream computing means that hundreds of millions of new parallel computers are now being shipped every year cilk arts was formed to capitalize on that opportunity in  leiserson launched cilk arts to create and bring to market a modern version of cilk that supports the commercial needs of an upcoming generation of programmers the company closed a series a venture financing round in october  and its product cilk  shipped in december  cilk differs from cilk in several ways support for c support for loops and hyperobjects a new construct designed to solve data race problems created by parallel accesses to global variables cilk was proprietary software like its predecessor it was implemented as a cilktoc compiler it supported the microsoft and gnu compilers intel cilk plus on july   cilk arts announced on its web site that its products and engineering team were now part of intel corp intel and cilk arts integrated and advanced the technology further resulting in a september  release of intel cilk plus cilk plus adopts simplifications proposed by cilk arts in cilk to eliminate the need for several of the original cilk keywords while adding the ability to spawn functions and to deal with variables involved in reduction operations cilk plus differs from cilk and cilk by adding array extensions being incorporated in a commercial compiler from intel and compatibility with existing debuggers cilk plus was first implemented in the intel c compiler with the release of the intel compiler in intel composer xe  an open source bsdlicensed implementation was contributed by intel to the gnu compiler collection gcc which shipped cilk plus support in version  except for the keyword which was added in gcc  in february  intel announced a clang fork with cilk plus support the intel compiler but not the open source implementations comes with a race detector and a performance analyzer intel has stated its desire to refine cilk plus and to enable it to be implemented by other compilers to gain industry wide adoption it has also released a specification to enable other compatible implementations and has said the trademark will be usable by compliant implementations differences between versions in the original mit cilk implementation the first cilk keyword is in fact codice which identifies a function which is written in cilk since cilk procedures can call c procedures directly but c procedures cannot directly call or spawn cilk procedures this keyword is needed to distinguish cilk code from c code cilk plus removes this restriction as well as the codice keyword so c and c functions can call into cilk plus code and vice versa language features the principle behind the design of the cilk language is that the programmer should be responsible for exposing the parallelism identifying elements that can safely be executed in parallel it should then be left to the runtime environment particularly the scheduler to decide during execution how to actually divide the work between processors it is because these responsibilities are separated that a cilk program can run without rewriting on any number of processors including one task parallelism spawn and sync cilks main addition to c are two keywords that together allow writing taskparallel programs in cilk plus the keywords are spelled and  or and if the cilk plus headers are included below is a recursive implementation of the fibonacci function in cilk with parallel recursive calls which demonstrates the  and keywords the original cilk required any function using these to be annotated with the keyword which is gone as of cilk plus cilk program code is not numbered the numbers have been added only to make the discussion easier to follow if this code was executed by a single processor to determine the value of  that processor would create a frame for  and execute lines  through  on line  it would create spaces in the frame to hold the values of and  on line  the processor would have to suspend the current frame create a new frame to execute the procedure  execute the code of that frame until reaching a return statement and then resume the frame with the value of fib placed into s variable on the next line it would need to suspend again to execute and place the result in s variable when the code is executed on a multiprocessor machine however execution proceeds differently one processor starts the execution of  when it reaches line  however the keyword modifying the call to tells the processor that it can safely give the job to a second processor this second processor can create a frame for  execute its code and store its result in s frame when it finishes the first processor continues executing the code of at the same time a processor is not obligated to assign a spawned procedure elsewhere if the machine only has two processors and the second is still busy on when the processor executing gets to the procedure call the first processor will suspend and execute itself as it would if it were the only processor of course if another processor is available then it will be called into service and all three processors would be executing separate frames simultaneously if the processor executing were to execute line  before both of the other processors had completed their frames it would generate an incorrect result or an error would be trying to add the values stored in and  but one or both of those values would be missing this is the purpose of the keyword which we see in line  it tells the processor executing a frame that it must suspend its own execution until all the procedure calls it has spawned off have returned when is allowed to proceed past the statement in line  it can only be because and have completed and placed their results in and  making it safe to perform calculations on those results the code example above uses the syntax of cilk the original cilk cilk used a rather different syntax that required programming in an explicit continuationpassing style and the fibonacci examples looks as follows inside s recursive case the keyword indicates the creation of a successor thread as opposed to the child threads created by  which executes the subroutine after waiting for the continuation variables and to be filled in by the recursive calls the base case and use a operation to set their continuation variable to the value of  effectively returning the value to the successor thread inlets the two remaining cilk keywords are slightly more advanced and concern the use of inlets ordinarily when a cilk procedure is spawned it can return its results to the parent procedure only by putting those results in a variable in the parents frame as we assigned the results of our spawned procedure calls in the example to codice and codice the alternative is to use an inlet an inlet is a function internal to a cilk procedure which handles the results of a spawned procedure call as they return one major reason to use inlets is that all the inlets of a procedure are guaranteed to operate atomically with regards to each other and to the parent procedure thus avoiding the bugs that could occur if the multiple returning procedures tried to update the same variables in the parent frame at the same time inlets were removed when cilk became cilk and are not present in cilk plus parallel loops cilk added an additional construct the parallel loop denoted in cilk plus these loops look like this implements the parallel map idiom the body of the loop here a call to followed by an assignment to the array  is executed for each value of from zero to in an indeterminate order the optional grain size pragma determines the coarsening any subarray of one hundred or fewer elements is processed sequentially although the cilk specification does not specify the exact behavior of the construct the typical implementation is a divideandconquer recursion as if the programmer had written the reasons for generating a divideandconquer program rather than the obvious alternative a loop that spawncalls the loop body as a function lie in both the grainsize handling and in efficiency doing all the spawning in a single task makes load balancing a bottleneck a review of various parallel loop constructs on hpcwire found the construct to be quite general but noted that the cilk plus specification did not stipulate that its iterations need to be dataindependent so a compiler cannot automatically vectorize a loop the review also noted the fact that reductions eg sums over arrays need additional code reducers and hyperobjects cilk added a kind of objects called hyperobjects that allow multiple strands to share state without race conditions and without using explicit locks each strand has a view on the hyperobject that it can use and update when the strands synchronize the views are combined in a way specified by the programmer the most common type of hyperobject is a reducer which corresponds to the reduction clause in openmp or to the algebraic notion of a monoid each reducer has an identity element and an associative operation that combines two values the archetypal reducer is summation of numbers the identity element is zero and the associative reduce operation computes a sum this reducer is built into cilk and cilk plus other reducers can be used to construct linked lists or strings and programmers can define custom reducers a limitation of hyperobjects is that they provide only limited determinacy burckhardt et al point out that even the sum reducer can result in nondeterministic behavior showing a program that may produce either or depending on the scheduling order array notation intel cilk plus adds notation to express highlevel operations on entire arrays or sections of arrays eg an axpystyle function that is ordinarily written can in cilk plus be expressed as this notation helps the compiler to effectively vectorize the application intel cilk plus allows cc operations to be applied to multiple array elements in parallel and also provides a set of builtin functions that can be used to perform vectorized shifts rotates and reductions similar functionality exists in fortran  cilk plus differs in that it never allocates temporary arrays so memory usage is easier to predict elemental functions in cilk plus an elemental function is a regular function which can be invoked either on scalar arguments or on array elements in parallel they are similar to the kernel functions of opencl pragma simd this pragma gives the compiler permission to vectorize a loop even in cases where autovectorization might fail it is the simplest way to manually apply vectorization workstealing the cilk scheduler uses a policy called workstealing to divide procedure execution efficiently among multiple processors again it is easiest to understand if we look first at how cilk code is executed on a singleprocessor machine the processor maintains a stack on which it places each frame that it has to suspend in order to handle a procedure call if it is executing fib and encounters a recursive call to fib it will save fibs state including its variables and where the code suspended execution and put that state on the stack it will not take a suspended state off the stack and resume execution until the procedure call that caused the suspension and any procedures called in turn by that procedure have all been fully executed with multiple processors things of course change each processor still has a stack for storing frames whose execution has been suspended however these stacks are more like deques in that suspended states can be removed from either end a processor can still only remove states from its own stack from the same end that it puts them on however any processor which is not currently working having finished its own work or not yet having been assigned any will pick another processor at random through the scheduler and try to steal work from the opposite end of their stack suspended states which the stealing processor can then begin to execute the states which get stolen are the states that the processor stolen from would get around to executing last