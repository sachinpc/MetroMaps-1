dylan programming language dylan is a multiparadigm programming language that includes support for functional and objectoriented programming and is dynamic and reflective while providing a programming model designed to support efficient machine code generation including finegrained control over dynamic and static behaviors it was created in the early s by a group led by apple computer a concise and thorough overview of the language may be found in the dylan reference manual dylan derives from scheme and common lisp and adds an integrated object system derived from the common lisp object system clos in dylan all values including numbers characters functions and classes are firstclass objects dylan supports multiple inheritance polymorphism multiple dispatch keyword arguments object introspection patternbased syntax extension macros and many other advanced features programs can express finegrained control over dynamism admitting programs that occupy a continuum between dynamic and static programming and supporting evolutionary development allowing for rapid prototyping followed by incremental refinement and optimization dylans main design goal is to be a dynamic language wellsuited for developing commercial software dylan attempts to address potential performance issues by introducing natural limits to the full flexibility of lisp systems allowing the compiler to clearly understand compilable units ie libraries although deriving much of its semantics from scheme and other lispssome implementations were in fact initially built within existing lisp systemsdylan has an algollike syntax rather than a lisplike prefix syntax history dylan was created in the early s by a group led by apple computer at one point in its development it was intended for use with apples newton computer but the dylan implementation did not reach sufficient maturity in time and newton instead used a combination of c and the newtonscript developed by walter smith apple ended their dylan development effort in  though they made a technology release version available apple dylan tr that included an advanced ide two other groups contributed to the design of the language and developed implementations harlequin released a commercial ide for microsoft windows and carnegie mellon university released an open source compiler for unix systems called gwydion dylan both of these implementations are now open source the harlequin implementation is now known as open dylan and is maintained by a group of volunteers the dylan hackers the dylan language was codenamed ralph james joaquin chose the name dylan for dynamic language syntax dylan uses an algollike syntax designed by michael kahl it is described in great detail in the dylan reference manual this page shows examples of some syntax features that are more unusual many of them come from dylans lisp heritage a simple class with several slots the same class rewritten in the most minimal way possible a factorial function originally dylan used a lisplike prefix syntax which is based on sexpressions by the time the language design was completed it was changed to an algollike syntax with the expectation that it would be more familiar to a wider audience of programmers modules vs namespace in many objectoriented languages classes are the primary means of encapsulation and modularity each class defines a namespace and controls which definitions are externally visible in addition classes in many languages define an indivisible unit that must be used as a wholeif you want to use a string concatenation function you must import and compile against all of string some languages also include a separate explicit namespace or module system that performs encapsulation in a more general way dylan is such a language in dylan the concepts of compileunit and importunit are separated and classes have nothing specifically to do with either a library defines items that should be compiled and handled together while a module defines the namespace classes can be placed together in modules or cut across them as the programmer wishes often the complete definition for a class does not exist in a single module but is spread across several that are optionally collected together different programs can have different definitions of the same class including only what they need for example consider an addon library for regex support on string in some languages in order for the functionality to be included in strings the functionality has to be added to the string namespace itself as soon as you do this the string class becomes larger and people who dont need to use regex still have to pay for it in increased library size for this reason these sorts of addons are typically placed in their own namespaces and objects the downside to this approach is that the new functionality is no longer a part of string instead it is isolated in its own set of functions that have to be called separately instead of codice which would be the natural organization from an oo point of view you use something like codice which effectively reverses the ordering in addition under dylan many interfaces can be defined for the same code for instance the string concatenation method could be placed in both the string interface and the concat interface which collects together all of the different concatenation functions from various classes this is more commonly used in math libraries where functions tend to be applicable to widely differing object types a more practical use of the interface construct is to build public and private versions of a module something that other languages include as a bolt on feature that invariably causes problems and adds syntax under dylan the programmer can simply place every function call in the private or development interface and collect up publicly accessible functions in public under java or c the visibility of an object is defined in the code itself meaning that to support a similar change the programmer would be forced to rewrite the definitions completely and could not have two versions at the same time classes classes in dylan describe slots data members fields ivars etc of objects in a fashion similar to most oo languages all access to slots are via methods as in smalltalk default getter and setter methods are automatically generated based on the slot names in contrast with most other oo languages other methods applicable to the class are often defined outside of the class and thus class definitions in dylan typically include the definition of the storage only for instance define class  end class in this example the class codice is defined the syntax is convention only to make the class names stand outthe angle brackets are merely part of the class name in comparison in some languages the convention is to capitalize the first letter of the class name or to prefix the name with a c or t for example codice inherits from a single class codice and contains two slots codice holding a string for the window title and codice holding an xy point for a corner of the window in this particular example the title has been given a default value while the position has not the optional initkeyword syntax allows the programmer to specify the initial value of the slot when instantiating an object of the class in languages such as c or java the class would also define its interface in this case the definition above has no explicit instructions so in both languages access to the slots and methods is considered codice meaning they can be used only by subclasses in order to allow unrelated code to use the window instances they would have to be declared codice in dylan these sorts of visibility rules are not considered part of the code itself but of the moduleinterface system this adds considerable flexibility for instance one interface used during early development could declare everything public whereas one used in testing and deployment could limit this with c or java these changes would require changes to the source code itself so people wont do it whereas in dylan this is a completely unrelated concept although this example does not use it dylan also supports multiple inheritance methods and generic functions in dylan methods are not intrinsically associated with any particular class methods can be thought of as existing outside of classes like clos dylan is based on multimethods where the specific method to be called is chosen based upon the types of all its arguments the method does not have to be known at compile time the understanding being that the required functionality may be available or may not based on the users preferences under java the same methods would be isolated in a particular class in order to use that functionality the programmer is forced to import that class and refer to it explicitly in order to call the method if that class is not available or unknown at compile time the application simply wont compile in dylan code is isolated from storage in functions many classes have methods that call their own functions thereby looking and feeling like most other oo languages however code may also be located in generic functions meaning they are not attached to a particular class and can be called natively by anyone linking a particular generic function to a method in a class is accomplished this way define method turnblue w   end method this definition is similar to those in other languages and would likely be encapsulated within the codice class note the  setter call which is syntactic sugar for codice the utility of generic methods comes into its own when you consider more generic examples for instance one common function in most languages is the codice which returns some humanreadable form for the object for instance a window might return its title and its position in parens while a string would return itself in dylan these methods could all be collected into a single module called codice thereby removing this code from the definition of the class itself if a particular object did not support a codice it could be easily added in the codice module extensibility this whole concept might strike some readers as very odd the code to handle codice for a window isnt defined in codice this might not make any sense until you consider how dylan handles the call of the codice in most languages when the program is compiled the codice for codice is looked up and replaced with a pointer more or less to the method in dylan this occurs when the program is first run the runtime builds a table of methodnameparameters details and looks up methods dynamically via this table that means that a function for a particular method can be located anywhere not just in the compiletime unit in the end the programmer is given considerable flexibility in terms of where to place their code collecting it along class lines where appropriate and functional lines where its not the implication here is that a programmer can add functionality to existing classes by defining functions in a separate file for instance you might wish to add spell checking to all codices which in most languages would require access to the source code of the string classand such basic classes are rarely given out in source form in dylan and other extensible languages the spell checking method could be added in the codice module defining all of the classes on which it can be applied via the codice construct in this case the actual functionality might be defined in a single generic function which takes a string and returns the errors when the codice module is compiled into your program all strings and other objects will get the added functionality apple dylan apple dylan is the implementation of dylan produced by apple computer it was originally developed for the apple newton product