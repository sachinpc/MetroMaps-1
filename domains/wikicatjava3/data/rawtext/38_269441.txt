swing java swing is a gui widget toolkit for java it is part of oracles java foundation classes jfc an api for providing a graphical user interface gui for java programs swing was developed to provide a more sophisticated set of gui components than the earlier abstract window toolkit awt swing provides a native look and feel that emulates the look and feel of several platforms and also supports a pluggable look and feel that allows applications to have a look and feel unrelated to the underlying platform it has more powerful and flexible components than awt in addition to familiar components such as buttons check boxes and labels swing provides several advanced components such as tabbed panel scroll panes trees tables and lists unlike awt components swing components are not implemented by platformspecific code instead they are written entirely in java and therefore are platformindependent the term lightweight is used to describe such an element swing is currently in the process of being replaced by javafx history the internet foundation classes ifc were a graphics library for java originally developed by netscape communications corporation and first released on december   on april   sun microsystems and netscape communications corporation announced their intention to incorporate ifc with other technologies to form the java foundation classes the java foundation classes were later renamed swing swing introduced a mechanism that allowed the look and feel of every component in an application to be altered without making substantial changes to the application code the introduction of support for a pluggable look and feel allows swing components to emulate the appearance of native components while still retaining the benefits of platform independence originally distributed as a separately downloadable library swing has been included as part of the java standard edition since release  the swing classes and components are contained in the package hierarchy architecture swing is a platformindependent modelviewcontroller gui framework for java which follows a singlethreaded programming model additionally this framework provides a layer of abstraction between the code structure and graphic presentation of a swingbased gui foundations swing is platformindependent because it is completely written in java complete documentation for all swing classes can be found in the java api guide for version  or the java platform standard edition  api specification for version  extensible swing is a highly modularbased architecture which allows for the plugging of various custom implementations of specified framework interfaces users can provide their own custom implementations of these components to override the default implementations using javas inheritance mechanism swing is a componentbased framework whose components are all ultimately derived from the javaxswingjcomponent class swing objects asynchronously fire events have bound properties and respond to a documented set of methods specific to the component swing components are java beans components compliant with the java beans component architecture specifications configurable swings heavy reliance on runtime mechanisms and indirect composition patterns allows it to respond at run time to fundamental changes in its settings for example a swingbased application is capable of hot swapping its userinterface during runtime furthermore users can provide their own look and feel implementation which allows for uniform changes in the look and feel of existing swing applications without any programmatic change to the application code swings high level of flexibility is reflected in its inherent ability to override the native host operating system oss gui controls for displaying itself swing paints its controls using the java d apis rather than calling a native user interface toolkit thus a swing component does not have a corresponding native os gui component and is free to render itself in any way that is possible with the underlying graphics guis however at its core every swing component relies on an awt container since swings extends awts container this allows swing to plug into the host oss gui management framework including the crucial devicescreen mappings and user interactions such as key presses or mouse movements swing simply transposes its own osagnostic semantics over the underlying osspecific components so for example every swing component paints its rendition on the graphic device in response to a call to componentpaint which is defined in awt container but unlike awt components which delegated the painting to their osnative heavyweight widget swing components are responsible for their own rendering this transposition and decoupling is not merely visual and extends to swings management and application of its own osindependent semantics for events fired within its component containment hierarchies generally speaking the swing architecture delegates the task of mapping the various flavors of os gui semantics onto a simple but generalized pattern to the awt container building on that generalized platform it establishes its own rich and complex gui semantics in the form of the model loosely coupled and mvc the swing library makes heavy use of the modelviewcontroller software design pattern which conceptually decouples the data being viewed from the user interface controls through which it is viewed because of this most swing components have associated models which are specified in terms of java interfaces and the programmers can use various default implementations or provide their own the framework provides default implementations of model interfaces for all of its concrete components the typical use of the swing framework does not require the creation of custom models as the framework provides a set of default implementations that are transparently by default associated with the corresponding child class in the swing library in general only complex components such as tables trees and sometimes lists may require the custom model implementations around the applicationspecific data structures to get a good sense of the potential that the swing architecture makes possible consider the hypothetical situation where custom models for tables and lists are wrappers over dao andor ejb services typically swing component model objects are responsible for providing a concise interface defining events fired and accessible properties for the conceptual data model for use by the associated jcomponent given that the overall mvc pattern is a loosely coupled collaborative object relationship pattern the model provides the programmatic means for attaching event listeners to the data model object typically these events are model centric ex a row inserted event in a table model and are mapped by the jcomponent specialization into a meaningful event for the gui component for example the has a model called that describes an interface for how a table would access tabular data a default implementation of this operates on a twodimensional array the view component of a swing jcomponent is the object used to graphically represent the conceptual gui control a distinction of swing as a gui framework is in its reliance on programmatically rendered gui controls as opposed to the use of the native host oss gui controls prior to java  update  this distinction was a source of complications when mixing awt controls which use native controls with swing controls in a gui see mixing awt and swing components finally in terms of visual composition and management swing favors relative layouts which specify the positional relationships between components as opposed to absolute layouts which specify the exact location and size of components this bias towards fluid visual ordering is due to its origins in the applet operating environment that framed the design and development of the original java gui toolkit conceptually this view of the layout management is quite similar to that which informs the rendering of html content in browsers and addresses the same set of concerns that motivated the former relationship to awt since early versions of java a portion of the abstract window toolkit awt has provided platformindependent apis for user interface components in awt each component is rendered and controlled by a native peer component specific to the underlying windowing system by contrast swing components are often described as lightweight because they do not require allocation of native resources in the operating systems windowing toolkit the awt components are referred to as heavyweight components much of the swing api is generally a complementary extension of the awt rather than a direct replacement in fact every swing lightweight interface ultimately exists within an awt heavyweight component because all of the toplevel components in swing    and  extend an awt toplevel container prior to java  update  the use of both lightweight and heavyweight components within the same window was generally discouraged due to zorder incompatibilities however later versions of java have fixed these issues and both swing and awt components can now be used in one gui without zorder issues the core rendering functionality used by swing to draw its lightweight components is provided by java d another part of jfc relationship to swt the standard widget toolkit swt is a competing toolkit originally developed by ibm and now maintained by the eclipse community swts implementation has more in common with the heavyweight components of awt this confers benefits such as more accurate fidelity with the underlying native windowing toolkit at the cost of an increased exposure to the native platform in the programming model there has been significant debate and speculation about the performance of swt versus swing some hinted that swts heavy dependence on jni would make it slower when the gui component and java need to communicate data but faster at rendering when the data model has been loaded into the gui but this has not been confirmed either way a fairly thorough set of benchmarks in  concluded that neither swing nor swt clearly outperformed the other in the general case examples a basic example the following is a rather simple swingbased program it displays a window a  containing a label and a button notice how all instantiation and handling of swing components are done by creating an instance of the class which is subclassed from the runnable class this is then run on the event dispatch thread by use of the method  created in the main method see swing and thread safety although swing code can be run without using this technique for instance by not implementing runnable and moving all commands from the run method to the main method it is considered to be good form as swing is not threadsafe meaning that invoking resources from multiple threads can result in thread interference and memory consistency errors another example in this example let javaxswingjframe be super class and add our own widgets to it in this case a jbutton the layout is set to null using the method since jframe uses javaawtborderlayout as its default layoutmanager with borderlayout anything which is added to the container is placed in the center and stretched to accommodate any other widgets of course most real world gui applications would prefer to use a layoutmanager instead of placing everything on absolute coordinates