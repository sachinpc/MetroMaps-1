go programming language go often referred to as golang is a free and open source programming language created at google in  by robert griesemer rob pike and ken thompson it is a compiled statically typed language in the tradition of algol and c with garbage collection limited structural typing memory safety features and cspstyle concurrent programming features added the language was announced in november  it is used in some of googles production systems as well as by other firms two major implementations exist googles go compiler gc is developed as open source software and targets various platforms including linux os x windows various bsd and unix versions and since  also mobile devices including smartphones a second compiler gccgo is a gcc frontend the gc toolchain is selfhosting since version  history go originated as an experiment by google engineers robert griesemer rob pike and ken thompson to design a new programming language that would resolve common criticisms of other languages while maintaining their positive characteristics the new language was to in later interviews all three of the language designers cited their shared dislike of cs complexity as a primary motivation for designing a new language go  added one tiny language change and one port to macos  sierra plus some experimental ports eg for linux on z systems linuxsx some library changes apply and eg unicode  is now supported language design go is recognizably in the tradition of c but makes many changes to improve conciseness simplicity and safety the following is a brief overview of the features which define go criticism go critics assert that the language designers argue that these tradeoffs are important to gos success and explain some particular decisions at length though they do express openness to adding some form of generic programming in the future and to pragmatic improvements in areas like standardizing ways to apply code generation regarding gc go defenders point to pausetime reduction in later versions eg go  while acknowledging their gc algorithm is not hard realtime syntax gos syntax includes changes from c aimed at keeping code concise and readable a combined declarationinitialization operator was introduced that allows the programmer to write codice or codice without specifying the types of variables this contrasts with cs codice and codice semicolons still terminate statements but are implicit when they would occur at the end of a line functions may return multiple values and returning a codice pair is the conventional way a function indicates an error to its caller in go go adds literal syntaxes for initializing struct parameters by name and for initializing maps and slices as an alternative to cs threestatement codice loop gos codice expressions allow concise iteration over arrays slices strings maps and channels types go has a number of builtin types including numeric ones    etc booleans and character strings  strings are immutable builtin operators and keywords rather than functions provide concatenation comparison and utf encoding and decoding record types can be defined with the keyword for each type and each nonnegative integer constant  there is an array type denoted  arrays of differing lengths are thus of different types dynamic arrays are available as slices denoted for some type  these have a length and a capacity specifying when new memory needs to be allocated to expand the array several slices may share their underlying memory pointers are available for all types and the pointerto type is denoted  addresstaking and indirection use the and operators as in c or happen implicitly through the method call or attribute access syntax there is no pointer arithmetic except via the special type in the standard library for a pair of types   the type is the type of hash tables mapping type keys to type values hash tables are built into the language with special syntax and builtin functions is a channel that allows sending values of type t between concurrent go processes aside from its support for interfaces gos type system is nominal the keyword can be used to define a new named type which is distinct from other named types that have the same layout in the case of a  the same members in the same order some conversions between types eg between the various integer types are predefined and adding a new type may define additional conversions but conversions between named types must always be invoked explicitly for example the keyword can be used to define a type for ipv addresses which are bit unsigned integers type ipvaddr uint with this type definition interprets the value as an ip address simply assigning to a variable of type is a type error constant expressions may be either typed or untyped they are given a type when assigned to a typed variable if the value they represent passes a compiletime check function types are indicated by the keyword they take zero or more parameters and return zero or more values all of which are typed the parameter and return values determine a function type thus is the type of functions that take a and a bit signed integer and return a signed integer of default width and a value of the builtin interface type  any named type has a method set associated with it the ip address example above can be extended with a method for converting an address to a humanreadable representation viz  is this the zero broadcast address  func addr ipvaddr zerobroadcast bool  due to nominal typing this method definition adds a method to  but not on  while methods have special definition and call syntax there is no distinct method type interface system go provides two features that replace class inheritance the first is embedding which can be viewed as an automated form of composition or delegation the second are its interfaces which provides runtime polymorphism interfaces provide a limited form of structural typing in the otherwise nominal type system of go any type that implements all methods of an interface conforms to that interface go interfaces were designed after protocols from the smalltalk programming language multiple sources use the term duck typing when describing go interface although the term duck typing is not precisely defined and therefore not wrong it usually implies that type conformance is not statically checked since conformance to a go interface is checked statically by the go compiler except when performing a type assertion the go authors prefer to use the term structural typing an interface specifies a set of types by listing required methods and their types and is satisfied by any type that has the required methods implementing types do not need to specify their implementing of interfaces so if  are defined as import math type shape interface  type square struct   note no implements declaration type circle struct   no implements declaration here either func c circle area float  return mathpi  mathpowcradius   then both and are implicitly a and can be assigned to a typed variable in formal language gos interface system provides structural rather than nominal typing interfaces can embed other interfaces with the effect of creating a combined interface that is satisfied by exactly the types that implement the embedded interface and any methods that the newly defined interface adds the go standard library uses interfaces to provide genericity in several places including the inputoutput system that is based on the concepts of and  besides calling methods via interfaces go allows converting interface values to other types with a runtime type check the language constructs to do so are the type assertion which checks against a single potential type and the type switch which checks against multiple types the empty interface  is an important corner case because it can refer to an item of any concrete type it is similar to the class in java or c but with the difference that the empty interface is satisfied by any type including builtin types like while in java and c an variable can only hold instances of reference type code using the empty interface cannot simply call methods or builtin operators on the referredto object but it can store the codice value try to convert it to a more useful type via a type assertion or type switch or inspect it with gos codice package because codice can refer to any value it is a limited way to escape the restrictions of static typing like codice in c but with additional runtime type checks interface values are implemented using pointer to data and a second pointer to runtime type information like some other types implemented using pointers in go interface values are codice if uninitialized package system in gos package system each package has a path eg codice or codice and a name eg codice or codice references to other packages definitions must always be prefixed with the other packages name and only the capitalized names from other packages are accessible codice is public but codice is not the codice command can retrieve packages stored in a remote repository such as github and developers are encouraged to develop packages inside a base path corresponding to a source repository such as githubcomusernamepackagename to reduce the likelihood of name collision with future additions to the standard library or other external libraries proposals exist to introduce a proper package management solution for go similar to rusts cargo system or nodes npm system concurrency goroutines and channels the go language has builtin facilities as well as library support for writing concurrent programs concurrency refers not only to cpu parallelism but also to asynchrony letting slow operations like a database or networkread run while the program does other work as is common in eventbased servers the primary concurrency construct is the goroutine a type of lightweight process a function call prefixed with the keyword starts a function in a new goroutine the language specification does not specify how goroutines should be implemented but current implementations multiplex a go processs goroutines onto a smaller set of operating system threads similar to the scheduling performed in erlang while a standard library package featuring most of the classical concurrency control structures mutex locks etc is available idiomatic concurrent programs instead prefer channels which provide send messages between goroutines optional buffers store messages in fifo order and allow sending goroutines to proceed before their messages are received channels are typed so that a channel of type can only be used to transfer messages of type  special syntax is used to operate on them is an expression that causes the executing goroutine to block until a value comes in over the channel  while sends the value possibly blocking until another goroutine receives the value the builtin like statement can be used to implement nonblocking communication on multiple channels see below for an example go has a memory model describing how goroutines must use channels or other operations to safely share data the existence of channels sets go apart from actor modelstyle concurrent languages like erlang where messages are addressed directly to actors corresponding to goroutines the actor style can be simulated in go by maintaining a onetoone correspondence between goroutines and channels but the language allows multiple goroutines to share a channel or a single goroutine to send and receive on multiple channels from these tools one can build concurrent constructs like worker pools pipelines in which say a file is decompressed and parsed as it downloads background calls with timeout fanout parallel calls to a set of services and others channels have also found uses further from the usual notion of interprocess communication like serving as a concurrencysafe list of recycled buffers implementing coroutines which helped inspire the name goroutine and implementing iterators concurrencyrelated structural conventions of go channels and alternative channel inputs are derived from tony hoares communicating sequential processes model unlike previous concurrent programming languages such as occam or limbo a language on which go codesigner rob pike worked go does not provide any builtin notion of safe or verifiable concurrency while the communicatingprocesses model is favored in go it is not the only one all goroutines in a program share a single address space this means that mutable objects and pointers can be shared between goroutines see  below suitability for parallel programming although gos concurrency features are not aimed primarily at parallel processing they can be used to program shared memory multiprocessor machines various studies have been done into the effectiveness of this approach one of these studies compared the size in lines of code and speed of programs written by a seasoned programmer not familiar with the language and corrections to these programs by a go expert from googles development team doing the same for chapel cilk and intel tbb the study found that the nonexpert tended to write divideandconquer algorithms with one statement per recursion while the expert wrote distributeworksynchronize programs using one goroutine per processor the experts programs were usually faster but also longer lack of race condition safety there are no restrictions on how goroutines access shared data making race conditions possible specifically unless a program explicitly synchronizes via channels or other means writes from one goroutine might be partly entirely or not at all visible to another often with no guarantees about ordering of writes furthermore gos internal data structures like interface values slice headers hash tables and string headers are not immune to race conditions so type and memory safety can be violated in multithreaded programs that modify shared instances of those types without synchronization instead of language support safe concurrent programming thus relies on conventions for example chisnall recommends an idiom called aliases xor mutable meaning that passing a mutable value or pointer over a channel signals a transfer of ownership over the value to its receiver omissions go deliberately omits certain features common in other languages including implementation inheritance generic programming assertions pointer arithmetic and implicit type conversions of these language features the go authors express an openness to generic programming explicitly argue against assertions and pointer arithmetic while defending the choice to omit type inheritance as giving a more useful language encouraging instead the use of interfaces to achieve dynamic dispatch and composition to reuse code composition and delegation are in fact largely automated by embedding according to researchers schmager et al this feature has many of the drawbacks of inheritance it affects the public interface of objects it is not finegrained ie no methodlevel control over embedding methods of embedded objects cannot be hidden and it is static making it not obvious whether programmers will not overuse it to the extent that programmers in other languages are reputed to overuse inheritance regarding generic programming some builtin functions are in fact typegeneric but these are treated as special cases rob pike calls this a weakness of the language that may at some point be changed the google team that designs the language built at least one compiler for an experimental go dialect with generics but did not release it after initially omitting exceptions the exceptionlike  mechanism was eventually added to the language which the go authors advise using for unrecoverable errors such as those that should halt an entire program or server request or as a shortcut to propagate errors up the stack within a package but not across package boundaries there error returns are the standard api conventions and code style the go authors put substantial effort into molding the style and design of go programs language tools go includes the same sort of debugging testing and codevetting tools as many language distributions the go distribution includes among other tools it also includes profiling and debugging support runtime instrumentation to for example track garbage collection pauses and a race condition tester there is an ecosystem of thirdparty tools that add to the standard distribution such as codice which enables code autocompletion in many text editors codice by a go team member which automatically addsremoves package imports as needed codice which detects code that might unintentionally ignore errors and more plugins exist to add language support in widely used text editors and at least one ide liteide is branded as a simple open source crossplatform go ide examples hello world here is a hello world program in go package main import fmt func main  concurrency example the following simple program demonstrates gos concurrency features to implement an asynchronous program it launches two goroutines lightweight threads one waits for the user to type some text while the other implements a timeout the statement waits for either of these goroutines to send a message to the main routine and acts on the first message to arrive example adapted from chisnall package main import  func readwordch chan string  func timeoutt chan bool  func main  projects using go some notable opensource applications in go include other notable companies and sites using go generally together with other languages not exclusively include reception gos initial release led to much discussion the interface system and the deliberate omission of inheritance were praised by michele simionato who likened these language characteristics to those of standard ml calling it a shame that no popular language has followed this particular route in the design space dave astels at engine yard wrote ars technica interviewed rob pike one of the authors of go and asked why a new language was needed he replied that go was named programming language of the year by the tiobe programming community index in its first year  for having a larger month increase in popularity in only  months after its introduction in november than any other language that year and reached th place by january  surpassing established languages like pascal by june of  its ranking had dropped to below th in the index placing it lower than cobol and fortran but  its ranking had surged to th indicating significant growth in popularity and adoption regarding go bruce eckel has stated a  evaluation of the language and its implementation in comparison to c gcc java and scala by a google engineer found that the evaluation got a rebuttal from the go development team ian lance taylor who had improved the go code for hundts paper had not been aware of the intention to publish his code and says that his version was never intended to be an example of idiomatic or efficient go russ cox then did optimize the go code as well as the c code and got the go code to run slightly faster than c and more than an order of magnitude faster than the optimized code in the paper naming dispute on  november  the day of the general release of the language francis mccabe developer of the go programming language note the exclamation point requested a name change of googles language to prevent confusion with his language which he had spent  years developing mccabe raised concerns that the big guy will end up steamrollering over him and this concern resonated with the more than  developers who commented on googles official issues thread saying they should change the name with some even saying the issue contradicts googles motto of dont be evil the issue was closed by a google developer on  october  with the custom status unfortunate and with the following comment there are many computing products and services named go in the  months since our release there has been minimal confusion of the two languages