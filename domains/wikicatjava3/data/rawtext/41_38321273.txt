java bytecode java bytecode is the instruction set of the java virtual machine each bytecode is composed of one or in some cases two bytes that represent the instruction opcode along with zero or more bytes for passing parameters of the  possible bytelong opcodes   are in use   are reserved for future use  and  instructions  are set aside as permanently unimplemented the java bytecode system does not directly support floating point operations beyond  bits except indirectly via bytecodes that enable use of bit and bit intermediate ieee floating point operations relation to java a java programmer does not need to be aware of or understand java bytecode at all however as suggested in the ibm developerworks journal understanding bytecode and what bytecode is likely to be generated by a java compiler helps the java programmer in the same way that knowledge of assembly helps the c or c programmer instructions fall into a number of broad groups there are also a few instructions for a number of more specialized tasks such as exception throwing synchronization etc many instructions have prefixes andor suffixes referring to the types of operands they operate on these are as follows for example iadd will add two integers while dadd will add two doubles the const load and store instructions may also take a suffix of the form n where n is a number from  for load and store the maximum n for const differs by type the const instructions push a value of the specified type onto the stack for example iconst will push an integer  while dconst will push a double  there is also an aconstnull which pushes null the n for the load and store instructions specifies the location in the variable table to load from or store to the aload instruction pushes the object in variable  onto the stack this is usually the this object istore stores the integer on the top of the stack into variable  for variables with higher numbers the suffix is dropped and operands must be used example consider the following java code a java compiler might translate the java code above into byte code as follows assuming the above was put in a method generation the most common language targeting java virtual machine by producing java bytecode is java originally only one compiler existed the javac compiler from sun microsystems which compiles java source code to java bytecode but because all the specifications for java bytecode are now available other parties have supplied compilers that produce java bytecode examples of other compilers include some projects provide java assemblers to enable writing java bytecode by hand assembly code may be also generated by machine for example by a compiler targeting a java virtual machine notable java assemblers include others have developed compilers for different programming languages in order to target the java virtual machine such as execution there are several machines available today both free and commercial products if executing java bytecode in a java virtual machine is not desirable a developer can also compile java source code or java bytecode directly to native machine code with tools such as the gnu compiler for java some processors can execute java bytecode natively such processors are known as java processors support for dynamic languages the java virtual machine provides some support for dynamically typed languages most of the existing jvm instruction set is statically typed  in the sense that method calls have their signatures typechecked at compile time without a mechanism to defer this decision to run time or to choose the method dispatch by an alternative approach jsr  supporting dynamically typed languages on the java platform added a new codice instruction at the jvm level to allow method invocation relying on dynamic type checking instead of the existing statically typechecked codice instruction the da vinci machine is a prototype virtual machine implementation that hosts jvm extensions aimed at supporting dynamic languages all jvms supporting jse  also include the codice opcode