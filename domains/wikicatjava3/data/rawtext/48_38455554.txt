julia programming language julia is a highlevel dynamic programming language designed to address the requirements of highperformance numerical and scientific computing while also being effective for generalpurpose programming web use or as a specification language distinctive aspects of julias design include a type system with parametric types in a fully dynamic programming language and multiple dispatch as its core programming paradigm it allows concurrent parallel and distributed computing and direct calling of c and fortran libraries without glue code julia is garbagecollected uses eager evaluation and includes efficient libraries for floatingpoint calculations linear algebra random number generation fast fourier transforms and regular expression matching language features according to the official website the main features of the language are multiple dispatch also known as multimethods in lisp is a generalization of single dispatch the polymorphic mechanism used in common object oriented oo languages that uses inheritance in julia all concrete types are subtypes of abstract types directly or indirectly subtypes of the any type which is the top of the type hierarchy concrete types can not be subtyped but composition is used over inheritance that is used by traditional objectoriented languages see also inheritance vs subtyping julia draws significant inspiration from various dialects of lisp including scheme and common lisp and it shares many features with dylan such as an algollike freeform infix syntax rather than a lisplike prefix syntax while in julia everything is an expression also a multipledispatchoriented dynamic language and fortress another numerical programming language with multiple dispatch and a sophisticated parametric type system while clos adds multiple dispatch to common lisp not all functions are generic functions in julia dylan and fortress extensibility is the default and the systems builtin functions are all generic and extensible in dylan multiple dispatch is as fundamental as it is in julia all userdefined functions and even basic builtin operations like codice are generic dylans type system however does not fully support parametric types which are more typical of the ml lineage of languages by default clos does not allow for dispatch on common lisps parametric types such extended dispatch semantics can only be added as an extension through the clos metaobject protocol by convergent design fortress also features multiple dispatch on parametric types unlike julia however fortress is statically rather than dynamically typed with separate compilation and execution phases the language features are summarized in the following table julias syntactic macros used for metaprogramming like lisp macros are more powerful and different from textsubstitution macros used in the preprocessor of some other languages such as c because they work at the level of abstract syntax trees asts julias macro system is hygienic but also supports deliberate capture when desired like for anaphoric macros using the codice construct interaction the julia official distribution includes an interactive session shell called julias repl which can be used to experiment and test code quickly the following fragment represents a sample session on the repl the repl gives user access to the system shell and to help mode by pressing codice or codice after the prompt preceding each command respectively the repl also keeps the history of commands even between sessions for other examples see the julia documentation which gives code that can be tested inside the julias interactive section or saved into a file with a codice extension and run from the command line by typing for example julia is also supported by jupyter an online interactive notebooks environment project jupyter is a multilanguage extension that evolved from the ipython command shell now includes ijulia see for other ways in the next section to use julia with other languages julias keyword is used to call cexported or fortran shared library functions individually julia has unicode  support with utf used for source code and by default for strings and eg optionally allowing common math symbols for many operators such as  for the codice operator julia has packages supporting markup languages such as html and also for http xml json and bson implementation julias core is implemented in c and c the llvm dependency is in c its parser in scheme femtolisp and the llvm compiler framework is used for justintime jit generation of bit or bit optimized machine code ie not for vm depending on the platform julia runs on with some exceptions eg libuv the standard library is implemented in julia itself the most notable aspect of julias implementation is its speed which is often within a factor of two relative to fully optimized c code and thus often an order of magnitude faster than python or r development of julia began in  and an opensource version was publicized in february  julia the x line is on a monthly release schedule where bugs are fixed and some new features from dev are backported and possibly also to x current and future platforms while julia uses jit mcjit from llvm julia generates native machine code directly the first time a function is run not a bytecode that is run on a vm as with eg javajvm or javadalvik in android current support is for  and bit all except for ancient prepentium era to optimize for newer x processors and with download of executables or source code also available for other architectures experimental and early support for arm aarch and power littleendian is available too including support for raspberry pi  and later eg requires at least armv support for gnu hurd is being worked on julia version  is planned for  and  for  and some features are discussed for  that is also planned eg multiple inheritance for abstract types juliac sourcetosource compiler a juliac sourcetosource compiler from intel labs is available this sourcetosource compiler is a fork of julia that implements the same julia language syntax which emits c code for compatibility with more cpus instead of native machine code for functions or whole programs the compiler is also meant to allow analyzing code at a higher level than c intels parallelacceleratorjl can be thought of as a partial julia to c compiler but the objective is parallel speedup can by x over plain julia for the older  version and could in cases also speed up serial code manyfold for that version not compiling the full language to c its only an implementation detail that may be dropped later it needs not compile all syntax as the rest is handled by julia